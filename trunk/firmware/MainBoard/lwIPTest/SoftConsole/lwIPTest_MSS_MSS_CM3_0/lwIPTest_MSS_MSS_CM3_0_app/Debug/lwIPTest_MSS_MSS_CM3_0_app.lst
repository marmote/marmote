
lwIPTest_MSS_MSS_CM3_0_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         00000470  00000000  60000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00008ecc  00000470  60000470  00008470  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000020  20000000  6000933c  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000095d0  20000020  6000935c  00018020  2**3
                  ALLOC
  4 .comment      00000891  00000000  00000000  00018020  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000908  00000000  00000000  000188b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000eaa  00000000  00000000  000191b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000c68d  00000000  00000000  0001a063  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000026c7  00000000  00000000  000266f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000b754  00000000  00000000  00028db7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001bb4  00000000  00000000  0003450c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003be6  00000000  00000000  000360c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002d24  00000000  00000000  00039ca6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 000e1ad7  00000000  00000000  0003c9ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000025  00000000  00000000  0011e4a1  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00000870  00000000  00000000  0011e4c6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000470 <__do_global_dtors_aux>:
     470:	f240 0320 	movw	r3, #32
     474:	f2c2 0300 	movt	r3, #8192	; 0x2000
     478:	781a      	ldrb	r2, [r3, #0]
     47a:	b90a      	cbnz	r2, 480 <__do_global_dtors_aux+0x10>
     47c:	2001      	movs	r0, #1
     47e:	7018      	strb	r0, [r3, #0]
     480:	4770      	bx	lr
     482:	bf00      	nop

00000484 <frame_dummy>:
     484:	f240 0000 	movw	r0, #0
     488:	f2c2 0000 	movt	r0, #8192	; 0x2000
     48c:	b508      	push	{r3, lr}
     48e:	6803      	ldr	r3, [r0, #0]
     490:	b12b      	cbz	r3, 49e <frame_dummy+0x1a>
     492:	f240 0300 	movw	r3, #0
     496:	f2c0 0300 	movt	r3, #0
     49a:	b103      	cbz	r3, 49e <frame_dummy+0x1a>
     49c:	4798      	blx	r3
     49e:	bd08      	pop	{r3, pc}

000004a0 <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static err_t
low_level_init(struct netif *netif)
{
     4a0:	b580      	push	{r7, lr}
     4a2:	b084      	sub	sp, #16
     4a4:	af00      	add	r7, sp, #0
     4a6:	6078      	str	r0, [r7, #4]
  netif->hwaddr[3] = STATIC_MACADDR3;
  netif->hwaddr[4] = STATIC_MACADDR4;
  netif->hwaddr[5] = STATIC_MACADDR5;
*/
  /* maximum transfer unit */
  netif->mtu = 1500;
     4a8:	687b      	ldr	r3, [r7, #4]
     4aa:	f240 52dc 	movw	r2, #1500	; 0x5dc
     4ae:	841a      	strh	r2, [r3, #32]

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
     4b0:	687b      	ldr	r3, [r7, #4]
     4b2:	f04f 0232 	mov.w	r2, #50	; 0x32
     4b6:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

  /* Do whatever else is needed to initialize interface. */
//SmartFusion begin
  MSS_MAC_init(  MSS_PHY_ADDRESS_AUTO_DETECT );
     4ba:	f04f 00ff 	mov.w	r0, #255	; 0xff
     4be:	f006 f9a3 	bl	6808 <MSS_MAC_init>
//  MSS_MAC_init(  1 );
  // Configure the MAC.

  int32_t mac_cfg;
  mac_cfg = MSS_MAC_get_configuration();
     4c2:	f006 fc49 	bl	6d58 <MSS_MAC_get_configuration>
     4c6:	4603      	mov	r3, r0
     4c8:	60fb      	str	r3, [r7, #12]

  mac_cfg &= ~( MSS_MAC_CFG_STORE_AND_FORWARD | MSS_MAC_CFG_PASS_BAD_FRAMES );
     4ca:	68fb      	ldr	r3, [r7, #12]
     4cc:	f423 7301 	bic.w	r3, r3, #516	; 0x204
     4d0:	60fb      	str	r3, [r7, #12]
  mac_cfg |=
     4d2:	68fb      	ldr	r3, [r7, #12]
     4d4:	f043 03a3 	orr.w	r3, r3, #163	; 0xa3
     4d8:	60fb      	str	r3, [r7, #12]
  		MSS_MAC_CFG_PROMISCUOUS_MODE |
  		MSS_MAC_CFG_FULL_DUPLEX_MODE |
  		MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE |
  		MSS_MAC_CFG_THRESHOLD_CONTROL_00;

  MSS_MAC_configure( mac_cfg );
     4da:	68fb      	ldr	r3, [r7, #12]
     4dc:	4618      	mov	r0, r3
     4de:	f006 fb1f 	bl	6b20 <MSS_MAC_configure>
  MSS_MAC_set_mac_address( (uint8_t *) &(netif->hwaddr[0]) );
     4e2:	687b      	ldr	r3, [r7, #4]
     4e4:	f103 0323 	add.w	r3, r3, #35	; 0x23
     4e8:	4618      	mov	r0, r3
     4ea:	f007 f815 	bl	7518 <MSS_MAC_set_mac_address>
//SmartFusion end

  return ERR_OK;
     4ee:	f04f 0300 	mov.w	r3, #0
     4f2:	b25b      	sxtb	r3, r3
}
     4f4:	4618      	mov	r0, r3
     4f6:	f107 0710 	add.w	r7, r7, #16
     4fa:	46bd      	mov	sp, r7
     4fc:	bd80      	pop	{r7, pc}
     4fe:	bf00      	nop

00000500 <low_level_output>:
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
     500:	b580      	push	{r7, lr}
     502:	f5ad 6d01 	sub.w	sp, sp, #2064	; 0x810
     506:	af00      	add	r7, sp, #0
     508:	f107 0310 	add.w	r3, r7, #16
     50c:	f1a3 030c 	sub.w	r3, r3, #12
     510:	6018      	str	r0, [r3, #0]
     512:	463b      	mov	r3, r7
     514:	6019      	str	r1, [r3, #0]
  struct pbuf *q;

//SmartFusion begin
//  initiate transfer();
  unsigned char out_buffer[2048];
  unsigned char *ptr = out_buffer;
     516:	f107 0310 	add.w	r3, r7, #16
     51a:	f1a3 0308 	sub.w	r3, r3, #8
     51e:	f8c7 380c 	str.w	r3, [r7, #2060]	; 0x80c

#if ETH_PAD_SIZE
  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

  for(q = p; q != NULL; q = q->next) {
     522:	463b      	mov	r3, r7
     524:	681b      	ldr	r3, [r3, #0]
     526:	f8c7 3808 	str.w	r3, [r7, #2056]	; 0x808
     52a:	e018      	b.n	55e <low_level_output+0x5e>
    /* Send the data from the pbuf to the interface, one pbuf at a
       time. The size of the data in each pbuf is kept in the ->len
       variable. */
//SmartFusion begin
//    send data from(q->payload, q->len);
      memcpy((void*) ptr, q->payload, q->len);
     52c:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
     530:	685a      	ldr	r2, [r3, #4]
     532:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
     536:	895b      	ldrh	r3, [r3, #10]
     538:	f8d7 080c 	ldr.w	r0, [r7, #2060]	; 0x80c
     53c:	4611      	mov	r1, r2
     53e:	461a      	mov	r2, r3
     540:	f008 fb70 	bl	8c24 <memcpy>
      ptr += q->len;
     544:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
     548:	895b      	ldrh	r3, [r3, #10]
     54a:	f8d7 280c 	ldr.w	r2, [r7, #2060]	; 0x80c
     54e:	4413      	add	r3, r2
     550:	f8c7 380c 	str.w	r3, [r7, #2060]	; 0x80c

#if ETH_PAD_SIZE
  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

  for(q = p; q != NULL; q = q->next) {
     554:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
     558:	681b      	ldr	r3, [r3, #0]
     55a:	f8c7 3808 	str.w	r3, [r7, #2056]	; 0x808
     55e:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
     562:	2b00      	cmp	r3, #0
     564:	d1e2      	bne.n	52c <low_level_output+0x2c>
//SmartFusion end
  }

//SmartFusion begin
//  signal that packet should be sent();
  if( !MSS_MAC_tx_packet( out_buffer, p->tot_len, MSS_MAC_BLOCKING) )
     566:	463b      	mov	r3, r7
     568:	681b      	ldr	r3, [r3, #0]
     56a:	891a      	ldrh	r2, [r3, #8]
     56c:	f107 0310 	add.w	r3, r7, #16
     570:	f1a3 0308 	sub.w	r3, r3, #8
     574:	4618      	mov	r0, r3
     576:	4611      	mov	r1, r2
     578:	f04f 32ff 	mov.w	r2, #4294967295
     57c:	f006 fc94 	bl	6ea8 <MSS_MAC_tx_packet>
     580:	4603      	mov	r3, r0
     582:	2b00      	cmp	r3, #0
     584:	d102      	bne.n	58c <low_level_output+0x8c>
  {
//      printf("Failed Sending Data to Eth len =%d\n\r", p->tot_len);
      return( ~ERR_OK);
     586:	f04f 03ff 	mov.w	r3, #255	; 0xff
     58a:	e00e      	b.n	5aa <low_level_output+0xaa>

#if ETH_PAD_SIZE
  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

  LINK_STATS_INC(link.xmit);
     58c:	f247 0330 	movw	r3, #28720	; 0x7030
     590:	f2c2 0300 	movt	r3, #8192	; 0x2000
     594:	881b      	ldrh	r3, [r3, #0]
     596:	f103 0301 	add.w	r3, r3, #1
     59a:	b29a      	uxth	r2, r3
     59c:	f247 0330 	movw	r3, #28720	; 0x7030
     5a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     5a4:	801a      	strh	r2, [r3, #0]

  return ERR_OK;
     5a6:	f04f 0300 	mov.w	r3, #0
     5aa:	b25b      	sxtb	r3, r3
}
     5ac:	4618      	mov	r0, r3
     5ae:	f507 6701 	add.w	r7, r7, #2064	; 0x810
     5b2:	46bd      	mov	sp, r7
     5b4:	bd80      	pop	{r7, pc}
     5b6:	bf00      	nop

000005b8 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
     5b8:	b580      	push	{r7, lr}
     5ba:	f5ad 5d80 	sub.w	sp, sp, #4096	; 0x1000
     5be:	b086      	sub	sp, #24
     5c0:	af00      	add	r7, sp, #0
     5c2:	f107 0318 	add.w	r3, r7, #24
     5c6:	f1a3 0314 	sub.w	r3, r3, #20
     5ca:	6018      	str	r0, [r3, #0]
//SmartFusion end

  /* Obtain the size of the packet and put it into the "len"
     variable. */
//SmartFusion begin
  l = 0;
     5cc:	f04f 0300 	mov.w	r3, #0
     5d0:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     5d4:	f100 0016 	add.w	r0, r0, #22
     5d8:	8003      	strh	r3, [r0, #0]
  p = NULL;
     5da:	f04f 0300 	mov.w	r3, #0
     5de:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     5e2:	f101 010c 	add.w	r1, r1, #12
     5e6:	600b      	str	r3, [r1, #0]
  len = MSS_MAC_rx_packet( s_rxBuff, 4096, MSS_MAC_NONBLOCKING );
     5e8:	f107 0318 	add.w	r3, r7, #24
     5ec:	f1a3 030c 	sub.w	r3, r3, #12
     5f0:	4618      	mov	r0, r3
     5f2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
     5f6:	f04f 0200 	mov.w	r2, #0
     5fa:	f006 fe69 	bl	72d0 <MSS_MAC_rx_packet>
     5fe:	4603      	mov	r3, r0
     600:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
     604:	f102 0214 	add.w	r2, r2, #20
     608:	8013      	strh	r3, [r2, #0]
  if (!len)
     60a:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     60e:	f100 0014 	add.w	r0, r0, #20
     612:	8803      	ldrh	r3, [r0, #0]
     614:	2b00      	cmp	r3, #0
     616:	d105      	bne.n	624 <low_level_input+0x6c>
	  return p;
     618:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     61c:	f101 010c 	add.w	r1, r1, #12
     620:	680b      	ldr	r3, [r1, #0]
     622:	e08d      	b.n	740 <low_level_input+0x188>
#if ETH_PAD_SIZE
  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
#endif

  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
     624:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
     628:	f102 0214 	add.w	r2, r2, #20
     62c:	8813      	ldrh	r3, [r2, #0]
     62e:	f04f 0003 	mov.w	r0, #3
     632:	4619      	mov	r1, r3
     634:	f04f 0203 	mov.w	r2, #3
     638:	f002 fade 	bl	2bf8 <pbuf_alloc>
     63c:	4603      	mov	r3, r0
     63e:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     642:	f100 000c 	add.w	r0, r0, #12
     646:	6003      	str	r3, [r0, #0]

  if (p != NULL) {
     648:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     64c:	f101 010c 	add.w	r1, r1, #12
     650:	680b      	ldr	r3, [r1, #0]
     652:	2b00      	cmp	r3, #0
     654:	d055      	beq.n	702 <low_level_input+0x14a>
    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    for(q = p; q != NULL; q = q->next) {
     656:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
     65a:	f102 020c 	add.w	r2, r2, #12
     65e:	6813      	ldr	r3, [r2, #0]
     660:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     664:	f100 0010 	add.w	r0, r0, #16
     668:	6003      	str	r3, [r0, #0]
     66a:	e035      	b.n	6d8 <low_level_input+0x120>
       * actually received size. In this case, ensure the tot_len member of the
       * pbuf is the sum of the chained pbuf len members.
       */
//SmartFusion begin
//      read data into(q->payload, q->len);
      memcpy((u8_t*)q->payload, &s_rxBuff[l], q->len);
     66c:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     670:	f101 0110 	add.w	r1, r1, #16
     674:	680b      	ldr	r3, [r1, #0]
     676:	6859      	ldr	r1, [r3, #4]
     678:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
     67c:	f103 0316 	add.w	r3, r3, #22
     680:	881a      	ldrh	r2, [r3, #0]
     682:	f107 0318 	add.w	r3, r7, #24
     686:	f1a3 030c 	sub.w	r3, r3, #12
     68a:	4413      	add	r3, r2
     68c:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     690:	f100 0010 	add.w	r0, r0, #16
     694:	6802      	ldr	r2, [r0, #0]
     696:	8952      	ldrh	r2, [r2, #10]
     698:	4608      	mov	r0, r1
     69a:	4619      	mov	r1, r3
     69c:	f008 fac2 	bl	8c24 <memcpy>

      l = l + q->len;
     6a0:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     6a4:	f101 0110 	add.w	r1, r1, #16
     6a8:	680b      	ldr	r3, [r1, #0]
     6aa:	895a      	ldrh	r2, [r3, #10]
     6ac:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     6b0:	f100 0016 	add.w	r0, r0, #22
     6b4:	8803      	ldrh	r3, [r0, #0]
     6b6:	4413      	add	r3, r2
     6b8:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     6bc:	f101 0116 	add.w	r1, r1, #22
     6c0:	800b      	strh	r3, [r1, #0]
    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    for(q = p; q != NULL; q = q->next) {
     6c2:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
     6c6:	f102 0210 	add.w	r2, r2, #16
     6ca:	6813      	ldr	r3, [r2, #0]
     6cc:	681b      	ldr	r3, [r3, #0]
     6ce:	f507 5080 	add.w	r0, r7, #4096	; 0x1000
     6d2:	f100 0010 	add.w	r0, r0, #16
     6d6:	6003      	str	r3, [r0, #0]
     6d8:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
     6dc:	f101 0110 	add.w	r1, r1, #16
     6e0:	680b      	ldr	r3, [r1, #0]
     6e2:	2b00      	cmp	r3, #0
     6e4:	d1c2      	bne.n	66c <low_level_input+0xb4>

#if ETH_PAD_SIZE
    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

    LINK_STATS_INC(link.recv);
     6e6:	f247 0330 	movw	r3, #28720	; 0x7030
     6ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6ee:	885b      	ldrh	r3, [r3, #2]
     6f0:	f103 0301 	add.w	r3, r3, #1
     6f4:	b29a      	uxth	r2, r3
     6f6:	f247 0330 	movw	r3, #28720	; 0x7030
     6fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6fe:	805a      	strh	r2, [r3, #2]
     700:	e019      	b.n	736 <low_level_input+0x17e>
  } else {
//SmartFusion begin
//    drop packet();
//SmartFusion end
    LINK_STATS_INC(link.memerr);
     702:	f247 0330 	movw	r3, #28720	; 0x7030
     706:	f2c2 0300 	movt	r3, #8192	; 0x2000
     70a:	899b      	ldrh	r3, [r3, #12]
     70c:	f103 0301 	add.w	r3, r3, #1
     710:	b29a      	uxth	r2, r3
     712:	f247 0330 	movw	r3, #28720	; 0x7030
     716:	f2c2 0300 	movt	r3, #8192	; 0x2000
     71a:	819a      	strh	r2, [r3, #12]
    LINK_STATS_INC(link.drop);
     71c:	f247 0330 	movw	r3, #28720	; 0x7030
     720:	f2c2 0300 	movt	r3, #8192	; 0x2000
     724:	88db      	ldrh	r3, [r3, #6]
     726:	f103 0301 	add.w	r3, r3, #1
     72a:	b29a      	uxth	r2, r3
     72c:	f247 0330 	movw	r3, #28720	; 0x7030
     730:	f2c2 0300 	movt	r3, #8192	; 0x2000
     734:	80da      	strh	r2, [r3, #6]
  }

  return p;
     736:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
     73a:	f102 020c 	add.w	r2, r2, #12
     73e:	6813      	ldr	r3, [r2, #0]
}
     740:	4618      	mov	r0, r3
     742:	f107 0718 	add.w	r7, r7, #24
     746:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
     74a:	46bd      	mov	sp, r7
     74c:	bd80      	pop	{r7, pc}
     74e:	bf00      	nop

00000750 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
     750:	b580      	push	{r7, lr}
     752:	b084      	sub	sp, #16
     754:	af00      	add	r7, sp, #0
     756:	6078      	str	r0, [r7, #4]
  struct pbuf *p;

//  ethernetif = netif->state;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
     758:	6878      	ldr	r0, [r7, #4]
     75a:	f7ff ff2d 	bl	5b8 <low_level_input>
     75e:	4603      	mov	r3, r0
     760:	60fb      	str	r3, [r7, #12]
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     762:	68fb      	ldr	r3, [r7, #12]
     764:	2b00      	cmp	r3, #0
     766:	d011      	beq.n	78c <ethernetif_input+0x3c>
  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
     768:	68fb      	ldr	r3, [r7, #12]
     76a:	685b      	ldr	r3, [r3, #4]
     76c:	60bb      	str	r3, [r7, #8]
          p = NULL;
          break;
  }
*/

  if (ethernet_input( p, netif )!=ERR_OK)
     76e:	68f8      	ldr	r0, [r7, #12]
     770:	6879      	ldr	r1, [r7, #4]
     772:	f001 fb2b 	bl	1dcc <ethernet_input>
     776:	4603      	mov	r3, r0
     778:	b2db      	uxtb	r3, r3
     77a:	2b00      	cmp	r3, #0
     77c:	d007      	beq.n	78e <ethernetif_input+0x3e>
   { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
     pbuf_free(p);
     77e:	68f8      	ldr	r0, [r7, #12]
     780:	f002 fcb8 	bl	30f4 <pbuf_free>
     p = NULL;
     784:	f04f 0300 	mov.w	r3, #0
     788:	60fb      	str	r3, [r7, #12]
     78a:	e000      	b.n	78e <ethernetif_input+0x3e>
//  ethernetif = netif->state;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     78c:	bf00      	nop
   { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
     pbuf_free(p);
     p = NULL;
   }

}
     78e:	f107 0710 	add.w	r7, r7, #16
     792:	46bd      	mov	sp, r7
     794:	bd80      	pop	{r7, pc}
     796:	bf00      	nop

00000798 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
     798:	b580      	push	{r7, lr}
     79a:	b08a      	sub	sp, #40	; 0x28
     79c:	af04      	add	r7, sp, #16
     79e:	6078      	str	r0, [r7, #4]
//SmartFusion begin
    // set MAC address in the network interface...
	netif->hwaddr_len = NETIF_MAX_HWADDR_LEN;
     7a0:	687b      	ldr	r3, [r7, #4]
     7a2:	f04f 0206 	mov.w	r2, #6
     7a6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

	netif->hwaddr[0] = STATIC_MACADDR0;
     7aa:	687b      	ldr	r3, [r7, #4]
     7ac:	f04f 0200 	mov.w	r2, #0
     7b0:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	netif->hwaddr[1] = STATIC_MACADDR1;
     7b4:	687b      	ldr	r3, [r7, #4]
     7b6:	f04f 0200 	mov.w	r2, #0
     7ba:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	netif->hwaddr[2] = STATIC_MACADDR2;
     7be:	687b      	ldr	r3, [r7, #4]
     7c0:	f04f 0223 	mov.w	r2, #35	; 0x23
     7c4:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	netif->hwaddr[3] = STATIC_MACADDR3;
     7c8:	687b      	ldr	r3, [r7, #4]
     7ca:	f04f 0210 	mov.w	r2, #16
     7ce:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	netif->hwaddr[4] = STATIC_MACADDR4;
     7d2:	687b      	ldr	r3, [r7, #4]
     7d4:	f04f 0220 	mov.w	r2, #32
     7d8:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	netif->hwaddr[5] = STATIC_MACADDR5;
     7dc:	687b      	ldr	r3, [r7, #4]
     7de:	f04f 0230 	mov.w	r2, #48	; 0x30
     7e2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

//  netif->state = ethernetif;
  netif->name[0] = IFNAME0;
     7e6:	687b      	ldr	r3, [r7, #4]
     7e8:	f04f 0265 	mov.w	r2, #101	; 0x65
     7ec:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  netif->name[1] = IFNAME1;
     7f0:	687b      	ldr	r3, [r7, #4]
     7f2:	f04f 026e 	mov.w	r2, #110	; 0x6e
     7f6:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
     7fa:	687a      	ldr	r2, [r7, #4]
     7fc:	f241 7381 	movw	r3, #6017	; 0x1781
     800:	f2c0 0300 	movt	r3, #0
     804:	6153      	str	r3, [r2, #20]
  netif->linkoutput = low_level_output;
     806:	687a      	ldr	r2, [r7, #4]
     808:	f240 5301 	movw	r3, #1281	; 0x501
     80c:	f2c0 0300 	movt	r3, #0
     810:	6193      	str	r3, [r2, #24]
  struct ip_addr netmask;
  struct ip_addr gw;

#if (LWIP_DHCP == 0)
          /* No mechanism of obtaining IP address specified, use static IP: */
    IP4_ADDR(&ipaddr,  STATIC_IPADDR0,    STATIC_IPADDR1,
     812:	f64a 03c0 	movw	r3, #43200	; 0xa8c0
     816:	f2c0 2301 	movt	r3, #513	; 0x201
     81a:	617b      	str	r3, [r7, #20]
                       STATIC_IPADDR2,    STATIC_IPADDR3);
    IP4_ADDR(&netmask, STATIC_NET_MASK0,  STATIC_NET_MASK1,
     81c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
     820:	613b      	str	r3, [r7, #16]
                       STATIC_NET_MASK2,  STATIC_NET_MASK3);
    IP4_ADDR(&gw,  STATIC_GW_IPADDR0, STATIC_GW_IPADDR1,
     822:	f64a 03c0 	movw	r3, #43200	; 0xa8c0
     826:	f2c0 1301 	movt	r3, #257	; 0x101
     82a:	60fb      	str	r3, [r7, #12]
    IP4_ADDR(&ipaddr,  0, 0, 0, 0);
    IP4_ADDR(&netmask, 0, 0, 0, 0);
    IP4_ADDR(&gw,      0, 0, 0, 0);
#endif
          /* add and configure the Ethernet interface with default settings */
    netif_add(netif,
     82c:	f107 0114 	add.w	r1, r7, #20
     830:	f107 0210 	add.w	r2, r7, #16
     834:	f107 0c0c 	add.w	ip, r7, #12
     838:	f04f 0300 	mov.w	r3, #0
     83c:	9300      	str	r3, [sp, #0]
     83e:	f240 43a1 	movw	r3, #1185	; 0x4a1
     842:	f2c0 0300 	movt	r3, #0
     846:	9301      	str	r3, [sp, #4]
     848:	f244 73c5 	movw	r3, #18373	; 0x47c5
     84c:	f2c0 0300 	movt	r3, #0
     850:	9302      	str	r3, [sp, #8]
     852:	6878      	ldr	r0, [r7, #4]
     854:	4663      	mov	r3, ip
     856:	f002 f8eb 	bl	2a30 <netif_add>
              &ipaddr, &netmask, &gw,            /* configured IP addresses */
              NULL,                /* use this active object as the state */
              &low_level_init,        /* Ethernet interface initialization */
              &ip_input);                   /* standard IP input processing */

    netif_set_default(netif);
     85a:	6878      	ldr	r0, [r7, #4]
     85c:	f002 f98e 	bl	2b7c <netif_set_default>

    netif_set_up(netif);                       /* bring the interface up */
     860:	6878      	ldr	r0, [r7, #4]
     862:	f002 f99b 	bl	2b9c <netif_set_up>
#if (LWIP_DHCP != 0)
    dhcp_start(netif);         /* start DHCP if configured in lwipopts.h */
#endif
//SmartFusion end

  return ERR_OK;
     866:	f04f 0300 	mov.w	r3, #0
     86a:	b25b      	sxtb	r3, r3
}
     86c:	4618      	mov	r0, r3
     86e:	f107 0718 	add.w	r7, r7, #24
     872:	46bd      	mov	sp, r7
     874:	bd80      	pop	{r7, pc}
     876:	bf00      	nop

00000878 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
     878:	b480      	push	{r7}
     87a:	b083      	sub	sp, #12
     87c:	af00      	add	r7, sp, #0
     87e:	4603      	mov	r3, r0
     880:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     882:	f24e 1300 	movw	r3, #57600	; 0xe100
     886:	f2ce 0300 	movt	r3, #57344	; 0xe000
     88a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     88e:	ea4f 1252 	mov.w	r2, r2, lsr #5
     892:	88f9      	ldrh	r1, [r7, #6]
     894:	f001 011f 	and.w	r1, r1, #31
     898:	f04f 0001 	mov.w	r0, #1
     89c:	fa00 f101 	lsl.w	r1, r0, r1
     8a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     8a4:	f107 070c 	add.w	r7, r7, #12
     8a8:	46bd      	mov	sp, r7
     8aa:	bc80      	pop	{r7}
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
     8b0:	b480      	push	{r7}
     8b2:	b083      	sub	sp, #12
     8b4:	af00      	add	r7, sp, #0
     8b6:	4603      	mov	r3, r0
     8b8:	80fb      	strh	r3, [r7, #6]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
     8ba:	f24e 1300 	movw	r3, #57600	; 0xe100
     8be:	f2ce 0300 	movt	r3, #57344	; 0xe000
     8c2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     8c6:	ea4f 1252 	mov.w	r2, r2, lsr #5
     8ca:	88f9      	ldrh	r1, [r7, #6]
     8cc:	f001 011f 	and.w	r1, r1, #31
     8d0:	f04f 0001 	mov.w	r0, #1
     8d4:	fa00 f101 	lsl.w	r1, r0, r1
     8d8:	f102 0220 	add.w	r2, r2, #32
     8dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     8e0:	f107 070c 	add.w	r7, r7, #12
     8e4:	46bd      	mov	sp, r7
     8e6:	bc80      	pop	{r7}
     8e8:	4770      	bx	lr
     8ea:	bf00      	nop

000008ec <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
     8ec:	b480      	push	{r7}
     8ee:	b083      	sub	sp, #12
     8f0:	af00      	add	r7, sp, #0
     8f2:	4603      	mov	r3, r0
     8f4:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
     8f6:	f24e 1300 	movw	r3, #57600	; 0xe100
     8fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
     8fe:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
     902:	ea4f 1252 	mov.w	r2, r2, lsr #5
     906:	88f9      	ldrh	r1, [r7, #6]
     908:	f001 011f 	and.w	r1, r1, #31
     90c:	f04f 0001 	mov.w	r0, #1
     910:	fa00 f101 	lsl.w	r1, r0, r1
     914:	f102 0260 	add.w	r2, r2, #96	; 0x60
     918:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     91c:	f107 070c 	add.w	r7, r7, #12
     920:	46bd      	mov	sp, r7
     922:	bc80      	pop	{r7}
     924:	4770      	bx	lr
     926:	bf00      	nop

00000928 <MSS_TIM1_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE
 */
static __INLINE void MSS_TIM1_init( mss_timer_mode_t mode )
{
     928:	b580      	push	{r7, lr}
     92a:	b082      	sub	sp, #8
     92c:	af00      	add	r7, sp, #0
     92e:	4603      	mov	r3, r0
     930:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ( Timer1_IRQn );             /* Disable timer 1 irq in the Cortex-M3 NVIC */  
     932:	f04f 0014 	mov.w	r0, #20
     936:	f7ff ffbb 	bl	8b0 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
     93a:	f242 0300 	movw	r3, #8192	; 0x2000
     93e:	f2ce 0304 	movt	r3, #57348	; 0xe004
     942:	f242 0200 	movw	r2, #8192	; 0x2000
     946:	f2ce 0204 	movt	r2, #57348	; 0xe004
     94a:	6b12      	ldr	r2, [r2, #48]	; 0x30
     94c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
     950:	631a      	str	r2, [r3, #48]	; 0x30
    
    TIMER->TIM64_MODE = 0U;                     /* switch to 32 bits mode */
     952:	f245 0300 	movw	r3, #20480	; 0x5000
     956:	f2c4 0300 	movt	r3, #16384	; 0x4000
     95a:	f04f 0200 	mov.w	r2, #0
     95e:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM1ENABLE = 0U;             /* disable timer */
     960:	f240 0300 	movw	r3, #0
     964:	f2c4 230a 	movt	r3, #16906	; 0x420a
     968:	f04f 0200 	mov.w	r2, #0
     96c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    TIMER_BITBAND->TIM1INTEN = 0U;              /* disable interrupt */
     970:	f240 0300 	movw	r3, #0
     974:	f2c4 230a 	movt	r3, #16906	; 0x420a
     978:	f04f 0200 	mov.w	r2, #0
     97c:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    TIMER_BITBAND->TIM1MODE = (uint32_t)mode;   /* set mode (continuous/one-shot) */
     980:	f240 0300 	movw	r3, #0
     984:	f2c4 230a 	movt	r3, #16906	; 0x420a
     988:	79fa      	ldrb	r2, [r7, #7]
     98a:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    
    TIMER->TIM1_RIS = 1U;                       /* clear timer 1 interrupt */
     98e:	f245 0300 	movw	r3, #20480	; 0x5000
     992:	f2c4 0300 	movt	r3, #16384	; 0x4000
     996:	f04f 0201 	mov.w	r2, #1
     99a:	611a      	str	r2, [r3, #16]
    NVIC_ClearPendingIRQ( Timer1_IRQn );        /* clear timer 1 interrupt within NVIC */
     99c:	f04f 0014 	mov.w	r0, #20
     9a0:	f7ff ffa4 	bl	8ec <NVIC_ClearPendingIRQ>
}
     9a4:	f107 0708 	add.w	r7, r7, #8
     9a8:	46bd      	mov	sp, r7
     9aa:	bd80      	pop	{r7, pc}

000009ac <MSS_TIM1_start>:
  The MSS_TIM1_start() function enables Timer 1 and starts its down-counter
  decrementing from the load_value specified in previous calls to the
  MSS_TIM1_load_immediate() or MSS_TIM1_load_background() functions.
 */
static __INLINE void MSS_TIM1_start( void )
{
     9ac:	b480      	push	{r7}
     9ae:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM1ENABLE = 1U;    /* enable timer */
     9b0:	f240 0300 	movw	r3, #0
     9b4:	f2c4 230a 	movt	r3, #16906	; 0x420a
     9b8:	f04f 0201 	mov.w	r2, #1
     9bc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
     9c0:	46bd      	mov	sp, r7
     9c2:	bc80      	pop	{r7}
     9c4:	4770      	bx	lr
     9c6:	bf00      	nop

000009c8 <MSS_TIM1_load_immediate>:
  @param load_value
    The load_value parameter specifies the value from which the Timer 1 down-counter
    will start decrementing from.
 */
static __INLINE void MSS_TIM1_load_immediate( uint32_t load_value )
{
     9c8:	b480      	push	{r7}
     9ca:	b083      	sub	sp, #12
     9cc:	af00      	add	r7, sp, #0
     9ce:	6078      	str	r0, [r7, #4]
    TIMER->TIM1_LOADVAL = load_value;
     9d0:	f245 0300 	movw	r3, #20480	; 0x5000
     9d4:	f2c4 0300 	movt	r3, #16384	; 0x4000
     9d8:	687a      	ldr	r2, [r7, #4]
     9da:	605a      	str	r2, [r3, #4]
}
     9dc:	f107 070c 	add.w	r7, r7, #12
     9e0:	46bd      	mov	sp, r7
     9e2:	bc80      	pop	{r7}
     9e4:	4770      	bx	lr
     9e6:	bf00      	nop

000009e8 <MSS_TIM1_enable_irq>:
  implementation of the Timer1_IRQHandler() function, that will override the
  default implementation, to suit your application.

 */
static __INLINE void MSS_TIM1_enable_irq( void )
{
     9e8:	b580      	push	{r7, lr}
     9ea:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM1INTEN = 1U;
     9ec:	f240 0300 	movw	r3, #0
     9f0:	f2c4 230a 	movt	r3, #16906	; 0x420a
     9f4:	f04f 0201 	mov.w	r2, #1
     9f8:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC_EnableIRQ( Timer1_IRQn );
     9fc:	f04f 0014 	mov.w	r0, #20
     a00:	f7ff ff3a 	bl	878 <NVIC_EnableIRQ>
}
     a04:	bd80      	pop	{r7, pc}
     a06:	bf00      	nop

00000a08 <MSS_TIM1_clear_irq>:
  (ISR) in order to prevent the same interrupt event retriggering a call to the
  ISR.

 */
static __INLINE void MSS_TIM1_clear_irq( void )
{
     a08:	b580      	push	{r7, lr}
     a0a:	af00      	add	r7, sp, #0
    TIMER->TIM1_RIS = 1U;
     a0c:	f245 0300 	movw	r3, #20480	; 0x5000
     a10:	f2c4 0300 	movt	r3, #16384	; 0x4000
     a14:	f04f 0201 	mov.w	r2, #1
     a18:	611a      	str	r2, [r3, #16]
    NVIC_ClearPendingIRQ( Timer1_IRQn );
     a1a:	f04f 0014 	mov.w	r0, #20
     a1e:	f7ff ff65 	bl	8ec <NVIC_ClearPendingIRQ>
}
     a22:	bd80      	pop	{r7, pc}

00000a24 <sys_now>:

#ifdef NETWORKING_ENABLED
// Returns the current time in milliseconds,
// may be the same as sys_jiffies or at least based on it.
u32_t sys_now(void)
{
     a24:	b480      	push	{r7}
     a26:	af00      	add	r7, sp, #0
	return (u32_t) System_ticks;
     a28:	f240 0328 	movw	r3, #40	; 0x28
     a2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a30:	e9d3 2300 	ldrd	r2, r3, [r3]
     a34:	4613      	mov	r3, r2
}
     a36:	4618      	mov	r0, r3
     a38:	46bd      	mov	sp, r7
     a3a:	bc80      	pop	{r7}
     a3c:	4770      	bx	lr
     a3e:	bf00      	nop

00000a40 <set_time_stamp>:
// **************************************************************************

#ifdef ADC_ENABLED
#	ifdef TIME_STAMP
void set_time_stamp(uint8_t buf_num)
{
     a40:	b480      	push	{r7}
     a42:	b083      	sub	sp, #12
     a44:	af00      	add	r7, sp, #0
     a46:	4603      	mov	r3, r0
     a48:	71fb      	strb	r3, [r7, #7]
	static uint32_t counter = 0;

    buffer[buf_num][0] = counter;
     a4a:	79f9      	ldrb	r1, [r7, #7]
     a4c:	f240 6338 	movw	r3, #1592	; 0x638
     a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a54:	681a      	ldr	r2, [r3, #0]
     a56:	f240 0334 	movw	r3, #52	; 0x34
     a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a5e:	ea4f 2141 	mov.w	r1, r1, lsl #9
     a62:	440b      	add	r3, r1
     a64:	601a      	str	r2, [r3, #0]

    counter++;
     a66:	f240 6338 	movw	r3, #1592	; 0x638
     a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a6e:	681b      	ldr	r3, [r3, #0]
     a70:	f103 0201 	add.w	r2, r3, #1
     a74:	f240 6338 	movw	r3, #1592	; 0x638
     a78:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a7c:	601a      	str	r2, [r3, #0]

}
     a7e:	f107 070c 	add.w	r7, r7, #12
     a82:	46bd      	mov	sp, r7
     a84:	bc80      	pop	{r7}
     a86:	4770      	bx	lr

00000a88 <next_DMA_transfer>:
#	endif

void next_DMA_transfer()
{
     a88:	b580      	push	{r7, lr}
     a8a:	af00      	add	r7, sp, #0
#	ifdef TIME_STAMP
	PDMA_load_next_buffer(PDMA_CHANNEL_0,
			(uint32_t) ADC_MEM_ADDRESS,
            (uint32_t) &(buffer[next_DMA_buf][1]),
     a8c:	f240 0334 	movw	r3, #52	; 0x34
     a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a94:	f240 0204 	movw	r2, #4
     a98:	f2c2 0200 	movt	r2, #8192	; 0x2000
     a9c:	7812      	ldrb	r2, [r2, #0]
     a9e:	b2d2      	uxtb	r2, r2
     aa0:	ea4f 12c2 	mov.w	r2, r2, lsl #7
     aa4:	f102 0201 	add.w	r2, r2, #1
     aa8:	ea4f 0282 	mov.w	r2, r2, lsl #2
     aac:	4413      	add	r3, r2
#	endif

void next_DMA_transfer()
{
#	ifdef TIME_STAMP
	PDMA_load_next_buffer(PDMA_CHANNEL_0,
     aae:	f04f 0000 	mov.w	r0, #0
     ab2:	f240 0100 	movw	r1, #0
     ab6:	f2c4 0105 	movt	r1, #16389	; 0x4005
     aba:	461a      	mov	r2, r3
     abc:	f04f 037f 	mov.w	r3, #127	; 0x7f
     ac0:	f005 fcce 	bl	6460 <PDMA_load_next_buffer>
	PDMA_load_next_buffer(PDMA_CHANNEL_0,
			(uint32_t) ADC_MEM_ADDRESS,
            (uint32_t) &(buffer[next_DMA_buf][0]),
            BUFF_LENGTH);
#	endif
}
     ac4:	bd80      	pop	{r7, pc}
     ac6:	bf00      	nop

00000ac8 <pdma_handler>:
//
// **************************************************************************

#ifdef ADC_ENABLED
void pdma_handler( void )
{
     ac8:	b580      	push	{r7, lr}
     aca:	b082      	sub	sp, #8
     acc:	af00      	add	r7, sp, #0
#	ifdef TIME_STAMP
	set_time_stamp(DMA_buf);
     ace:	f240 0331 	movw	r3, #49	; 0x31
     ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ad6:	781b      	ldrb	r3, [r3, #0]
     ad8:	b2db      	uxtb	r3, r3
     ada:	4618      	mov	r0, r3
     adc:	f7ff ffb0 	bl	a40 <set_time_stamp>
#	endif

	DMA_buf = next_DMA_buf;
     ae0:	f240 0304 	movw	r3, #4
     ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ae8:	781b      	ldrb	r3, [r3, #0]
     aea:	b2da      	uxtb	r2, r3
     aec:	f240 0331 	movw	r3, #49	; 0x31
     af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     af4:	701a      	strb	r2, [r3, #0]

	uint8_t next_buf = (next_DMA_buf + 1) % NB_OF_SAMPLE_BUFFERS;
     af6:	f240 0304 	movw	r3, #4
     afa:	f2c2 0300 	movt	r3, #8192	; 0x2000
     afe:	781b      	ldrb	r3, [r3, #0]
     b00:	b2db      	uxtb	r3, r3
     b02:	f103 0101 	add.w	r1, r3, #1
     b06:	f245 5356 	movw	r3, #21846	; 0x5556
     b0a:	f2c5 5355 	movt	r3, #21845	; 0x5555
     b0e:	fb83 0201 	smull	r0, r2, r3, r1
     b12:	ea4f 73e1 	mov.w	r3, r1, asr #31
     b16:	ebc3 0202 	rsb	r2, r3, r2
     b1a:	4613      	mov	r3, r2
     b1c:	ea4f 0343 	mov.w	r3, r3, lsl #1
     b20:	4413      	add	r3, r2
     b22:	ebc3 0201 	rsb	r2, r3, r1
     b26:	4613      	mov	r3, r2
     b28:	71fb      	strb	r3, [r7, #7]
	if (next_buf != NET_buf)
     b2a:	f240 0332 	movw	r3, #50	; 0x32
     b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b32:	781b      	ldrb	r3, [r3, #0]
     b34:	b2db      	uxtb	r3, r3
     b36:	79fa      	ldrb	r2, [r7, #7]
     b38:	429a      	cmp	r2, r3
     b3a:	d005      	beq.n	b48 <pdma_handler+0x80>
		next_DMA_buf = next_buf;
     b3c:	f240 0304 	movw	r3, #4
     b40:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b44:	79fa      	ldrb	r2, [r7, #7]
     b46:	701a      	strb	r2, [r3, #0]

	next_DMA_transfer();
     b48:	f7ff ff9e 	bl	a88 <next_DMA_transfer>
}
     b4c:	f107 0708 	add.w	r7, r7, #8
     b50:	46bd      	mov	sp, r7
     b52:	bd80      	pop	{r7, pc}

00000b54 <data_sent_callback_fn>:
#endif

#ifdef NETWORKING_ENABLED
void data_sent_callback_fn()
{
     b54:	b480      	push	{r7}
     b56:	af00      	add	r7, sp, #0
	if (!still_working_on_last_data)
     b58:	f240 0330 	movw	r3, #48	; 0x30
     b5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b60:	781b      	ldrb	r3, [r3, #0]
     b62:	b2db      	uxtb	r3, r3
     b64:	2b00      	cmp	r3, #0
     b66:	d043      	beq.n	bf0 <data_sent_callback_fn+0x9c>
		return;

	still_working_on_last_data = 0;
     b68:	f240 0330 	movw	r3, #48	; 0x30
     b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b70:	f04f 0200 	mov.w	r2, #0
     b74:	701a      	strb	r2, [r3, #0]
	NET_buf = (NET_buf + 1) % NB_OF_SAMPLE_BUFFERS;
     b76:	f240 0332 	movw	r3, #50	; 0x32
     b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b7e:	781b      	ldrb	r3, [r3, #0]
     b80:	b2db      	uxtb	r3, r3
     b82:	f103 0101 	add.w	r1, r3, #1
     b86:	f245 5356 	movw	r3, #21846	; 0x5556
     b8a:	f2c5 5355 	movt	r3, #21845	; 0x5555
     b8e:	fb83 0201 	smull	r0, r2, r3, r1
     b92:	ea4f 73e1 	mov.w	r3, r1, asr #31
     b96:	ebc3 0202 	rsb	r2, r3, r2
     b9a:	4613      	mov	r3, r2
     b9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
     ba0:	4413      	add	r3, r2
     ba2:	ebc3 0201 	rsb	r2, r3, r1
     ba6:	b2d2      	uxtb	r2, r2
     ba8:	f240 0332 	movw	r3, #50	; 0x32
     bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bb0:	701a      	strb	r2, [r3, #0]

	if (BurstCounter && BurstCounter != FAST_FLOOD)
     bb2:	f240 6334 	movw	r3, #1588	; 0x634
     bb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bba:	781b      	ldrb	r3, [r3, #0]
     bbc:	b2db      	uxtb	r3, r3
     bbe:	2b00      	cmp	r3, #0
     bc0:	d017      	beq.n	bf2 <data_sent_callback_fn+0x9e>
     bc2:	f240 6334 	movw	r3, #1588	; 0x634
     bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bca:	781b      	ldrb	r3, [r3, #0]
     bcc:	b2db      	uxtb	r3, r3
     bce:	2bff      	cmp	r3, #255	; 0xff
     bd0:	d00f      	beq.n	bf2 <data_sent_callback_fn+0x9e>
		BurstCounter--;
     bd2:	f240 6334 	movw	r3, #1588	; 0x634
     bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bda:	781b      	ldrb	r3, [r3, #0]
     bdc:	b2db      	uxtb	r3, r3
     bde:	f103 33ff 	add.w	r3, r3, #4294967295
     be2:	b2da      	uxtb	r2, r3
     be4:	f240 6334 	movw	r3, #1588	; 0x634
     be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bec:	701a      	strb	r2, [r3, #0]
     bee:	e000      	b.n	bf2 <data_sent_callback_fn+0x9e>

#ifdef NETWORKING_ENABLED
void data_sent_callback_fn()
{
	if (!still_working_on_last_data)
		return;
     bf0:	bf00      	nop
	still_working_on_last_data = 0;
	NET_buf = (NET_buf + 1) % NB_OF_SAMPLE_BUFFERS;

	if (BurstCounter && BurstCounter != FAST_FLOOD)
		BurstCounter--;
}
     bf2:	46bd      	mov	sp, r7
     bf4:	bc80      	pop	{r7}
     bf6:	4770      	bx	lr

00000bf8 <Timer1_IRQHandler>:

void Timer1_IRQHandler( void )
{
     bf8:	b580      	push	{r7, lr}
     bfa:	af00      	add	r7, sp, #0
    System_ticks++;
     bfc:	f240 0328 	movw	r3, #40	; 0x28
     c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c04:	e9d3 0100 	ldrd	r0, r1, [r3]
     c08:	f04f 0201 	mov.w	r2, #1
     c0c:	f04f 0300 	mov.w	r3, #0
     c10:	1880      	adds	r0, r0, r2
     c12:	eb41 0103 	adc.w	r1, r1, r3
     c16:	f240 0328 	movw	r3, #40	; 0x28
     c1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c1e:	e9c3 0100 	strd	r0, r1, [r3]
    MSS_TIM1_clear_irq();
     c22:	f7ff fef1 	bl	a08 <MSS_TIM1_clear_irq>
}
     c26:	bd80      	pop	{r7, pc}

00000c28 <receive_callback>:
#define COMMAND_ID_FLOW_CONTROL_STATE	2

#define CMD_SIZE	(1+4+4+2+2+4+1)

void receive_callback(void* data, u16_t len)
{
     c28:	b480      	push	{r7}
     c2a:	b085      	sub	sp, #20
     c2c:	af00      	add	r7, sp, #0
     c2e:	6078      	str	r0, [r7, #4]
     c30:	460b      	mov	r3, r1
     c32:	807b      	strh	r3, [r7, #2]
	static char		state = COMMAND_ID_WAITING_STATE;

	u16_t i;
	for (i = 0; i < len; i++)
     c34:	f04f 0300 	mov.w	r3, #0
     c38:	81fb      	strh	r3, [r7, #14]
     c3a:	e03c      	b.n	cb6 <receive_callback+0x8e>
	{
		if (state == COMMAND_ID_WAITING_STATE)
     c3c:	f240 6335 	movw	r3, #1589	; 0x635
     c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c44:	781b      	ldrb	r3, [r3, #0]
     c46:	2b00      	cmp	r3, #0
     c48:	d10d      	bne.n	c66 <receive_callback+0x3e>
		{
			if (*(((uint8_t*) data) + i) == COMMAND_ID_FLOW_CONTROL_MSG)
     c4a:	687a      	ldr	r2, [r7, #4]
     c4c:	89fb      	ldrh	r3, [r7, #14]
     c4e:	4413      	add	r3, r2
     c50:	781b      	ldrb	r3, [r3, #0]
     c52:	2b01      	cmp	r3, #1
     c54:	d12a      	bne.n	cac <receive_callback+0x84>
				state = COMMAND_ID_FLOW_CONTROL_STATE;
     c56:	f240 6335 	movw	r3, #1589	; 0x635
     c5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c5e:	f04f 0202 	mov.w	r2, #2
     c62:	701a      	strb	r2, [r3, #0]
     c64:	e023      	b.n	cae <receive_callback+0x86>
		}
		else if (state == COMMAND_ID_FLOW_CONTROL_STATE)
     c66:	f240 6335 	movw	r3, #1589	; 0x635
     c6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c6e:	781b      	ldrb	r3, [r3, #0]
     c70:	2b02      	cmp	r3, #2
     c72:	d11c      	bne.n	cae <receive_callback+0x86>
		{
			BurstCounter = *(((uint8_t*) data) + i);
     c74:	687a      	ldr	r2, [r7, #4]
     c76:	89fb      	ldrh	r3, [r7, #14]
     c78:	4413      	add	r3, r2
     c7a:	781a      	ldrb	r2, [r3, #0]
     c7c:	f240 6334 	movw	r3, #1588	; 0x634
     c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c84:	701a      	strb	r2, [r3, #0]

			NET_buf = DMA_buf;
     c86:	f240 0331 	movw	r3, #49	; 0x31
     c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c8e:	781b      	ldrb	r3, [r3, #0]
     c90:	b2da      	uxtb	r2, r3
     c92:	f240 0332 	movw	r3, #50	; 0x32
     c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c9a:	701a      	strb	r2, [r3, #0]

			state = COMMAND_ID_WAITING_STATE;
     c9c:	f240 6335 	movw	r3, #1589	; 0x635
     ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ca4:	f04f 0200 	mov.w	r2, #0
     ca8:	701a      	strb	r2, [r3, #0]
     caa:	e000      	b.n	cae <receive_callback+0x86>
	for (i = 0; i < len; i++)
	{
		if (state == COMMAND_ID_WAITING_STATE)
		{
			if (*(((uint8_t*) data) + i) == COMMAND_ID_FLOW_CONTROL_MSG)
				state = COMMAND_ID_FLOW_CONTROL_STATE;
     cac:	bf00      	nop
void receive_callback(void* data, u16_t len)
{
	static char		state = COMMAND_ID_WAITING_STATE;

	u16_t i;
	for (i = 0; i < len; i++)
     cae:	89fb      	ldrh	r3, [r7, #14]
     cb0:	f103 0301 	add.w	r3, r3, #1
     cb4:	81fb      	strh	r3, [r7, #14]
     cb6:	89fa      	ldrh	r2, [r7, #14]
     cb8:	887b      	ldrh	r3, [r7, #2]
     cba:	429a      	cmp	r2, r3
     cbc:	d3be      	bcc.n	c3c <receive_callback+0x14>
			NET_buf = DMA_buf;

			state = COMMAND_ID_WAITING_STATE;
		}
	}
}
     cbe:	f107 0714 	add.w	r7, r7, #20
     cc2:	46bd      	mov	sp, r7
     cc4:	bc80      	pop	{r7}
     cc6:	4770      	bx	lr

00000cc8 <init_DMA>:
//
// **************************************************************************

#ifdef ADC_ENABLED
void init_DMA()
{
     cc8:	b580      	push	{r7, lr}
     cca:	af00      	add	r7, sp, #0
    PDMA_init();
     ccc:	f005 f9bc 	bl	6048 <PDMA_init>

    PDMA_configure(PDMA_CHANNEL_0,
     cd0:	f04f 0000 	mov.w	r0, #0
     cd4:	f04f 010a 	mov.w	r1, #10
     cd8:	f243 2208 	movw	r2, #12808	; 0x3208
     cdc:	f04f 0300 	mov.w	r3, #0
     ce0:	f005 fa0e 	bl	6100 <PDMA_configure>
				PDMA_FROM_FPGA_0,
				PDMA_HIGH_PRIORITY | PDMA_WORD_TRANSFER | PDMA_INC_DEST_FOUR_BYTES,
				0);

    PDMA_set_irq_handler( PDMA_CHANNEL_0, pdma_handler );
     ce4:	f04f 0000 	mov.w	r0, #0
     ce8:	f640 21c9 	movw	r1, #2761	; 0xac9
     cec:	f2c0 0100 	movt	r1, #0
     cf0:	f005 fd36 	bl	6760 <PDMA_set_irq_handler>
    PDMA_enable_irq( PDMA_CHANNEL_0 );
     cf4:	f04f 0000 	mov.w	r0, #0
     cf8:	f005 fd60 	bl	67bc <PDMA_enable_irq>
}
     cfc:	bd80      	pop	{r7, pc}
     cfe:	bf00      	nop

00000d00 <init_timing>:
#endif

#ifdef NETWORKING_ENABLED
void init_timing()
{
     d00:	b580      	push	{r7, lr}
     d02:	af00      	add	r7, sp, #0
    SystemCoreClockUpdate();
     d04:	f007 fe08 	bl	8918 <SystemCoreClockUpdate>

    MSS_TIM1_init( MSS_TIMER_PERIODIC_MODE );
     d08:	f04f 0000 	mov.w	r0, #0
     d0c:	f7ff fe0c 	bl	928 <MSS_TIM1_init>
    MSS_TIM1_load_immediate( (uint32_t) (g_FrequencyPCLK0/1000) ); //Divide by 1000 means an interrupt at every 1/1000 sec = 1 msec
     d10:	f240 0310 	movw	r3, #16
     d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d18:	681a      	ldr	r2, [r3, #0]
     d1a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
     d1e:	f2c1 0362 	movt	r3, #4194	; 0x1062
     d22:	fba3 1302 	umull	r1, r3, r3, r2
     d26:	ea4f 1393 	mov.w	r3, r3, lsr #6
     d2a:	4618      	mov	r0, r3
     d2c:	f7ff fe4c 	bl	9c8 <MSS_TIM1_load_immediate>
    MSS_TIM1_start();
     d30:	f7ff fe3c 	bl	9ac <MSS_TIM1_start>
    MSS_TIM1_enable_irq();
     d34:	f7ff fe58 	bl	9e8 <MSS_TIM1_enable_irq>
}
     d38:	bd80      	pop	{r7, pc}
     d3a:	bf00      	nop

00000d3c <main>:
// 								Main
//
//
// ****************************************************************
int main()
{
     d3c:	b580      	push	{r7, lr}
     d3e:	b090      	sub	sp, #64	; 0x40
     d40:	af00      	add	r7, sp, #0

	struct netif l_netif;                // the single network interface
	struct udp_pcb *pcb;

#  if LWIP_ARP
    uint64_t arp_timer = 0;
     d42:	f04f 0200 	mov.w	r2, #0
     d46:	f04f 0300 	mov.w	r3, #0
     d4a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

#endif


#ifdef ADC_ENABLED
    init_DMA();
     d4e:	f7ff ffbb 	bl	cc8 <init_DMA>
#endif


#ifdef NETWORKING_ENABLED
    // Initialize hardware necessary for millisecond timing
    init_timing();
     d52:	f7ff ffd5 	bl	d00 <init_timing>

    // Initialize the lwIP stack
    lwip_init();
     d56:	f001 f8f1 	bl	1f3c <lwip_init>

    // initialize the network interface
    ethernetif_init(&l_netif);
     d5a:	f107 0304 	add.w	r3, r7, #4
     d5e:	4618      	mov	r0, r3
     d60:	f7ff fd1a 	bl	798 <ethernetif_init>

    // initialize the simple server
    pcb = server_init(49151);
     d64:	f64b 70ff 	movw	r0, #49151	; 0xbfff
     d68:	f000 f8f0 	bl	f4c <server_init>
     d6c:	4603      	mov	r3, r0
     d6e:	637b      	str	r3, [r7, #52]	; 0x34
#	ifdef TIME_STAMP
//    set_time_stamp(DMA_buf);

	PDMA_start(PDMA_CHANNEL_0,
			(uint32_t) ADC_MEM_ADDRESS,
            (uint32_t) &(buffer[DMA_buf][1]),
     d70:	f240 0334 	movw	r3, #52	; 0x34
     d74:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d78:	f240 0231 	movw	r2, #49	; 0x31
     d7c:	f2c2 0200 	movt	r2, #8192	; 0x2000
     d80:	7812      	ldrb	r2, [r2, #0]
     d82:	b2d2      	uxtb	r2, r2
     d84:	ea4f 12c2 	mov.w	r2, r2, lsl #7
     d88:	f102 0201 	add.w	r2, r2, #1
     d8c:	ea4f 0282 	mov.w	r2, r2, lsl #2
     d90:	4413      	add	r3, r2
//	next_DMA_transfer(); //This would be ideal, but it doesn't work like this. This has to be after PDMA_start

#	ifdef TIME_STAMP
//    set_time_stamp(DMA_buf);

	PDMA_start(PDMA_CHANNEL_0,
     d92:	f04f 0000 	mov.w	r0, #0
     d96:	f240 0100 	movw	r1, #0
     d9a:	f2c4 0105 	movt	r1, #16389	; 0x4005
     d9e:	461a      	mov	r2, r3
     da0:	f04f 037f 	mov.w	r3, #127	; 0x7f
     da4:	f005 fa42 	bl	622c <PDMA_start>
			(uint32_t) ADC_MEM_ADDRESS,
            (uint32_t) &(buffer[DMA_buf][0]),
            BUFF_LENGTH);
#	endif

	next_DMA_transfer();
     da8:	f7ff fe6e 	bl	a88 <next_DMA_transfer>
     dac:	e006      	b.n	dbc <main+0x80>
        	still_working_on_last_data = 1;
        	send_buffer(pcb, (char*) &(buffer[NET_buf][0]), BUFF_LENGTH*sizeof(uint32_t));

        	data_sent_callback_fn();
        }
    }
     dae:	bf00      	nop
     db0:	e004      	b.n	dbc <main+0x80>
     db2:	bf00      	nop
     db4:	e002      	b.n	dbc <main+0x80>
     db6:	bf00      	nop
     db8:	e000      	b.n	dbc <main+0x80>
     dba:	bf00      	nop
    while (1)
    {
#ifdef NETWORKING_ENABLED

#  if LWIP_ARP
        PERIODIC(arp_timer, ARP_TMR_INTERVAL, etharp_tmr());
     dbc:	f240 0328 	movw	r3, #40	; 0x28
     dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     dc4:	e9d3 0100 	ldrd	r0, r1, [r3]
     dc8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
     dcc:	1a82      	subs	r2, r0, r2
     dce:	eb61 0303 	sbc.w	r3, r1, r3
     dd2:	f241 3088 	movw	r0, #5000	; 0x1388
     dd6:	f04f 0100 	mov.w	r1, #0
     dda:	4290      	cmp	r0, r2
     ddc:	eb71 0c03 	sbcs.w	ip, r1, r3
     de0:	d20c      	bcs.n	dfc <main+0xc0>
     de2:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
     de6:	f241 3288 	movw	r2, #5000	; 0x1388
     dea:	f04f 0300 	mov.w	r3, #0
     dee:	1812      	adds	r2, r2, r0
     df0:	eb43 0301 	adc.w	r3, r3, r1
     df4:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
     df8:	f000 f914 	bl	1024 <etharp_tmr>
#  if LWIP_DHCP
        PERIODIC(dhcp_fine_timer, DHCP_FINE_TIMER_MSECS, dhcp_fine_tmr());
        PERIODIC(dhcp_coarse_timer, DHCP_COARSE_TIMER_MSECS, dhcp_coarse_tmr());
#  endif

        ethernetif_input(&l_netif);
     dfc:	f107 0304 	add.w	r3, r7, #4
     e00:	4618      	mov	r0, r3
     e02:	f7ff fca5 	bl	750 <ethernetif_input>

        // if we have stuff to write
        //AND last data is already sent
        //AND we have a live connection
        //AND BurstCounter indicates that receiver is still expecting bursts
        if (	(NET_buf != DMA_buf)
     e06:	f240 0332 	movw	r3, #50	; 0x32
     e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e0e:	781b      	ldrb	r3, [r3, #0]
     e10:	b2da      	uxtb	r2, r3
     e12:	f240 0331 	movw	r3, #49	; 0x31
     e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e1a:	781b      	ldrb	r3, [r3, #0]
     e1c:	b2db      	uxtb	r3, r3
     e1e:	429a      	cmp	r2, r3
     e20:	d0c5      	beq.n	dae <main+0x72>
        		&&
        		!still_working_on_last_data
     e22:	f240 0330 	movw	r3, #48	; 0x30
     e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e2a:	781b      	ldrb	r3, [r3, #0]
     e2c:	b2db      	uxtb	r3, r3

        // if we have stuff to write
        //AND last data is already sent
        //AND we have a live connection
        //AND BurstCounter indicates that receiver is still expecting bursts
        if (	(NET_buf != DMA_buf)
     e2e:	2b00      	cmp	r3, #0
     e30:	d1bf      	bne.n	db2 <main+0x76>
        		&&
        		!still_working_on_last_data
        		&&
        		pcb->remote_port
        		&&
     e32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     e34:	8a9b      	ldrh	r3, [r3, #20]

        // if we have stuff to write
        //AND last data is already sent
        //AND we have a live connection
        //AND BurstCounter indicates that receiver is still expecting bursts
        if (	(NET_buf != DMA_buf)
     e36:	2b00      	cmp	r3, #0
     e38:	d0bd      	beq.n	db6 <main+0x7a>
        		&&
        		!still_working_on_last_data
        		&&
        		pcb->remote_port
        		&&
        		BurstCounter)
     e3a:	f240 6334 	movw	r3, #1588	; 0x634
     e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e42:	781b      	ldrb	r3, [r3, #0]
     e44:	b2db      	uxtb	r3, r3

        // if we have stuff to write
        //AND last data is already sent
        //AND we have a live connection
        //AND BurstCounter indicates that receiver is still expecting bursts
        if (	(NET_buf != DMA_buf)
     e46:	2b00      	cmp	r3, #0
     e48:	d0b7      	beq.n	dba <main+0x7e>
        		&&
        		pcb->remote_port
        		&&
        		BurstCounter)
        {
        	still_working_on_last_data = 1;
     e4a:	f240 0330 	movw	r3, #48	; 0x30
     e4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e52:	f04f 0201 	mov.w	r2, #1
     e56:	701a      	strb	r2, [r3, #0]
        	send_buffer(pcb, (char*) &(buffer[NET_buf][0]), BUFF_LENGTH*sizeof(uint32_t));
     e58:	f240 0334 	movw	r3, #52	; 0x34
     e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e60:	f240 0232 	movw	r2, #50	; 0x32
     e64:	f2c2 0200 	movt	r2, #8192	; 0x2000
     e68:	7812      	ldrb	r2, [r2, #0]
     e6a:	b2d2      	uxtb	r2, r2
     e6c:	ea4f 2242 	mov.w	r2, r2, lsl #9
     e70:	4413      	add	r3, r2
     e72:	6b78      	ldr	r0, [r7, #52]	; 0x34
     e74:	4619      	mov	r1, r3
     e76:	f44f 7200 	mov.w	r2, #512	; 0x200
     e7a:	f000 f803 	bl	e84 <send_buffer>

        	data_sent_callback_fn();
     e7e:	f7ff fe69 	bl	b54 <data_sent_callback_fn>
        }
    }
     e82:	e79b      	b.n	dbc <main+0x80>

00000e84 <send_buffer>:
err_t send_buffer (struct udp_pcb *pcb,
		                 /*struct ip_addr *to_ip,
		                 int to_port,*/
		                 char *buf,
		                 int buflen)
{
     e84:	b580      	push	{r7, lr}
     e86:	b088      	sub	sp, #32
     e88:	af00      	add	r7, sp, #0
     e8a:	60f8      	str	r0, [r7, #12]
     e8c:	60b9      	str	r1, [r7, #8]
     e8e:	607a      	str	r2, [r7, #4]
	struct ip_addr *to_ip = &(pcb->remote_ip);
     e90:	68fb      	ldr	r3, [r7, #12]
     e92:	f103 0304 	add.w	r3, r3, #4
     e96:	613b      	str	r3, [r7, #16]
	int to_port = pcb->remote_port;
     e98:	68fb      	ldr	r3, [r7, #12]
     e9a:	8a9b      	ldrh	r3, [r3, #20]
     e9c:	617b      	str	r3, [r7, #20]

    err_t err;
    struct pbuf *pkt_buf;

    pkt_buf = pbuf_alloc(PBUF_TRANSPORT, buflen, PBUF_POOL);
     e9e:	687b      	ldr	r3, [r7, #4]
     ea0:	b29b      	uxth	r3, r3
     ea2:	f04f 0000 	mov.w	r0, #0
     ea6:	4619      	mov	r1, r3
     ea8:	f04f 0203 	mov.w	r2, #3
     eac:	f001 fea4 	bl	2bf8 <pbuf_alloc>
     eb0:	4603      	mov	r3, r0
     eb2:	61fb      	str	r3, [r7, #28]
    if (!pkt_buf)
     eb4:	69fb      	ldr	r3, [r7, #28]
     eb6:	2b00      	cmp	r3, #0
     eb8:	d102      	bne.n	ec0 <send_buffer+0x3c>
    {
//        iprintf("error allocating pkt buffer\n\r");
        return ERR_MEM;
     eba:	f04f 03ff 	mov.w	r3, #255	; 0xff
     ebe:	e015      	b.n	eec <send_buffer+0x68>
    }
    // Copy the original data buffer over to the packet buffer's payload
    memcpy(pkt_buf->payload, buf, buflen);
     ec0:	69fb      	ldr	r3, [r7, #28]
     ec2:	685a      	ldr	r2, [r3, #4]
     ec4:	687b      	ldr	r3, [r7, #4]
     ec6:	4610      	mov	r0, r2
     ec8:	68b9      	ldr	r1, [r7, #8]
     eca:	461a      	mov	r2, r3
     ecc:	f007 feaa 	bl	8c24 <memcpy>
    // send message
    err = udp_sendto(pcb, pkt_buf, to_ip, to_port);
     ed0:	697b      	ldr	r3, [r7, #20]
     ed2:	b29b      	uxth	r3, r3
     ed4:	68f8      	ldr	r0, [r7, #12]
     ed6:	69f9      	ldr	r1, [r7, #28]
     ed8:	693a      	ldr	r2, [r7, #16]
     eda:	f002 fdb3 	bl	3a44 <udp_sendto>
     ede:	4603      	mov	r3, r0
     ee0:	b2db      	uxtb	r3, r3
     ee2:	76fb      	strb	r3, [r7, #27]
    pbuf_free(pkt_buf);
     ee4:	69f8      	ldr	r0, [r7, #28]
     ee6:	f002 f905 	bl	30f4 <pbuf_free>
    return err;
     eea:	7efb      	ldrb	r3, [r7, #27]
     eec:	b25b      	sxtb	r3, r3
}
     eee:	4618      	mov	r0, r3
     ef0:	f107 0720 	add.w	r7, r7, #32
     ef4:	46bd      	mov	sp, r7
     ef6:	bd80      	pop	{r7, pc}

00000ef8 <recv_callback>:
void recv_callback(void *arg,
					   struct udp_pcb *pcb,
		               struct pbuf *pkt_buf,
		               struct ip_addr *addr,
		               u16_t port)
{
     ef8:	b580      	push	{r7, lr}
     efa:	b086      	sub	sp, #24
     efc:	af00      	add	r7, sp, #0
     efe:	60f8      	str	r0, [r7, #12]
     f00:	60b9      	str	r1, [r7, #8]
     f02:	607a      	str	r2, [r7, #4]
     f04:	603b      	str	r3, [r7, #0]
	pcb->remote_port = port;
     f06:	68bb      	ldr	r3, [r7, #8]
     f08:	8c3a      	ldrh	r2, [r7, #32]
     f0a:	829a      	strh	r2, [r3, #20]
	pcb->remote_ip = *addr;
     f0c:	68bb      	ldr	r3, [r7, #8]
     f0e:	683a      	ldr	r2, [r7, #0]
     f10:	6812      	ldr	r2, [r2, #0]
     f12:	605a      	str	r2, [r3, #4]

//Process
	struct pbuf* p = pkt_buf;
     f14:	687b      	ldr	r3, [r7, #4]
     f16:	617b      	str	r3, [r7, #20]

	while (p && p->len)
     f18:	e00a      	b.n	f30 <recv_callback+0x38>
	{
		receive_callback(p->payload, p->len);
     f1a:	697b      	ldr	r3, [r7, #20]
     f1c:	685a      	ldr	r2, [r3, #4]
     f1e:	697b      	ldr	r3, [r7, #20]
     f20:	895b      	ldrh	r3, [r3, #10]
     f22:	4610      	mov	r0, r2
     f24:	4619      	mov	r1, r3
     f26:	f7ff fe7f 	bl	c28 <receive_callback>
		p = p->next;
     f2a:	697b      	ldr	r3, [r7, #20]
     f2c:	681b      	ldr	r3, [r3, #0]
     f2e:	617b      	str	r3, [r7, #20]
	pcb->remote_ip = *addr;

//Process
	struct pbuf* p = pkt_buf;

	while (p && p->len)
     f30:	697b      	ldr	r3, [r7, #20]
     f32:	2b00      	cmp	r3, #0
     f34:	d003      	beq.n	f3e <recv_callback+0x46>
     f36:	697b      	ldr	r3, [r7, #20]
     f38:	895b      	ldrh	r3, [r3, #10]
     f3a:	2b00      	cmp	r3, #0
     f3c:	d1ed      	bne.n	f1a <recv_callback+0x22>
		receive_callback(p->payload, p->len);
		p = p->next;
	}

//Free buff
	pbuf_free(pkt_buf);
     f3e:	6878      	ldr	r0, [r7, #4]
     f40:	f002 f8d8 	bl	30f4 <pbuf_free>

// if error close
	//udp_remove(pcb);
}
     f44:	f107 0718 	add.w	r7, r7, #24
     f48:	46bd      	mov	sp, r7
     f4a:	bd80      	pop	{r7, pc}

00000f4c <server_init>:


/*..........................................................................*/
struct udp_pcb *server_init(u16_t port)
{
     f4c:	b580      	push	{r7, lr}
     f4e:	b084      	sub	sp, #16
     f50:	af00      	add	r7, sp, #0
     f52:	4603      	mov	r3, r0
     f54:	80fb      	strh	r3, [r7, #6]
    struct udp_pcb *pcb;
    err_t err;

    pcb = udp_new();
     f56:	f002 ff53 	bl	3e00 <udp_new>
     f5a:	4603      	mov	r3, r0
     f5c:	60bb      	str	r3, [r7, #8]
    if (!pcb)
     f5e:	68bb      	ldr	r3, [r7, #8]
     f60:	2b00      	cmp	r3, #0
     f62:	d102      	bne.n	f6a <server_init+0x1e>
    {
//    	iprintf("Error creating PCB. Out of Memory\n\r");
        return NULL;
     f64:	f04f 0300 	mov.w	r3, #0
     f68:	e01c      	b.n	fa4 <server_init+0x58>
    }

    err = udp_bind(pcb, IP_ADDR_ANY, port);
     f6a:	88fb      	ldrh	r3, [r7, #6]
     f6c:	68b8      	ldr	r0, [r7, #8]
     f6e:	f648 61b8 	movw	r1, #36536	; 0x8eb8
     f72:	f2c0 0100 	movt	r1, #0
     f76:	461a      	mov	r2, r3
     f78:	f002 fea0 	bl	3cbc <udp_bind>
     f7c:	4603      	mov	r3, r0
     f7e:	b2db      	uxtb	r3, r3
     f80:	73fb      	strb	r3, [r7, #15]
    if (err != ERR_OK)
     f82:	f997 300f 	ldrsb.w	r3, [r7, #15]
     f86:	2b00      	cmp	r3, #0
     f88:	d002      	beq.n	f90 <server_init+0x44>
    {
//        iprintf("Unable to bind to port %d: err = %d\n\r", port, err);
        return NULL;
     f8a:	f04f 0300 	mov.w	r3, #0
     f8e:	e009      	b.n	fa4 <server_init+0x58>
    }

    udp_recv(pcb, recv_callback, NULL);
     f90:	68b8      	ldr	r0, [r7, #8]
     f92:	f640 61f9 	movw	r1, #3833	; 0xef9
     f96:	f2c0 0100 	movt	r1, #0
     f9a:	f04f 0200 	mov.w	r2, #0
     f9e:	f002 ff1d 	bl	3ddc <udp_recv>

    return pcb;
     fa2:	68bb      	ldr	r3, [r7, #8]
}
     fa4:	4618      	mov	r0, r3
     fa6:	f107 0710 	add.w	r7, r7, #16
     faa:	46bd      	mov	sp, r7
     fac:	bd80      	pop	{r7, pc}
     fae:	bf00      	nop

00000fb0 <free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
free_entry(int i)
{
     fb0:	b580      	push	{r7, lr}
     fb2:	b082      	sub	sp, #8
     fb4:	af00      	add	r7, sp, #0
     fb6:	6078      	str	r0, [r7, #4]
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
     fb8:	687a      	ldr	r2, [r7, #4]
     fba:	f240 633c 	movw	r3, #1596	; 0x63c
     fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fc2:	ea4f 1202 	mov.w	r2, r2, lsl #4
     fc6:	4413      	add	r3, r2
     fc8:	681b      	ldr	r3, [r3, #0]
     fca:	2b00      	cmp	r3, #0
     fcc:	d016      	beq.n	ffc <free_entry+0x4c>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
     fce:	687a      	ldr	r2, [r7, #4]
     fd0:	f240 633c 	movw	r3, #1596	; 0x63c
     fd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fd8:	ea4f 1202 	mov.w	r2, r2, lsl #4
     fdc:	4413      	add	r3, r2
     fde:	681b      	ldr	r3, [r3, #0]
     fe0:	4618      	mov	r0, r3
     fe2:	f002 f887 	bl	30f4 <pbuf_free>
    arp_table[i].q = NULL;
     fe6:	687a      	ldr	r2, [r7, #4]
     fe8:	f240 633c 	movw	r3, #1596	; 0x63c
     fec:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ff0:	ea4f 1202 	mov.w	r2, r2, lsl #4
     ff4:	4413      	add	r3, r2
     ff6:	f04f 0200 	mov.w	r2, #0
     ffa:	601a      	str	r2, [r3, #0]
  }
  /* recycle entry for re-use */      
  arp_table[i].state = ETHARP_STATE_EMPTY;
     ffc:	687b      	ldr	r3, [r7, #4]
     ffe:	f240 623c 	movw	r2, #1596	; 0x63c
    1002:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1006:	ea4f 0343 	mov.w	r3, r3, lsl #1
    100a:	f103 0301 	add.w	r3, r3, #1
    100e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1012:	4413      	add	r3, r2
    1014:	f04f 0200 	mov.w	r2, #0
    1018:	719a      	strb	r2, [r3, #6]
  arp_table[i].netif = NULL;
#endif /* LWIP_SNMP */
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    101a:	f107 0708 	add.w	r7, r7, #8
    101e:	46bd      	mov	sp, r7
    1020:	bd80      	pop	{r7, pc}
    1022:	bf00      	nop

00001024 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
    1024:	b580      	push	{r7, lr}
    1026:	b082      	sub	sp, #8
    1028:	af00      	add	r7, sp, #0
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    102a:	f04f 0300 	mov.w	r3, #0
    102e:	71bb      	strb	r3, [r7, #6]
    1030:	e062      	b.n	10f8 <etharp_tmr+0xd4>
    u8_t state = arp_table[i].state;
    1032:	79bb      	ldrb	r3, [r7, #6]
    1034:	f240 623c 	movw	r2, #1596	; 0x63c
    1038:	f2c2 0200 	movt	r2, #8192	; 0x2000
    103c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1040:	f103 0301 	add.w	r3, r3, #1
    1044:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1048:	4413      	add	r3, r2
    104a:	799b      	ldrb	r3, [r3, #6]
    104c:	71fb      	strb	r3, [r7, #7]
    if (state != ETHARP_STATE_EMPTY
    104e:	79fb      	ldrb	r3, [r7, #7]
    1050:	2b00      	cmp	r3, #0
    1052:	d04d      	beq.n	10f0 <etharp_tmr+0xcc>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (arp_table[i].static_entry == 0)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
    1054:	79b9      	ldrb	r1, [r7, #6]
    1056:	f240 623c 	movw	r2, #1596	; 0x63c
    105a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    105e:	ea4f 0341 	mov.w	r3, r1, lsl #1
    1062:	f103 0301 	add.w	r3, r3, #1
    1066:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    106a:	4413      	add	r3, r2
    106c:	79db      	ldrb	r3, [r3, #7]
    106e:	f103 0301 	add.w	r3, r3, #1
    1072:	b2d8      	uxtb	r0, r3
    1074:	f240 623c 	movw	r2, #1596	; 0x63c
    1078:	f2c2 0200 	movt	r2, #8192	; 0x2000
    107c:	ea4f 0341 	mov.w	r3, r1, lsl #1
    1080:	f103 0301 	add.w	r3, r3, #1
    1084:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1088:	4413      	add	r3, r2
    108a:	4602      	mov	r2, r0
    108c:	71da      	strb	r2, [r3, #7]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    108e:	79bb      	ldrb	r3, [r7, #6]
    1090:	f240 623c 	movw	r2, #1596	; 0x63c
    1094:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1098:	ea4f 0343 	mov.w	r3, r3, lsl #1
    109c:	f103 0301 	add.w	r3, r3, #1
    10a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    10a4:	4413      	add	r3, r2
    10a6:	79db      	ldrb	r3, [r3, #7]
    10a8:	2bef      	cmp	r3, #239	; 0xef
    10aa:	d81d      	bhi.n	10e8 <etharp_tmr+0xc4>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
    10ac:	79bb      	ldrb	r3, [r7, #6]
    10ae:	f240 623c 	movw	r2, #1596	; 0x63c
    10b2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    10b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    10ba:	f103 0301 	add.w	r3, r3, #1
    10be:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    10c2:	4413      	add	r3, r2
    10c4:	799b      	ldrb	r3, [r3, #6]
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (arp_table[i].static_entry == 0)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    10c6:	2b01      	cmp	r3, #1
    10c8:	d112      	bne.n	10f0 <etharp_tmr+0xcc>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
    10ca:	79bb      	ldrb	r3, [r7, #6]
    10cc:	f240 623c 	movw	r2, #1596	; 0x63c
    10d0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    10d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    10d8:	f103 0301 	add.w	r3, r3, #1
    10dc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    10e0:	4413      	add	r3, r2
    10e2:	79db      	ldrb	r3, [r3, #7]
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (arp_table[i].static_entry == 0)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    10e4:	2b01      	cmp	r3, #1
    10e6:	d903      	bls.n	10f0 <etharp_tmr+0xcc>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state == ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        free_entry(i);
    10e8:	79bb      	ldrb	r3, [r7, #6]
    10ea:	4618      	mov	r0, r3
    10ec:	f7ff ff60 	bl	fb0 <free_entry>
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    10f0:	79bb      	ldrb	r3, [r7, #6]
    10f2:	f103 0301 	add.w	r3, r3, #1
    10f6:	71bb      	strb	r3, [r7, #6]
    10f8:	79bb      	ldrb	r3, [r7, #6]
    10fa:	2b09      	cmp	r3, #9
    10fc:	d999      	bls.n	1032 <etharp_tmr+0xe>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
    10fe:	f107 0708 	add.w	r7, r7, #8
    1102:	46bd      	mov	sp, r7
    1104:	bd80      	pop	{r7, pc}
    1106:	bf00      	nop

00001108 <find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    1108:	b580      	push	{r7, lr}
    110a:	b086      	sub	sp, #24
    110c:	af00      	add	r7, sp, #0
    110e:	6078      	str	r0, [r7, #4]
    1110:	460b      	mov	r3, r1
    1112:	70fb      	strb	r3, [r7, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    1114:	f04f 030a 	mov.w	r3, #10
    1118:	73fb      	strb	r3, [r7, #15]
    111a:	f04f 030a 	mov.w	r3, #10
    111e:	743b      	strb	r3, [r7, #16]
  s8_t empty = ARP_TABLE_SIZE;
    1120:	f04f 030a 	mov.w	r3, #10
    1124:	747b      	strb	r3, [r7, #17]
  u8_t i = 0, age_pending = 0, age_stable = 0;
    1126:	f04f 0300 	mov.w	r3, #0
    112a:	74bb      	strb	r3, [r7, #18]
    112c:	f04f 0300 	mov.w	r3, #0
    1130:	74fb      	strb	r3, [r7, #19]
    1132:	f04f 0300 	mov.w	r3, #0
    1136:	753b      	strb	r3, [r7, #20]
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
    1138:	f04f 030a 	mov.w	r3, #10
    113c:	757b      	strb	r3, [r7, #21]
  /* its age */
  u8_t age_queue = 0;
    113e:	f04f 0300 	mov.w	r3, #0
    1142:	75bb      	strb	r3, [r7, #22]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    1144:	f04f 0300 	mov.w	r3, #0
    1148:	74bb      	strb	r3, [r7, #18]
    114a:	e0ac      	b.n	12a6 <find_entry+0x19e>
    u8_t state = arp_table[i].state;
    114c:	7cbb      	ldrb	r3, [r7, #18]
    114e:	f240 623c 	movw	r2, #1596	; 0x63c
    1152:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1156:	ea4f 0343 	mov.w	r3, r3, lsl #1
    115a:	f103 0301 	add.w	r3, r3, #1
    115e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1162:	4413      	add	r3, r2
    1164:	799b      	ldrb	r3, [r3, #6]
    1166:	75fb      	strb	r3, [r7, #23]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    1168:	f997 3011 	ldrsb.w	r3, [r7, #17]
    116c:	2b0a      	cmp	r3, #10
    116e:	d105      	bne.n	117c <find_entry+0x74>
    1170:	7dfb      	ldrb	r3, [r7, #23]
    1172:	2b00      	cmp	r3, #0
    1174:	d102      	bne.n	117c <find_entry+0x74>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    1176:	7cbb      	ldrb	r3, [r7, #18]
    1178:	747b      	strb	r3, [r7, #17]
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    117a:	e090      	b.n	129e <find_entry+0x196>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
    117c:	7dfb      	ldrb	r3, [r7, #23]
    117e:	2b00      	cmp	r3, #0
    1180:	f000 808d 	beq.w	129e <find_entry+0x196>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state == ETHARP_STATE_STABLE",
    1184:	7dfb      	ldrb	r3, [r7, #23]
    1186:	2b01      	cmp	r3, #1
        state == ETHARP_STATE_PENDING || state == ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    1188:	687b      	ldr	r3, [r7, #4]
    118a:	2b00      	cmp	r3, #0
    118c:	d010      	beq.n	11b0 <find_entry+0xa8>
    118e:	687b      	ldr	r3, [r7, #4]
    1190:	681a      	ldr	r2, [r3, #0]
    1192:	7cb9      	ldrb	r1, [r7, #18]
    1194:	f240 633c 	movw	r3, #1596	; 0x63c
    1198:	f2c2 0300 	movt	r3, #8192	; 0x2000
    119c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    11a0:	440b      	add	r3, r1
    11a2:	f103 0304 	add.w	r3, r3, #4
    11a6:	681b      	ldr	r3, [r3, #0]
    11a8:	429a      	cmp	r2, r3
    11aa:	d101      	bne.n	11b0 <find_entry+0xa8>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
    11ac:	7cbb      	ldrb	r3, [r7, #18]
    11ae:	e0d2      	b.n	1356 <find_entry+0x24e>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
    11b0:	7dfb      	ldrb	r3, [r7, #23]
    11b2:	2b01      	cmp	r3, #1
    11b4:	d14c      	bne.n	1250 <find_entry+0x148>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
    11b6:	7cba      	ldrb	r2, [r7, #18]
    11b8:	f240 633c 	movw	r3, #1596	; 0x63c
    11bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11c0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    11c4:	4413      	add	r3, r2
    11c6:	681b      	ldr	r3, [r3, #0]
    11c8:	2b00      	cmp	r3, #0
    11ca:	d020      	beq.n	120e <find_entry+0x106>
          if (arp_table[i].ctime >= age_queue) {
    11cc:	7cbb      	ldrb	r3, [r7, #18]
    11ce:	f240 623c 	movw	r2, #1596	; 0x63c
    11d2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    11d6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    11da:	f103 0301 	add.w	r3, r3, #1
    11de:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    11e2:	4413      	add	r3, r2
    11e4:	79db      	ldrb	r3, [r3, #7]
    11e6:	7dba      	ldrb	r2, [r7, #22]
    11e8:	429a      	cmp	r2, r3
    11ea:	d855      	bhi.n	1298 <find_entry+0x190>
            old_queue = i;
    11ec:	7cbb      	ldrb	r3, [r7, #18]
    11ee:	757b      	strb	r3, [r7, #21]
            age_queue = arp_table[i].ctime;
    11f0:	7cbb      	ldrb	r3, [r7, #18]
    11f2:	f240 623c 	movw	r2, #1596	; 0x63c
    11f6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    11fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
    11fe:	f103 0301 	add.w	r3, r3, #1
    1202:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1206:	4413      	add	r3, r2
    1208:	79db      	ldrb	r3, [r3, #7]
    120a:	75bb      	strb	r3, [r7, #22]
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
            old_pending = i;
            age_pending = arp_table[i].ctime;
    120c:	e047      	b.n	129e <find_entry+0x196>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
    120e:	7cbb      	ldrb	r3, [r7, #18]
    1210:	f240 623c 	movw	r2, #1596	; 0x63c
    1214:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1218:	ea4f 0343 	mov.w	r3, r3, lsl #1
    121c:	f103 0301 	add.w	r3, r3, #1
    1220:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1224:	4413      	add	r3, r2
    1226:	79db      	ldrb	r3, [r3, #7]
    1228:	7cfa      	ldrb	r2, [r7, #19]
    122a:	429a      	cmp	r2, r3
    122c:	d836      	bhi.n	129c <find_entry+0x194>
            old_pending = i;
    122e:	7cbb      	ldrb	r3, [r7, #18]
    1230:	73fb      	strb	r3, [r7, #15]
            age_pending = arp_table[i].ctime;
    1232:	7cbb      	ldrb	r3, [r7, #18]
    1234:	f240 623c 	movw	r2, #1596	; 0x63c
    1238:	f2c2 0200 	movt	r2, #8192	; 0x2000
    123c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1240:	f103 0301 	add.w	r3, r3, #1
    1244:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1248:	4413      	add	r3, r2
    124a:	79db      	ldrb	r3, [r3, #7]
    124c:	74fb      	strb	r3, [r7, #19]
    124e:	e026      	b.n	129e <find_entry+0x196>
          }
        }
      /* stable entry? */
      } else if (state == ETHARP_STATE_STABLE) {
    1250:	7dfb      	ldrb	r3, [r7, #23]
    1252:	2b02      	cmp	r3, #2
    1254:	d123      	bne.n	129e <find_entry+0x196>
        /* don't record old_stable for static entries since they never expire */
        if (arp_table[i].static_entry == 0)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
    1256:	7cbb      	ldrb	r3, [r7, #18]
    1258:	f240 623c 	movw	r2, #1596	; 0x63c
    125c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1260:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1264:	f103 0301 	add.w	r3, r3, #1
    1268:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    126c:	4413      	add	r3, r2
    126e:	79db      	ldrb	r3, [r3, #7]
    1270:	7d3a      	ldrb	r2, [r7, #20]
    1272:	429a      	cmp	r2, r3
    1274:	d813      	bhi.n	129e <find_entry+0x196>
            old_stable = i;
    1276:	7cbb      	ldrb	r3, [r7, #18]
    1278:	743b      	strb	r3, [r7, #16]
            age_stable = arp_table[i].ctime;
    127a:	7cbb      	ldrb	r3, [r7, #18]
    127c:	f240 623c 	movw	r2, #1596	; 0x63c
    1280:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1284:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1288:	f103 0301 	add.w	r3, r3, #1
    128c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1290:	4413      	add	r3, r2
    1292:	79db      	ldrb	r3, [r3, #7]
    1294:	753b      	strb	r3, [r7, #20]
    1296:	e002      	b.n	129e <find_entry+0x196>
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
            old_pending = i;
            age_pending = arp_table[i].ctime;
    1298:	bf00      	nop
    129a:	e000      	b.n	129e <find_entry+0x196>
    129c:	bf00      	nop
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    129e:	7cbb      	ldrb	r3, [r7, #18]
    12a0:	f103 0301 	add.w	r3, r3, #1
    12a4:	74bb      	strb	r3, [r7, #18]
    12a6:	7cbb      	ldrb	r3, [r7, #18]
    12a8:	2b09      	cmp	r3, #9
    12aa:	f67f af4f 	bls.w	114c <find_entry+0x44>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    12ae:	78fb      	ldrb	r3, [r7, #3]
    12b0:	f003 0302 	and.w	r3, r3, #2
    12b4:	2b00      	cmp	r3, #0
    12b6:	d108      	bne.n	12ca <find_entry+0x1c2>
    12b8:	f997 3011 	ldrsb.w	r3, [r7, #17]
    12bc:	2b0a      	cmp	r3, #10
    12be:	d107      	bne.n	12d0 <find_entry+0x1c8>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    12c0:	78fb      	ldrb	r3, [r7, #3]
    12c2:	f003 0301 	and.w	r3, r3, #1
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    12c6:	2b00      	cmp	r3, #0
    12c8:	d102      	bne.n	12d0 <find_entry+0x1c8>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
    12ca:	f04f 03ff 	mov.w	r3, #255	; 0xff
    12ce:	e042      	b.n	1356 <find_entry+0x24e>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    12d0:	f997 3011 	ldrsb.w	r3, [r7, #17]
    12d4:	2b09      	cmp	r3, #9
    12d6:	dc02      	bgt.n	12de <find_entry+0x1d6>
    i = empty;
    12d8:	7c7b      	ldrb	r3, [r7, #17]
    12da:	74bb      	strb	r3, [r7, #18]
    12dc:	e01b      	b.n	1316 <find_entry+0x20e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
    12de:	f997 3010 	ldrsb.w	r3, [r7, #16]
    12e2:	2b09      	cmp	r3, #9
    12e4:	dc02      	bgt.n	12ec <find_entry+0x1e4>
      /* recycle oldest stable*/
      i = old_stable;
    12e6:	7c3b      	ldrb	r3, [r7, #16]
    12e8:	74bb      	strb	r3, [r7, #18]
    12ea:	e010      	b.n	130e <find_entry+0x206>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
    12ec:	f997 300f 	ldrsb.w	r3, [r7, #15]
    12f0:	2b09      	cmp	r3, #9
    12f2:	dc02      	bgt.n	12fa <find_entry+0x1f2>
      /* recycle oldest pending */
      i = old_pending;
    12f4:	7bfb      	ldrb	r3, [r7, #15]
    12f6:	74bb      	strb	r3, [r7, #18]
    12f8:	e009      	b.n	130e <find_entry+0x206>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
    12fa:	f997 3015 	ldrsb.w	r3, [r7, #21]
    12fe:	2b09      	cmp	r3, #9
    1300:	dc02      	bgt.n	1308 <find_entry+0x200>
      /* recycle oldest pending (queued packets are free in free_entry) */
      i = old_queue;
    1302:	7d7b      	ldrb	r3, [r7, #21]
    1304:	74bb      	strb	r3, [r7, #18]
    1306:	e002      	b.n	130e <find_entry+0x206>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    1308:	f04f 03ff 	mov.w	r3, #255	; 0xff
    130c:	e023      	b.n	1356 <find_entry+0x24e>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    free_entry(i);
    130e:	7cbb      	ldrb	r3, [r7, #18]
    1310:	4618      	mov	r0, r3
    1312:	f7ff fe4d 	bl	fb0 <free_entry>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
    1316:	687b      	ldr	r3, [r7, #4]
    1318:	2b00      	cmp	r3, #0
    131a:	d00c      	beq.n	1336 <find_entry+0x22e>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    131c:	7cb9      	ldrb	r1, [r7, #18]
    131e:	687b      	ldr	r3, [r7, #4]
    1320:	681a      	ldr	r2, [r3, #0]
    1322:	f240 633c 	movw	r3, #1596	; 0x63c
    1326:	f2c2 0300 	movt	r3, #8192	; 0x2000
    132a:	ea4f 1101 	mov.w	r1, r1, lsl #4
    132e:	440b      	add	r3, r1
    1330:	f103 0304 	add.w	r3, r3, #4
    1334:	601a      	str	r2, [r3, #0]
  }
  arp_table[i].ctime = 0;
    1336:	7cbb      	ldrb	r3, [r7, #18]
    1338:	f240 623c 	movw	r2, #1596	; 0x63c
    133c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1340:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1344:	f103 0301 	add.w	r3, r3, #1
    1348:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    134c:	4413      	add	r3, r2
    134e:	f04f 0200 	mov.w	r2, #0
    1352:	71da      	strb	r2, [r3, #7]
#if ETHARP_SUPPORT_STATIC_ENTRIES
  arp_table[i].static_entry = 0;
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  return (err_t)i;
    1354:	7cbb      	ldrb	r3, [r7, #18]
    1356:	b25b      	sxtb	r3, r3
}
    1358:	4618      	mov	r0, r3
    135a:	f107 0718 	add.w	r7, r7, #24
    135e:	46bd      	mov	sp, r7
    1360:	bd80      	pop	{r7, pc}
    1362:	bf00      	nop

00001364 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    1364:	b580      	push	{r7, lr}
    1366:	b086      	sub	sp, #24
    1368:	af00      	add	r7, sp, #0
    136a:	60f8      	str	r0, [r7, #12]
    136c:	60b9      	str	r1, [r7, #8]
    136e:	607a      	str	r2, [r7, #4]
    1370:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    1372:	68bb      	ldr	r3, [r7, #8]
    1374:	685b      	ldr	r3, [r3, #4]
    1376:	617b      	str	r3, [r7, #20]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
    1378:	697b      	ldr	r3, [r7, #20]
    137a:	4618      	mov	r0, r3
    137c:	6839      	ldr	r1, [r7, #0]
    137e:	f04f 0206 	mov.w	r2, #6
    1382:	f007 fc4f 	bl	8c24 <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
    1386:	697b      	ldr	r3, [r7, #20]
    1388:	f103 0306 	add.w	r3, r3, #6
    138c:	4618      	mov	r0, r3
    138e:	6879      	ldr	r1, [r7, #4]
    1390:	f04f 0206 	mov.w	r2, #6
    1394:	f007 fc46 	bl	8c24 <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
    1398:	697b      	ldr	r3, [r7, #20]
    139a:	f04f 0200 	mov.w	r2, #0
    139e:	f042 0208 	orr.w	r2, r2, #8
    13a2:	731a      	strb	r2, [r3, #12]
    13a4:	f04f 0200 	mov.w	r2, #0
    13a8:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
    13aa:	68fb      	ldr	r3, [r7, #12]
    13ac:	699b      	ldr	r3, [r3, #24]
    13ae:	68f8      	ldr	r0, [r7, #12]
    13b0:	68b9      	ldr	r1, [r7, #8]
    13b2:	4798      	blx	r3
    13b4:	4603      	mov	r3, r0
    13b6:	b2db      	uxtb	r3, r3
    13b8:	b2db      	uxtb	r3, r3
    13ba:	b25b      	sxtb	r3, r3
}
    13bc:	4618      	mov	r0, r3
    13be:	f107 0718 	add.w	r7, r7, #24
    13c2:	46bd      	mov	sp, r7
    13c4:	bd80      	pop	{r7, pc}
    13c6:	bf00      	nop

000013c8 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
    13c8:	b580      	push	{r7, lr}
    13ca:	b086      	sub	sp, #24
    13cc:	af00      	add	r7, sp, #0
    13ce:	60f8      	str	r0, [r7, #12]
    13d0:	60b9      	str	r1, [r7, #8]
    13d2:	607a      	str	r2, [r7, #4]
    13d4:	70fb      	strb	r3, [r7, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    13d6:	68bb      	ldr	r3, [r7, #8]
    13d8:	2b00      	cmp	r3, #0
    13da:	d012      	beq.n	1402 <update_arp_entry+0x3a>
    13dc:	68bb      	ldr	r3, [r7, #8]
    13de:	681b      	ldr	r3, [r3, #0]
    13e0:	2b00      	cmp	r3, #0
    13e2:	d00e      	beq.n	1402 <update_arp_entry+0x3a>
      ip_addr_isbroadcast(ipaddr, netif) ||
    13e4:	68bb      	ldr	r3, [r7, #8]
    13e6:	681b      	ldr	r3, [r3, #0]
    13e8:	4618      	mov	r0, r3
    13ea:	68f9      	ldr	r1, [r7, #12]
    13ec:	f003 fe42 	bl	5074 <ip4_addr_isbroadcast>
    13f0:	4603      	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    13f2:	2b00      	cmp	r3, #0
    13f4:	d105      	bne.n	1402 <update_arp_entry+0x3a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    13f6:	68bb      	ldr	r3, [r7, #8]
    13f8:	681b      	ldr	r3, [r3, #0]
    13fa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    13fe:	2be0      	cmp	r3, #224	; 0xe0
    1400:	d102      	bne.n	1408 <update_arp_entry+0x40>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    1402:	f04f 03f2 	mov.w	r3, #242	; 0xf2
    1406:	e071      	b.n	14ec <update_arp_entry+0x124>
  }
  /* find or create ARP entry */
  i = find_entry(ipaddr, flags);
    1408:	78fb      	ldrb	r3, [r7, #3]
    140a:	68b8      	ldr	r0, [r7, #8]
    140c:	4619      	mov	r1, r3
    140e:	f7ff fe7b 	bl	1108 <find_entry>
    1412:	4603      	mov	r3, r0
    1414:	b2db      	uxtb	r3, r3
    1416:	74fb      	strb	r3, [r7, #19]
  /* bail out if no entry could be found */
  if (i < 0) {
    1418:	f997 3013 	ldrsb.w	r3, [r7, #19]
    141c:	2b00      	cmp	r3, #0
    141e:	da01      	bge.n	1424 <update_arp_entry+0x5c>
    return (err_t)i;
    1420:	7cfb      	ldrb	r3, [r7, #19]
    1422:	e063      	b.n	14ec <update_arp_entry+0x124>
    arp_table[i].static_entry = 1;
  }
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */

  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
    1424:	f997 3013 	ldrsb.w	r3, [r7, #19]
    1428:	f240 623c 	movw	r2, #1596	; 0x63c
    142c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1430:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1434:	f103 0301 	add.w	r3, r3, #1
    1438:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    143c:	4413      	add	r3, r2
    143e:	f04f 0202 	mov.w	r2, #2
    1442:	719a      	strb	r2, [r3, #6]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    1444:	f997 3013 	ldrsb.w	r3, [r7, #19]
    1448:	ea4f 0343 	mov.w	r3, r3, lsl #1
    144c:	f103 0301 	add.w	r3, r3, #1
    1450:	ea4f 02c3 	mov.w	r2, r3, lsl #3
    1454:	f240 633c 	movw	r3, #1596	; 0x63c
    1458:	f2c2 0300 	movt	r3, #8192	; 0x2000
    145c:	4413      	add	r3, r2
    145e:	4618      	mov	r0, r3
    1460:	6879      	ldr	r1, [r7, #4]
    1462:	f04f 0206 	mov.w	r2, #6
    1466:	f007 fbdd 	bl	8c24 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
    146a:	f997 3013 	ldrsb.w	r3, [r7, #19]
    146e:	f240 623c 	movw	r2, #1596	; 0x63c
    1472:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1476:	ea4f 0343 	mov.w	r3, r3, lsl #1
    147a:	f103 0301 	add.w	r3, r3, #1
    147e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1482:	4413      	add	r3, r2
    1484:	f04f 0200 	mov.w	r2, #0
    1488:	71da      	strb	r2, [r3, #7]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
    148a:	f997 2013 	ldrsb.w	r2, [r7, #19]
    148e:	f240 633c 	movw	r3, #1596	; 0x63c
    1492:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1496:	ea4f 1202 	mov.w	r2, r2, lsl #4
    149a:	4413      	add	r3, r2
    149c:	681b      	ldr	r3, [r3, #0]
    149e:	2b00      	cmp	r3, #0
    14a0:	d022      	beq.n	14e8 <update_arp_entry+0x120>
    struct pbuf *p = arp_table[i].q;
    14a2:	f997 2013 	ldrsb.w	r2, [r7, #19]
    14a6:	f240 633c 	movw	r3, #1596	; 0x63c
    14aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14ae:	ea4f 1202 	mov.w	r2, r2, lsl #4
    14b2:	4413      	add	r3, r2
    14b4:	681b      	ldr	r3, [r3, #0]
    14b6:	617b      	str	r3, [r7, #20]
    arp_table[i].q = NULL;
    14b8:	f997 2013 	ldrsb.w	r2, [r7, #19]
    14bc:	f240 633c 	movw	r3, #1596	; 0x63c
    14c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14c4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    14c8:	4413      	add	r3, r2
    14ca:	f04f 0200 	mov.w	r2, #0
    14ce:	601a      	str	r2, [r3, #0]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    14d0:	68fb      	ldr	r3, [r7, #12]
    14d2:	f103 0323 	add.w	r3, r3, #35	; 0x23
    14d6:	68f8      	ldr	r0, [r7, #12]
    14d8:	6979      	ldr	r1, [r7, #20]
    14da:	461a      	mov	r2, r3
    14dc:	687b      	ldr	r3, [r7, #4]
    14de:	f7ff ff41 	bl	1364 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
    14e2:	6978      	ldr	r0, [r7, #20]
    14e4:	f001 fe06 	bl	30f4 <pbuf_free>
  }
  return ERR_OK;
    14e8:	f04f 0300 	mov.w	r3, #0
    14ec:	b25b      	sxtb	r3, r3
}
    14ee:	4618      	mov	r0, r3
    14f0:	f107 0718 	add.w	r7, r7, #24
    14f4:	46bd      	mov	sp, r7
    14f6:	bd80      	pop	{r7, pc}

000014f8 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
    14f8:	b580      	push	{r7, lr}
    14fa:	b08a      	sub	sp, #40	; 0x28
    14fc:	af00      	add	r7, sp, #0
    14fe:	60f8      	str	r0, [r7, #12]
    1500:	60b9      	str	r1, [r7, #8]
    1502:	607a      	str	r2, [r7, #4]
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    1504:	68fb      	ldr	r3, [r7, #12]
    1506:	2b00      	cmp	r3, #0
    1508:	f000 8135 	beq.w	1776 <etharp_arp_input+0x27e>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    150c:	687b      	ldr	r3, [r7, #4]
    150e:	895b      	ldrh	r3, [r3, #10]
    1510:	2b29      	cmp	r3, #41	; 0x29
    1512:	d81d      	bhi.n	1550 <etharp_arp_input+0x58>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    1514:	f247 0330 	movw	r3, #28720	; 0x7030
    1518:	f2c2 0300 	movt	r3, #8192	; 0x2000
    151c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    151e:	f103 0301 	add.w	r3, r3, #1
    1522:	b29a      	uxth	r2, r3
    1524:	f247 0330 	movw	r3, #28720	; 0x7030
    1528:	f2c2 0300 	movt	r3, #8192	; 0x2000
    152c:	845a      	strh	r2, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
    152e:	f247 0330 	movw	r3, #28720	; 0x7030
    1532:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1536:	8bdb      	ldrh	r3, [r3, #30]
    1538:	f103 0301 	add.w	r3, r3, #1
    153c:	b29a      	uxth	r2, r3
    153e:	f247 0330 	movw	r3, #28720	; 0x7030
    1542:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1546:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
    1548:	6878      	ldr	r0, [r7, #4]
    154a:	f001 fdd3 	bl	30f4 <pbuf_free>
    return;
    154e:	e112      	b.n	1776 <etharp_arp_input+0x27e>
  }

  ethhdr = (struct eth_hdr *)p->payload;
    1550:	687b      	ldr	r3, [r7, #4]
    1552:	685b      	ldr	r3, [r3, #4]
    1554:	623b      	str	r3, [r7, #32]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    1556:	6a3b      	ldr	r3, [r7, #32]
    1558:	f103 030e 	add.w	r3, r3, #14
    155c:	61fb      	str	r3, [r7, #28]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    155e:	69fb      	ldr	r3, [r7, #28]
    1560:	781a      	ldrb	r2, [r3, #0]
    1562:	785b      	ldrb	r3, [r3, #1]
    1564:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1568:	ea43 0302 	orr.w	r3, r3, r2
    156c:	b29b      	uxth	r3, r3
    156e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    1572:	d111      	bne.n	1598 <etharp_arp_input+0xa0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
    1574:	69fb      	ldr	r3, [r7, #28]
    1576:	791b      	ldrb	r3, [r3, #4]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    1578:	2b06      	cmp	r3, #6
    157a:	d10d      	bne.n	1598 <etharp_arp_input+0xa0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
    157c:	69fb      	ldr	r3, [r7, #28]
    157e:	795b      	ldrb	r3, [r3, #5]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    1580:	2b04      	cmp	r3, #4
    1582:	d109      	bne.n	1598 <etharp_arp_input+0xa0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    1584:	69fb      	ldr	r3, [r7, #28]
    1586:	789a      	ldrb	r2, [r3, #2]
    1588:	78db      	ldrb	r3, [r3, #3]
    158a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    158e:	ea43 0302 	orr.w	r3, r3, r2
    1592:	b29b      	uxth	r3, r3
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    1594:	2b08      	cmp	r3, #8
    1596:	d01d      	beq.n	15d4 <etharp_arp_input+0xdc>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    1598:	f247 0330 	movw	r3, #28720	; 0x7030
    159c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15a0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    15a2:	f103 0301 	add.w	r3, r3, #1
    15a6:	b29a      	uxth	r2, r3
    15a8:	f247 0330 	movw	r3, #28720	; 0x7030
    15ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15b0:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
    15b2:	f247 0330 	movw	r3, #28720	; 0x7030
    15b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15ba:	8bdb      	ldrh	r3, [r3, #30]
    15bc:	f103 0301 	add.w	r3, r3, #1
    15c0:	b29a      	uxth	r2, r3
    15c2:	f247 0330 	movw	r3, #28720	; 0x7030
    15c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15ca:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
    15cc:	6878      	ldr	r0, [r7, #4]
    15ce:	f001 fd91 	bl	30f4 <pbuf_free>
    return;
    15d2:	e0d0      	b.n	1776 <etharp_arp_input+0x27e>
  }
  ETHARP_STATS_INC(etharp.recv);
    15d4:	f247 0330 	movw	r3, #28720	; 0x7030
    15d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15dc:	8b5b      	ldrh	r3, [r3, #26]
    15de:	f103 0301 	add.w	r3, r3, #1
    15e2:	b29a      	uxth	r2, r3
    15e4:	f247 0330 	movw	r3, #28720	; 0x7030
    15e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15ec:	835a      	strh	r2, [r3, #26]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    15ee:	69fb      	ldr	r3, [r7, #28]
    15f0:	f103 030e 	add.w	r3, r3, #14
    15f4:	f107 0218 	add.w	r2, r7, #24
    15f8:	4610      	mov	r0, r2
    15fa:	4619      	mov	r1, r3
    15fc:	f04f 0204 	mov.w	r2, #4
    1600:	f007 fb10 	bl	8c24 <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    1604:	69fb      	ldr	r3, [r7, #28]
    1606:	f103 0318 	add.w	r3, r3, #24
    160a:	f107 0214 	add.w	r2, r7, #20
    160e:	4610      	mov	r0, r2
    1610:	4619      	mov	r1, r3
    1612:	f04f 0204 	mov.w	r2, #4
    1616:	f007 fb05 	bl	8c24 <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    161a:	68fb      	ldr	r3, [r7, #12]
    161c:	f103 0304 	add.w	r3, r3, #4
    1620:	2b00      	cmp	r3, #0
    1622:	d003      	beq.n	162c <etharp_arp_input+0x134>
    1624:	68fb      	ldr	r3, [r7, #12]
    1626:	685b      	ldr	r3, [r3, #4]
    1628:	2b00      	cmp	r3, #0
    162a:	d104      	bne.n	1636 <etharp_arp_input+0x13e>
    for_us = 0;
    162c:	f04f 0300 	mov.w	r3, #0
    1630:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    1634:	e008      	b.n	1648 <etharp_arp_input+0x150>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    1636:	697a      	ldr	r2, [r7, #20]
    1638:	68fb      	ldr	r3, [r7, #12]
    163a:	685b      	ldr	r3, [r3, #4]
    163c:	429a      	cmp	r2, r3
    163e:	bf14      	ite	ne
    1640:	2300      	movne	r3, #0
    1642:	2301      	moveq	r3, #1
    1644:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
    1648:	69fb      	ldr	r3, [r7, #28]
    164a:	f103 0208 	add.w	r2, r3, #8
    164e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    1652:	2b00      	cmp	r3, #0
    1654:	d002      	beq.n	165c <etharp_arp_input+0x164>
    1656:	f04f 0301 	mov.w	r3, #1
    165a:	e001      	b.n	1660 <etharp_arp_input+0x168>
    165c:	f04f 0302 	mov.w	r3, #2
    1660:	f107 0118 	add.w	r1, r7, #24
    1664:	68f8      	ldr	r0, [r7, #12]
    1666:	f7ff feaf 	bl	13c8 <update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
    166a:	69fb      	ldr	r3, [r7, #28]
    166c:	799a      	ldrb	r2, [r3, #6]
    166e:	79db      	ldrb	r3, [r3, #7]
    1670:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1674:	ea43 0302 	orr.w	r3, r3, r2
    1678:	b29b      	uxth	r3, r3
    167a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    167e:	d003      	beq.n	1688 <etharp_arp_input+0x190>
    1680:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    1684:	d073      	beq.n	176e <etharp_arp_input+0x276>
    1686:	e064      	b.n	1752 <etharp_arp_input+0x25a>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
    1688:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    168c:	2b00      	cmp	r3, #0
    168e:	d05b      	beq.n	1748 <etharp_arp_input+0x250>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
    1690:	f04f 0002 	mov.w	r0, #2
    1694:	f000 fc2a 	bl	1eec <lwip_htons>
    1698:	4603      	mov	r3, r0
    169a:	461a      	mov	r2, r3
    169c:	69fb      	ldr	r3, [r7, #28]
    169e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    16a2:	f04f 0000 	mov.w	r0, #0
    16a6:	ea40 0101 	orr.w	r1, r0, r1
    16aa:	7199      	strb	r1, [r3, #6]
    16ac:	ea4f 2212 	mov.w	r2, r2, lsr #8
    16b0:	b292      	uxth	r2, r2
    16b2:	f04f 0100 	mov.w	r1, #0
    16b6:	ea41 0202 	orr.w	r2, r1, r2
    16ba:	71da      	strb	r2, [r3, #7]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    16bc:	69fb      	ldr	r3, [r7, #28]
    16be:	f103 0218 	add.w	r2, r3, #24
    16c2:	69fb      	ldr	r3, [r7, #28]
    16c4:	f103 030e 	add.w	r3, r3, #14
    16c8:	4610      	mov	r0, r2
    16ca:	4619      	mov	r1, r3
    16cc:	f04f 0204 	mov.w	r2, #4
    16d0:	f007 faa8 	bl	8c24 <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    16d4:	69fb      	ldr	r3, [r7, #28]
    16d6:	f103 020e 	add.w	r2, r3, #14
    16da:	68fb      	ldr	r3, [r7, #12]
    16dc:	f103 0304 	add.w	r3, r3, #4
    16e0:	4610      	mov	r0, r2
    16e2:	4619      	mov	r1, r3
    16e4:	f04f 0204 	mov.w	r2, #4
    16e8:	f007 fa9c 	bl	8c24 <memcpy>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    16ec:	69fb      	ldr	r3, [r7, #28]
    16ee:	f103 0212 	add.w	r2, r3, #18
    16f2:	69fb      	ldr	r3, [r7, #28]
    16f4:	f103 0308 	add.w	r3, r3, #8
    16f8:	4610      	mov	r0, r2
    16fa:	4619      	mov	r1, r3
    16fc:	f04f 0206 	mov.w	r2, #6
    1700:	f007 fa90 	bl	8c24 <memcpy>
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    1704:	6a3a      	ldr	r2, [r7, #32]
    1706:	69fb      	ldr	r3, [r7, #28]
    1708:	f103 0308 	add.w	r3, r3, #8
    170c:	4610      	mov	r0, r2
    170e:	4619      	mov	r1, r3
    1710:	f04f 0206 	mov.w	r2, #6
    1714:	f007 fa86 	bl	8c24 <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    1718:	69fb      	ldr	r3, [r7, #28]
    171a:	f103 0308 	add.w	r3, r3, #8
    171e:	4618      	mov	r0, r3
    1720:	68b9      	ldr	r1, [r7, #8]
    1722:	f04f 0206 	mov.w	r2, #6
    1726:	f007 fa7d 	bl	8c24 <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
    172a:	6a3b      	ldr	r3, [r7, #32]
    172c:	f103 0306 	add.w	r3, r3, #6
    1730:	4618      	mov	r0, r3
    1732:	68b9      	ldr	r1, [r7, #8]
    1734:	f04f 0206 	mov.w	r2, #6
    1738:	f007 fa74 	bl	8c24 <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    173c:	68fb      	ldr	r3, [r7, #12]
    173e:	699b      	ldr	r3, [r3, #24]
    1740:	68f8      	ldr	r0, [r7, #12]
    1742:	6879      	ldr	r1, [r7, #4]
    1744:	4798      	blx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
    1746:	e013      	b.n	1770 <etharp_arp_input+0x278>
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    /* we are not configured? */
    } else if (ip_addr_isany(&netif->ip_addr)) {
    1748:	68fb      	ldr	r3, [r7, #12]
    174a:	f103 0304 	add.w	r3, r3, #4
    174e:	2b00      	cmp	r3, #0
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
    1750:	e00e      	b.n	1770 <etharp_arp_input+0x278>
    dhcp_arp_reply(netif, &sipaddr);
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    1752:	f247 0330 	movw	r3, #28720	; 0x7030
    1756:	f2c2 0300 	movt	r3, #8192	; 0x2000
    175a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    175c:	f103 0301 	add.w	r3, r3, #1
    1760:	b29a      	uxth	r2, r3
    1762:	f247 0330 	movw	r3, #28720	; 0x7030
    1766:	f2c2 0300 	movt	r3, #8192	; 0x2000
    176a:	859a      	strh	r2, [r3, #44]	; 0x2c
    176c:	e000      	b.n	1770 <etharp_arp_input+0x278>
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
    176e:	bf00      	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
    1770:	6878      	ldr	r0, [r7, #4]
    1772:	f001 fcbf 	bl	30f4 <pbuf_free>
}
    1776:	f107 0728 	add.w	r7, r7, #40	; 0x28
    177a:	46bd      	mov	sp, r7
    177c:	bd80      	pop	{r7, pc}
    177e:	bf00      	nop

00001780 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
    1780:	b580      	push	{r7, lr}
    1782:	b088      	sub	sp, #32
    1784:	af00      	add	r7, sp, #0
    1786:	60f8      	str	r0, [r7, #12]
    1788:	60b9      	str	r1, [r7, #8]
    178a:	607a      	str	r2, [r7, #4]
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    178c:	68b8      	ldr	r0, [r7, #8]
    178e:	f04f 010e 	mov.w	r1, #14
    1792:	f001 fc33 	bl	2ffc <pbuf_header>
    1796:	4603      	mov	r3, r0
    1798:	2b00      	cmp	r3, #0
    179a:	d00f      	beq.n	17bc <etharp_output+0x3c>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    179c:	f247 0330 	movw	r3, #28720	; 0x7030
    17a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17a4:	895b      	ldrh	r3, [r3, #10]
    17a6:	f103 0301 	add.w	r3, r3, #1
    17aa:	b29a      	uxth	r2, r3
    17ac:	f247 0330 	movw	r3, #28720	; 0x7030
    17b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17b4:	815a      	strh	r2, [r3, #10]
    return ERR_BUF;
    17b6:	f04f 03fe 	mov.w	r3, #254	; 0xfe
    17ba:	e0c1      	b.n	1940 <etharp_output+0x1c0>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
    17bc:	f04f 0300 	mov.w	r3, #0
    17c0:	61fb      	str	r3, [r7, #28]
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    17c2:	687b      	ldr	r3, [r7, #4]
    17c4:	681b      	ldr	r3, [r3, #0]
    17c6:	4618      	mov	r0, r3
    17c8:	68f9      	ldr	r1, [r7, #12]
    17ca:	f003 fc53 	bl	5074 <ip4_addr_isbroadcast>
    17ce:	4603      	mov	r3, r0
    17d0:	2b00      	cmp	r3, #0
    17d2:	d005      	beq.n	17e0 <etharp_output+0x60>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
    17d4:	f648 6388 	movw	r3, #36488	; 0x8e88
    17d8:	f2c0 0300 	movt	r3, #0
    17dc:	61fb      	str	r3, [r7, #28]
    17de:	e0a3      	b.n	1928 <etharp_output+0x1a8>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    17e0:	687b      	ldr	r3, [r7, #4]
    17e2:	681b      	ldr	r3, [r3, #0]
    17e4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    17e8:	2be0      	cmp	r3, #224	; 0xe0
    17ea:	d11d      	bne.n	1828 <etharp_output+0xa8>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
    17ec:	f04f 0301 	mov.w	r3, #1
    17f0:	753b      	strb	r3, [r7, #20]
    mcastaddr.addr[1] = 0x00;
    17f2:	f04f 0300 	mov.w	r3, #0
    17f6:	757b      	strb	r3, [r7, #21]
    mcastaddr.addr[2] = 0x5e;
    17f8:	f04f 035e 	mov.w	r3, #94	; 0x5e
    17fc:	75bb      	strb	r3, [r7, #22]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    17fe:	687b      	ldr	r3, [r7, #4]
    1800:	f103 0301 	add.w	r3, r3, #1
    1804:	781b      	ldrb	r3, [r3, #0]
    1806:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    180a:	75fb      	strb	r3, [r7, #23]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	f103 0302 	add.w	r3, r3, #2
    1812:	781b      	ldrb	r3, [r3, #0]
    1814:	763b      	strb	r3, [r7, #24]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    1816:	687b      	ldr	r3, [r7, #4]
    1818:	f103 0303 	add.w	r3, r3, #3
    181c:	781b      	ldrb	r3, [r3, #0]
    181e:	767b      	strb	r3, [r7, #25]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
    1820:	f107 0314 	add.w	r3, r7, #20
    1824:	61fb      	str	r3, [r7, #28]
    1826:	e07f      	b.n	1928 <etharp_output+0x1a8>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    1828:	687b      	ldr	r3, [r7, #4]
    182a:	681a      	ldr	r2, [r3, #0]
    182c:	68fb      	ldr	r3, [r7, #12]
    182e:	685b      	ldr	r3, [r3, #4]
    1830:	ea82 0203 	eor.w	r2, r2, r3
    1834:	68fb      	ldr	r3, [r7, #12]
    1836:	689b      	ldr	r3, [r3, #8]
    1838:	ea02 0303 	and.w	r3, r2, r3
    183c:	2b00      	cmp	r3, #0
    183e:	d01a      	beq.n	1876 <etharp_output+0xf6>
        !ip_addr_islinklocal(ipaddr)) {
    1840:	687b      	ldr	r3, [r7, #4]
    1842:	681b      	ldr	r3, [r3, #0]
    1844:	ea4f 4303 	mov.w	r3, r3, lsl #16
    1848:	ea4f 4313 	mov.w	r3, r3, lsr #16
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    184c:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    1850:	4293      	cmp	r3, r2
    1852:	d010      	beq.n	1876 <etharp_output+0xf6>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
    1854:	68fb      	ldr	r3, [r7, #12]
    1856:	f103 030c 	add.w	r3, r3, #12
    185a:	2b00      	cmp	r3, #0
    185c:	d008      	beq.n	1870 <etharp_output+0xf0>
    185e:	68fb      	ldr	r3, [r7, #12]
    1860:	68db      	ldr	r3, [r3, #12]
    1862:	2b00      	cmp	r3, #0
    1864:	d004      	beq.n	1870 <etharp_output+0xf0>
          /* send to hardware address of default gateway IP address */
          ipaddr = &(netif->gw);
    1866:	68fb      	ldr	r3, [r7, #12]
    1868:	f103 030c 	add.w	r3, r3, #12
    186c:	607b      	str	r3, [r7, #4]
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
    186e:	e002      	b.n	1876 <etharp_output+0xf6>
          /* send to hardware address of default gateway IP address */
          ipaddr = &(netif->gw);
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
    1870:	f04f 03fc 	mov.w	r3, #252	; 0xfc
    1874:	e064      	b.n	1940 <etharp_output+0x1c0>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) &&
    1876:	f240 63dc 	movw	r3, #1756	; 0x6dc
    187a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    187e:	781b      	ldrb	r3, [r3, #0]
    1880:	f240 623c 	movw	r2, #1596	; 0x63c
    1884:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1888:	ea4f 0343 	mov.w	r3, r3, lsl #1
    188c:	f103 0301 	add.w	r3, r3, #1
    1890:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1894:	4413      	add	r3, r2
    1896:	799b      	ldrb	r3, [r3, #6]
    1898:	2b02      	cmp	r3, #2
    189a:	d13c      	bne.n	1916 <etharp_output+0x196>
            (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr))) {
    189c:	687b      	ldr	r3, [r7, #4]
    189e:	681a      	ldr	r2, [r3, #0]
    18a0:	f240 63dc 	movw	r3, #1756	; 0x6dc
    18a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18a8:	781b      	ldrb	r3, [r3, #0]
    18aa:	4619      	mov	r1, r3
    18ac:	f240 633c 	movw	r3, #1596	; 0x63c
    18b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18b4:	ea4f 1101 	mov.w	r1, r1, lsl #4
    18b8:	440b      	add	r3, r1
    18ba:	f103 0304 	add.w	r3, r3, #4
    18be:	681b      	ldr	r3, [r3, #0]
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) &&
    18c0:	429a      	cmp	r2, r3
    18c2:	d128      	bne.n	1916 <etharp_output+0x196>
            (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
    18c4:	f247 0330 	movw	r3, #28720	; 0x7030
    18c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18cc:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    18ce:	f103 0301 	add.w	r3, r3, #1
    18d2:	b29a      	uxth	r2, r3
    18d4:	f247 0330 	movw	r3, #28720	; 0x7030
    18d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18dc:	85da      	strh	r2, [r3, #46]	; 0x2e
          return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
    18de:	68fb      	ldr	r3, [r7, #12]
    18e0:	f103 0323 	add.w	r3, r3, #35	; 0x23
    18e4:	461a      	mov	r2, r3
    18e6:	f240 63dc 	movw	r3, #1756	; 0x6dc
    18ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18ee:	781b      	ldrb	r3, [r3, #0]
    18f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    18f4:	f103 0301 	add.w	r3, r3, #1
    18f8:	ea4f 01c3 	mov.w	r1, r3, lsl #3
    18fc:	f240 633c 	movw	r3, #1596	; 0x63c
    1900:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1904:	440b      	add	r3, r1
    1906:	68f8      	ldr	r0, [r7, #12]
    1908:	68b9      	ldr	r1, [r7, #8]
    190a:	f7ff fd2b 	bl	1364 <etharp_send_ip>
    190e:	4603      	mov	r3, r0
    1910:	b2db      	uxtb	r3, r3
    1912:	b2db      	uxtb	r3, r3
    1914:	e014      	b.n	1940 <etharp_output+0x1c0>
#if LWIP_NETIF_HWADDRHINT
      }
    }
#endif /* LWIP_NETIF_HWADDRHINT */
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
    1916:	68f8      	ldr	r0, [r7, #12]
    1918:	6879      	ldr	r1, [r7, #4]
    191a:	68ba      	ldr	r2, [r7, #8]
    191c:	f000 f816 	bl	194c <etharp_query>
    1920:	4603      	mov	r3, r0
    1922:	b2db      	uxtb	r3, r3
    1924:	b2db      	uxtb	r3, r3
    1926:	e00b      	b.n	1940 <etharp_output+0x1c0>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
    1928:	68fb      	ldr	r3, [r7, #12]
    192a:	f103 0323 	add.w	r3, r3, #35	; 0x23
    192e:	68f8      	ldr	r0, [r7, #12]
    1930:	68b9      	ldr	r1, [r7, #8]
    1932:	461a      	mov	r2, r3
    1934:	69fb      	ldr	r3, [r7, #28]
    1936:	f7ff fd15 	bl	1364 <etharp_send_ip>
    193a:	4603      	mov	r3, r0
    193c:	b2db      	uxtb	r3, r3
    193e:	b2db      	uxtb	r3, r3
    1940:	b25b      	sxtb	r3, r3
}
    1942:	4618      	mov	r0, r3
    1944:	f107 0720 	add.w	r7, r7, #32
    1948:	46bd      	mov	sp, r7
    194a:	bd80      	pop	{r7, pc}

0000194c <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
    194c:	b580      	push	{r7, lr}
    194e:	b088      	sub	sp, #32
    1950:	af00      	add	r7, sp, #0
    1952:	60f8      	str	r0, [r7, #12]
    1954:	60b9      	str	r1, [r7, #8]
    1956:	607a      	str	r2, [r7, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
    1958:	68fb      	ldr	r3, [r7, #12]
    195a:	f103 0323 	add.w	r3, r3, #35	; 0x23
    195e:	613b      	str	r3, [r7, #16]
  err_t result = ERR_MEM;
    1960:	f04f 33ff 	mov.w	r3, #4294967295
    1964:	75bb      	strb	r3, [r7, #22]
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    1966:	68bb      	ldr	r3, [r7, #8]
    1968:	681b      	ldr	r3, [r3, #0]
    196a:	4618      	mov	r0, r3
    196c:	68f9      	ldr	r1, [r7, #12]
    196e:	f003 fb81 	bl	5074 <ip4_addr_isbroadcast>
    1972:	4603      	mov	r3, r0
    1974:	2b00      	cmp	r3, #0
    1976:	d10c      	bne.n	1992 <etharp_query+0x46>
      ip_addr_ismulticast(ipaddr) ||
    1978:	68bb      	ldr	r3, [r7, #8]
    197a:	681b      	ldr	r3, [r3, #0]
    197c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    1980:	2be0      	cmp	r3, #224	; 0xe0
    1982:	d006      	beq.n	1992 <etharp_query+0x46>
    1984:	68bb      	ldr	r3, [r7, #8]
    1986:	2b00      	cmp	r3, #0
    1988:	d003      	beq.n	1992 <etharp_query+0x46>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    198a:	68bb      	ldr	r3, [r7, #8]
    198c:	681b      	ldr	r3, [r3, #0]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    198e:	2b00      	cmp	r3, #0
    1990:	d102      	bne.n	1998 <etharp_query+0x4c>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    1992:	f04f 03f2 	mov.w	r3, #242	; 0xf2
    1996:	e125      	b.n	1be4 <etharp_query+0x298>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    1998:	68b8      	ldr	r0, [r7, #8]
    199a:	f04f 0101 	mov.w	r1, #1
    199e:	f7ff fbb3 	bl	1108 <find_entry>
    19a2:	4603      	mov	r3, r0
    19a4:	b2db      	uxtb	r3, r3
    19a6:	75fb      	strb	r3, [r7, #23]

  /* could not find or create entry? */
  if (i < 0) {
    19a8:	f997 3017 	ldrsb.w	r3, [r7, #23]
    19ac:	2b00      	cmp	r3, #0
    19ae:	da11      	bge.n	19d4 <etharp_query+0x88>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
    19b0:	687b      	ldr	r3, [r7, #4]
    19b2:	2b00      	cmp	r3, #0
    19b4:	d00c      	beq.n	19d0 <etharp_query+0x84>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    19b6:	f247 0330 	movw	r3, #28720	; 0x7030
    19ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19be:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    19c0:	f103 0301 	add.w	r3, r3, #1
    19c4:	b29a      	uxth	r2, r3
    19c6:	f247 0330 	movw	r3, #28720	; 0x7030
    19ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19ce:	849a      	strh	r2, [r3, #36]	; 0x24
    }
    return (err_t)i;
    19d0:	7dfb      	ldrb	r3, [r7, #23]
    19d2:	e107      	b.n	1be4 <etharp_query+0x298>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    19d4:	f997 3017 	ldrsb.w	r3, [r7, #23]
    19d8:	f240 623c 	movw	r2, #1596	; 0x63c
    19dc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    19e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    19e4:	f103 0301 	add.w	r3, r3, #1
    19e8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    19ec:	4413      	add	r3, r2
    19ee:	799b      	ldrb	r3, [r3, #6]
    19f0:	2b00      	cmp	r3, #0
    19f2:	d10f      	bne.n	1a14 <etharp_query+0xc8>
    arp_table[i].state = ETHARP_STATE_PENDING;
    19f4:	f997 3017 	ldrsb.w	r3, [r7, #23]
    19f8:	f240 623c 	movw	r2, #1596	; 0x63c
    19fc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1a00:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1a04:	f103 0301 	add.w	r3, r3, #1
    1a08:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1a0c:	4413      	add	r3, r2
    1a0e:	f04f 0201 	mov.w	r2, #1
    1a12:	719a      	strb	r2, [r3, #6]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
    1a14:	f997 3017 	ldrsb.w	r3, [r7, #23]
    1a18:	f240 623c 	movw	r2, #1596	; 0x63c
    1a1c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1a20:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1a24:	f103 0301 	add.w	r3, r3, #1
    1a28:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1a2c:	4413      	add	r3, r2
    1a2e:	799b      	ldrb	r3, [r3, #6]
    1a30:	2b01      	cmp	r3, #1
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    1a32:	f997 3017 	ldrsb.w	r3, [r7, #23]
    1a36:	f240 623c 	movw	r2, #1596	; 0x63c
    1a3a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1a3e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1a42:	f103 0301 	add.w	r3, r3, #1
    1a46:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1a4a:	4413      	add	r3, r2
    1a4c:	799b      	ldrb	r3, [r3, #6]
    1a4e:	2b01      	cmp	r3, #1
    1a50:	d002      	beq.n	1a58 <etharp_query+0x10c>
    1a52:	687b      	ldr	r3, [r7, #4]
    1a54:	2b00      	cmp	r3, #0
    1a56:	d10b      	bne.n	1a70 <etharp_query+0x124>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    1a58:	68f8      	ldr	r0, [r7, #12]
    1a5a:	68b9      	ldr	r1, [r7, #8]
    1a5c:	f000 f988 	bl	1d70 <etharp_request>
    1a60:	4603      	mov	r3, r0
    1a62:	b2db      	uxtb	r3, r3
    1a64:	75bb      	strb	r3, [r7, #22]
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
    1a66:	687b      	ldr	r3, [r7, #4]
    1a68:	2b00      	cmp	r3, #0
    1a6a:	d101      	bne.n	1a70 <etharp_query+0x124>
      return result;
    1a6c:	7dbb      	ldrb	r3, [r7, #22]
    1a6e:	e0b9      	b.n	1be4 <etharp_query+0x298>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state == ETHARP_STATE_STABLE) {
    1a70:	f997 3017 	ldrsb.w	r3, [r7, #23]
    1a74:	f240 623c 	movw	r2, #1596	; 0x63c
    1a78:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1a7c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1a80:	f103 0301 	add.w	r3, r3, #1
    1a84:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1a88:	4413      	add	r3, r2
    1a8a:	799b      	ldrb	r3, [r3, #6]
    1a8c:	2b02      	cmp	r3, #2
    1a8e:	d11b      	bne.n	1ac8 <etharp_query+0x17c>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    1a90:	7dfa      	ldrb	r2, [r7, #23]
    1a92:	f240 63dc 	movw	r3, #1756	; 0x6dc
    1a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a9a:	701a      	strb	r2, [r3, #0]
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    1a9c:	f997 3017 	ldrsb.w	r3, [r7, #23]
    1aa0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1aa4:	f103 0301 	add.w	r3, r3, #1
    1aa8:	ea4f 02c3 	mov.w	r2, r3, lsl #3
    1aac:	f240 633c 	movw	r3, #1596	; 0x63c
    1ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ab4:	4413      	add	r3, r2
    1ab6:	68f8      	ldr	r0, [r7, #12]
    1ab8:	6879      	ldr	r1, [r7, #4]
    1aba:	693a      	ldr	r2, [r7, #16]
    1abc:	f7ff fc52 	bl	1364 <etharp_send_ip>
    1ac0:	4603      	mov	r3, r0
    1ac2:	b2db      	uxtb	r3, r3
    1ac4:	75bb      	strb	r3, [r7, #22]
    1ac6:	e08c      	b.n	1be2 <etharp_query+0x296>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    1ac8:	f997 3017 	ldrsb.w	r3, [r7, #23]
    1acc:	f240 623c 	movw	r2, #1596	; 0x63c
    1ad0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1ad4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1ad8:	f103 0301 	add.w	r3, r3, #1
    1adc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1ae0:	4413      	add	r3, r2
    1ae2:	799b      	ldrb	r3, [r3, #6]
    1ae4:	2b01      	cmp	r3, #1
    1ae6:	d17c      	bne.n	1be2 <etharp_query+0x296>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
    1ae8:	f04f 0300 	mov.w	r3, #0
    1aec:	61fb      	str	r3, [r7, #28]
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    1aee:	687b      	ldr	r3, [r7, #4]
    1af0:	61bb      	str	r3, [r7, #24]
    while (p) {
    1af2:	e00f      	b.n	1b14 <etharp_query+0x1c8>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
    1af4:	69bb      	ldr	r3, [r7, #24]
    1af6:	895a      	ldrh	r2, [r3, #10]
    1af8:	69bb      	ldr	r3, [r7, #24]
    1afa:	891b      	ldrh	r3, [r3, #8]
    1afc:	429a      	cmp	r2, r3
      if(p->type != PBUF_ROM) {
    1afe:	69bb      	ldr	r3, [r7, #24]
    1b00:	7b1b      	ldrb	r3, [r3, #12]
    1b02:	2b01      	cmp	r3, #1
    1b04:	d003      	beq.n	1b0e <etharp_query+0x1c2>
        copy_needed = 1;
    1b06:	f04f 0301 	mov.w	r3, #1
    1b0a:	61fb      	str	r3, [r7, #28]
        break;
    1b0c:	e005      	b.n	1b1a <etharp_query+0x1ce>
      }
      p = p->next;
    1b0e:	69bb      	ldr	r3, [r7, #24]
    1b10:	681b      	ldr	r3, [r3, #0]
    1b12:	61bb      	str	r3, [r7, #24]
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
    1b14:	69bb      	ldr	r3, [r7, #24]
    1b16:	2b00      	cmp	r3, #0
    1b18:	d1ec      	bne.n	1af4 <etharp_query+0x1a8>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
    1b1a:	69fb      	ldr	r3, [r7, #28]
    1b1c:	2b00      	cmp	r3, #0
    1b1e:	d01c      	beq.n	1b5a <etharp_query+0x20e>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    1b20:	69bb      	ldr	r3, [r7, #24]
    1b22:	891b      	ldrh	r3, [r3, #8]
    1b24:	f04f 0003 	mov.w	r0, #3
    1b28:	4619      	mov	r1, r3
    1b2a:	f04f 0200 	mov.w	r2, #0
    1b2e:	f001 f863 	bl	2bf8 <pbuf_alloc>
    1b32:	4603      	mov	r3, r0
    1b34:	61bb      	str	r3, [r7, #24]
      if(p != NULL) {
    1b36:	69bb      	ldr	r3, [r7, #24]
    1b38:	2b00      	cmp	r3, #0
    1b3a:	d014      	beq.n	1b66 <etharp_query+0x21a>
        if (pbuf_copy(p, q) != ERR_OK) {
    1b3c:	69b8      	ldr	r0, [r7, #24]
    1b3e:	6879      	ldr	r1, [r7, #4]
    1b40:	f001 fba8 	bl	3294 <pbuf_copy>
    1b44:	4603      	mov	r3, r0
    1b46:	b2db      	uxtb	r3, r3
    1b48:	2b00      	cmp	r3, #0
    1b4a:	d00e      	beq.n	1b6a <etharp_query+0x21e>
          pbuf_free(p);
    1b4c:	69b8      	ldr	r0, [r7, #24]
    1b4e:	f001 fad1 	bl	30f4 <pbuf_free>
          p = NULL;
    1b52:	f04f 0300 	mov.w	r3, #0
    1b56:	61bb      	str	r3, [r7, #24]
    1b58:	e008      	b.n	1b6c <etharp_query+0x220>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
    1b5a:	687b      	ldr	r3, [r7, #4]
    1b5c:	61bb      	str	r3, [r7, #24]
      pbuf_ref(p);
    1b5e:	69b8      	ldr	r0, [r7, #24]
    1b60:	f001 fb46 	bl	31f0 <pbuf_ref>
    1b64:	e002      	b.n	1b6c <etharp_query+0x220>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
      if(p != NULL) {
        if (pbuf_copy(p, q) != ERR_OK) {
          pbuf_free(p);
          p = NULL;
    1b66:	bf00      	nop
    1b68:	e000      	b.n	1b6c <etharp_query+0x220>
    1b6a:	bf00      	nop
      /* referencing the old pbuf is enough */
      p = q;
      pbuf_ref(p);
    }
    /* packet could be taken over? */
    if (p != NULL) {
    1b6c:	69bb      	ldr	r3, [r7, #24]
    1b6e:	2b00      	cmp	r3, #0
    1b70:	d027      	beq.n	1bc2 <etharp_query+0x276>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
    1b72:	f997 2017 	ldrsb.w	r2, [r7, #23]
    1b76:	f240 633c 	movw	r3, #1596	; 0x63c
    1b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b7e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    1b82:	4413      	add	r3, r2
    1b84:	681b      	ldr	r3, [r3, #0]
    1b86:	2b00      	cmp	r3, #0
    1b88:	d00c      	beq.n	1ba4 <etharp_query+0x258>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
    1b8a:	f997 2017 	ldrsb.w	r2, [r7, #23]
    1b8e:	f240 633c 	movw	r3, #1596	; 0x63c
    1b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b96:	ea4f 1202 	mov.w	r2, r2, lsl #4
    1b9a:	4413      	add	r3, r2
    1b9c:	681b      	ldr	r3, [r3, #0]
    1b9e:	4618      	mov	r0, r3
    1ba0:	f001 faa8 	bl	30f4 <pbuf_free>
      }
      arp_table[i].q = p;
    1ba4:	f997 2017 	ldrsb.w	r2, [r7, #23]
    1ba8:	f240 633c 	movw	r3, #1596	; 0x63c
    1bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bb0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    1bb4:	4413      	add	r3, r2
    1bb6:	69ba      	ldr	r2, [r7, #24]
    1bb8:	601a      	str	r2, [r3, #0]
      result = ERR_OK;
    1bba:	f04f 0300 	mov.w	r3, #0
    1bbe:	75bb      	strb	r3, [r7, #22]
    1bc0:	e00f      	b.n	1be2 <etharp_query+0x296>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
    1bc2:	f247 0330 	movw	r3, #28720	; 0x7030
    1bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bca:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    1bcc:	f103 0301 	add.w	r3, r3, #1
    1bd0:	b29a      	uxth	r2, r3
    1bd2:	f247 0330 	movw	r3, #28720	; 0x7030
    1bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bda:	849a      	strh	r2, [r3, #36]	; 0x24
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    1bdc:	f04f 33ff 	mov.w	r3, #4294967295
    1be0:	75bb      	strb	r3, [r7, #22]
    }
  }
  return result;
    1be2:	7dbb      	ldrb	r3, [r7, #22]
    1be4:	b25b      	sxtb	r3, r3
}
    1be6:	4618      	mov	r0, r3
    1be8:	f107 0720 	add.w	r7, r7, #32
    1bec:	46bd      	mov	sp, r7
    1bee:	bd80      	pop	{r7, pc}

00001bf0 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
    1bf0:	b580      	push	{r7, lr}
    1bf2:	b088      	sub	sp, #32
    1bf4:	af00      	add	r7, sp, #0
    1bf6:	60f8      	str	r0, [r7, #12]
    1bf8:	60b9      	str	r1, [r7, #8]
    1bfa:	607a      	str	r2, [r7, #4]
    1bfc:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
    1bfe:	f04f 0300 	mov.w	r3, #0
    1c02:	75fb      	strb	r3, [r7, #23]
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    1c04:	f04f 0003 	mov.w	r0, #3
    1c08:	f04f 012a 	mov.w	r1, #42	; 0x2a
    1c0c:	f04f 0200 	mov.w	r2, #0
    1c10:	f000 fff2 	bl	2bf8 <pbuf_alloc>
    1c14:	4603      	mov	r3, r0
    1c16:	613b      	str	r3, [r7, #16]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    1c18:	693b      	ldr	r3, [r7, #16]
    1c1a:	2b00      	cmp	r3, #0
    1c1c:	d10f      	bne.n	1c3e <etharp_raw+0x4e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    1c1e:	f247 0330 	movw	r3, #28720	; 0x7030
    1c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c26:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    1c28:	f103 0301 	add.w	r3, r3, #1
    1c2c:	b29a      	uxth	r2, r3
    1c2e:	f247 0330 	movw	r3, #28720	; 0x7030
    1c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c36:	849a      	strh	r2, [r3, #36]	; 0x24
    return ERR_MEM;
    1c38:	f04f 03ff 	mov.w	r3, #255	; 0xff
    1c3c:	e091      	b.n	1d62 <etharp_raw+0x172>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
    1c3e:	693b      	ldr	r3, [r7, #16]
    1c40:	685b      	ldr	r3, [r3, #4]
    1c42:	61bb      	str	r3, [r7, #24]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    1c44:	69bb      	ldr	r3, [r7, #24]
    1c46:	f103 030e 	add.w	r3, r3, #14
    1c4a:	61fb      	str	r3, [r7, #28]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
    1c4c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    1c4e:	4618      	mov	r0, r3
    1c50:	f000 f94c 	bl	1eec <lwip_htons>
    1c54:	4603      	mov	r3, r0
    1c56:	461a      	mov	r2, r3
    1c58:	69fb      	ldr	r3, [r7, #28]
    1c5a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1c5e:	f04f 0000 	mov.w	r0, #0
    1c62:	ea40 0101 	orr.w	r1, r0, r1
    1c66:	7199      	strb	r1, [r3, #6]
    1c68:	ea4f 2212 	mov.w	r2, r2, lsr #8
    1c6c:	b292      	uxth	r2, r2
    1c6e:	f04f 0100 	mov.w	r1, #0
    1c72:	ea41 0202 	orr.w	r2, r1, r2
    1c76:	71da      	strb	r2, [r3, #7]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    1c78:	69fb      	ldr	r3, [r7, #28]
    1c7a:	f103 0308 	add.w	r3, r3, #8
    1c7e:	4618      	mov	r0, r3
    1c80:	6839      	ldr	r1, [r7, #0]
    1c82:	f04f 0206 	mov.w	r2, #6
    1c86:	f006 ffcd 	bl	8c24 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    1c8a:	69fb      	ldr	r3, [r7, #28]
    1c8c:	f103 0312 	add.w	r3, r3, #18
    1c90:	4618      	mov	r0, r3
    1c92:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    1c94:	f04f 0206 	mov.w	r2, #6
    1c98:	f006 ffc4 	bl	8c24 <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    1c9c:	69bb      	ldr	r3, [r7, #24]
    1c9e:	4618      	mov	r0, r3
    1ca0:	6879      	ldr	r1, [r7, #4]
    1ca2:	f04f 0206 	mov.w	r2, #6
    1ca6:	f006 ffbd 	bl	8c24 <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    1caa:	69bb      	ldr	r3, [r7, #24]
    1cac:	f103 0306 	add.w	r3, r3, #6
    1cb0:	4618      	mov	r0, r3
    1cb2:	68b9      	ldr	r1, [r7, #8]
    1cb4:	f04f 0206 	mov.w	r2, #6
    1cb8:	f006 ffb4 	bl	8c24 <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    1cbc:	69fb      	ldr	r3, [r7, #28]
    1cbe:	f103 030e 	add.w	r3, r3, #14
    1cc2:	4618      	mov	r0, r3
    1cc4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    1cc6:	f04f 0204 	mov.w	r2, #4
    1cca:	f006 ffab 	bl	8c24 <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    1cce:	69fb      	ldr	r3, [r7, #28]
    1cd0:	f103 0318 	add.w	r3, r3, #24
    1cd4:	4618      	mov	r0, r3
    1cd6:	6b39      	ldr	r1, [r7, #48]	; 0x30
    1cd8:	f04f 0204 	mov.w	r2, #4
    1cdc:	f006 ffa2 	bl	8c24 <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    1ce0:	69fb      	ldr	r3, [r7, #28]
    1ce2:	f04f 0200 	mov.w	r2, #0
    1ce6:	701a      	strb	r2, [r3, #0]
    1ce8:	f04f 0200 	mov.w	r2, #0
    1cec:	f042 0201 	orr.w	r2, r2, #1
    1cf0:	705a      	strb	r2, [r3, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
    1cf2:	69fb      	ldr	r3, [r7, #28]
    1cf4:	f04f 0200 	mov.w	r2, #0
    1cf8:	f042 0208 	orr.w	r2, r2, #8
    1cfc:	709a      	strb	r2, [r3, #2]
    1cfe:	f04f 0200 	mov.w	r2, #0
    1d02:	70da      	strb	r2, [r3, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
    1d04:	69fb      	ldr	r3, [r7, #28]
    1d06:	f04f 0206 	mov.w	r2, #6
    1d0a:	711a      	strb	r2, [r3, #4]
  hdr->protolen = sizeof(ip_addr_t);
    1d0c:	69fb      	ldr	r3, [r7, #28]
    1d0e:	f04f 0204 	mov.w	r2, #4
    1d12:	715a      	strb	r2, [r3, #5]

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    1d14:	69bb      	ldr	r3, [r7, #24]
    1d16:	f04f 0200 	mov.w	r2, #0
    1d1a:	f042 0208 	orr.w	r2, r2, #8
    1d1e:	731a      	strb	r2, [r3, #12]
    1d20:	f04f 0200 	mov.w	r2, #0
    1d24:	f042 0206 	orr.w	r2, r2, #6
    1d28:	735a      	strb	r2, [r3, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    1d2a:	68fb      	ldr	r3, [r7, #12]
    1d2c:	699b      	ldr	r3, [r3, #24]
    1d2e:	68f8      	ldr	r0, [r7, #12]
    1d30:	6939      	ldr	r1, [r7, #16]
    1d32:	4798      	blx	r3
    1d34:	4603      	mov	r3, r0
    1d36:	b2db      	uxtb	r3, r3
    1d38:	75fb      	strb	r3, [r7, #23]
  ETHARP_STATS_INC(etharp.xmit);
    1d3a:	f247 0330 	movw	r3, #28720	; 0x7030
    1d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d42:	8b1b      	ldrh	r3, [r3, #24]
    1d44:	f103 0301 	add.w	r3, r3, #1
    1d48:	b29a      	uxth	r2, r3
    1d4a:	f247 0330 	movw	r3, #28720	; 0x7030
    1d4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d52:	831a      	strh	r2, [r3, #24]
  /* free ARP query packet */
  pbuf_free(p);
    1d54:	6938      	ldr	r0, [r7, #16]
    1d56:	f001 f9cd 	bl	30f4 <pbuf_free>
  p = NULL;
    1d5a:	f04f 0300 	mov.w	r3, #0
    1d5e:	613b      	str	r3, [r7, #16]
  /* could not allocate pbuf for ARP request */

  return result;
    1d60:	7dfb      	ldrb	r3, [r7, #23]
    1d62:	b25b      	sxtb	r3, r3
}
    1d64:	4618      	mov	r0, r3
    1d66:	f107 0720 	add.w	r7, r7, #32
    1d6a:	46bd      	mov	sp, r7
    1d6c:	bd80      	pop	{r7, pc}
    1d6e:	bf00      	nop

00001d70 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    1d70:	b580      	push	{r7, lr}
    1d72:	b086      	sub	sp, #24
    1d74:	af04      	add	r7, sp, #16
    1d76:	6078      	str	r0, [r7, #4]
    1d78:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
    1d7a:	687b      	ldr	r3, [r7, #4]
    1d7c:	f103 0323 	add.w	r3, r3, #35	; 0x23
    1d80:	461a      	mov	r2, r3
    1d82:	687b      	ldr	r3, [r7, #4]
    1d84:	f103 0323 	add.w	r3, r3, #35	; 0x23
    1d88:	469c      	mov	ip, r3
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
    1d8a:	687b      	ldr	r3, [r7, #4]
    1d8c:	f103 0304 	add.w	r3, r3, #4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
    1d90:	9300      	str	r3, [sp, #0]
    1d92:	f648 6390 	movw	r3, #36496	; 0x8e90
    1d96:	f2c0 0300 	movt	r3, #0
    1d9a:	9301      	str	r3, [sp, #4]
    1d9c:	683b      	ldr	r3, [r7, #0]
    1d9e:	9302      	str	r3, [sp, #8]
    1da0:	f04f 0301 	mov.w	r3, #1
    1da4:	9303      	str	r3, [sp, #12]
    1da6:	6878      	ldr	r0, [r7, #4]
    1da8:	4611      	mov	r1, r2
    1daa:	f648 6288 	movw	r2, #36488	; 0x8e88
    1dae:	f2c0 0200 	movt	r2, #0
    1db2:	4663      	mov	r3, ip
    1db4:	f7ff ff1c 	bl	1bf0 <etharp_raw>
    1db8:	4603      	mov	r3, r0
    1dba:	b2db      	uxtb	r3, r3
    1dbc:	b2db      	uxtb	r3, r3
    1dbe:	b25b      	sxtb	r3, r3
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
    1dc0:	4618      	mov	r0, r3
    1dc2:	f107 0708 	add.w	r7, r7, #8
    1dc6:	46bd      	mov	sp, r7
    1dc8:	bd80      	pop	{r7, pc}
    1dca:	bf00      	nop

00001dcc <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
    1dcc:	b580      	push	{r7, lr}
    1dce:	b084      	sub	sp, #16
    1dd0:	af00      	add	r7, sp, #0
    1dd2:	6078      	str	r0, [r7, #4]
    1dd4:	6039      	str	r1, [r7, #0]
  struct eth_hdr* ethhdr;
  u16_t type;
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
    1dd6:	f04f 030e 	mov.w	r3, #14
    1dda:	81fb      	strh	r3, [r7, #14]

  if (p->len <= SIZEOF_ETH_HDR) {
    1ddc:	687b      	ldr	r3, [r7, #4]
    1dde:	895b      	ldrh	r3, [r3, #10]
    1de0:	2b0e      	cmp	r3, #14
    1de2:	d81a      	bhi.n	1e1a <ethernet_input+0x4e>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
    1de4:	f247 0330 	movw	r3, #28720	; 0x7030
    1de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dec:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1dee:	f103 0301 	add.w	r3, r3, #1
    1df2:	b29a      	uxth	r2, r3
    1df4:	f247 0330 	movw	r3, #28720	; 0x7030
    1df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dfc:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
    1dfe:	f247 0330 	movw	r3, #28720	; 0x7030
    1e02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e06:	8bdb      	ldrh	r3, [r3, #30]
    1e08:	f103 0301 	add.w	r3, r3, #1
    1e0c:	b29a      	uxth	r2, r3
    1e0e:	f247 0330 	movw	r3, #28720	; 0x7030
    1e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e16:	83da      	strh	r2, [r3, #30]
    goto free_and_return;
    1e18:	e05c      	b.n	1ed4 <ethernet_input+0x108>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
    1e1a:	687b      	ldr	r3, [r7, #4]
    1e1c:	685b      	ldr	r3, [r3, #4]
    1e1e:	60bb      	str	r3, [r7, #8]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
    1e20:	68bb      	ldr	r3, [r7, #8]
    1e22:	7b1a      	ldrb	r2, [r3, #12]
    1e24:	7b5b      	ldrb	r3, [r3, #13]
    1e26:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1e2a:	ea43 0302 	orr.w	r3, r3, r2
    1e2e:	81bb      	strh	r3, [r7, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  switch (type) {
    1e30:	89bb      	ldrh	r3, [r7, #12]
    1e32:	2b08      	cmp	r3, #8
    1e34:	d003      	beq.n	1e3e <ethernet_input+0x72>
    1e36:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
    1e3a:	d018      	beq.n	1e6e <ethernet_input+0xa2>
    1e3c:	e027      	b.n	1e8e <ethernet_input+0xc2>
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    1e3e:	683b      	ldr	r3, [r7, #0]
    1e40:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    1e44:	f003 0320 	and.w	r3, r3, #32
    1e48:	2b00      	cmp	r3, #0
    1e4a:	d03e      	beq.n	1eca <ethernet_input+0xfe>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
    1e4c:	89fb      	ldrh	r3, [r7, #14]
    1e4e:	f1c3 0300 	rsb	r3, r3, #0
    1e52:	b29b      	uxth	r3, r3
    1e54:	b21b      	sxth	r3, r3
    1e56:	6878      	ldr	r0, [r7, #4]
    1e58:	4619      	mov	r1, r3
    1e5a:	f001 f8cf 	bl	2ffc <pbuf_header>
    1e5e:	4603      	mov	r3, r0
    1e60:	2b00      	cmp	r3, #0
    1e62:	d134      	bne.n	1ece <ethernet_input+0x102>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
    1e64:	6878      	ldr	r0, [r7, #4]
    1e66:	6839      	ldr	r1, [r7, #0]
    1e68:	f002 fcac 	bl	47c4 <ip_input>
      }
      break;
    1e6c:	e02a      	b.n	1ec4 <ethernet_input+0xf8>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    1e6e:	683b      	ldr	r3, [r7, #0]
    1e70:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    1e74:	f003 0320 	and.w	r3, r3, #32
    1e78:	2b00      	cmp	r3, #0
    1e7a:	d02a      	beq.n	1ed2 <ethernet_input+0x106>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
    1e7c:	683b      	ldr	r3, [r7, #0]
    1e7e:	f103 0323 	add.w	r3, r3, #35	; 0x23
    1e82:	6838      	ldr	r0, [r7, #0]
    1e84:	4619      	mov	r1, r3
    1e86:	687a      	ldr	r2, [r7, #4]
    1e88:	f7ff fb36 	bl	14f8 <etharp_arp_input>
      break;
    1e8c:	e01a      	b.n	1ec4 <ethernet_input+0xf8>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
    1e8e:	f247 0330 	movw	r3, #28720	; 0x7030
    1e92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e96:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    1e98:	f103 0301 	add.w	r3, r3, #1
    1e9c:	b29a      	uxth	r2, r3
    1e9e:	f247 0330 	movw	r3, #28720	; 0x7030
    1ea2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ea6:	851a      	strh	r2, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
    1ea8:	f247 0330 	movw	r3, #28720	; 0x7030
    1eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1eb0:	8bdb      	ldrh	r3, [r3, #30]
    1eb2:	f103 0301 	add.w	r3, r3, #1
    1eb6:	b29a      	uxth	r2, r3
    1eb8:	f247 0330 	movw	r3, #28720	; 0x7030
    1ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ec0:	83da      	strh	r2, [r3, #30]
      goto free_and_return;
    1ec2:	e007      	b.n	1ed4 <ethernet_input+0x108>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
    1ec4:	f04f 0300 	mov.w	r3, #0
    1ec8:	e009      	b.n	1ede <ethernet_input+0x112>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    1eca:	bf00      	nop
    1ecc:	e002      	b.n	1ed4 <ethernet_input+0x108>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
    1ece:	bf00      	nop
    1ed0:	e000      	b.n	1ed4 <ethernet_input+0x108>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    1ed2:	bf00      	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
    1ed4:	6878      	ldr	r0, [r7, #4]
    1ed6:	f001 f90d 	bl	30f4 <pbuf_free>
  return ERR_OK;
    1eda:	f04f 0300 	mov.w	r3, #0
    1ede:	b25b      	sxtb	r3, r3
}
    1ee0:	4618      	mov	r0, r3
    1ee2:	f107 0710 	add.w	r7, r7, #16
    1ee6:	46bd      	mov	sp, r7
    1ee8:	bd80      	pop	{r7, pc}
    1eea:	bf00      	nop

00001eec <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
    1eec:	b480      	push	{r7}
    1eee:	b083      	sub	sp, #12
    1ef0:	af00      	add	r7, sp, #0
    1ef2:	4603      	mov	r3, r0
    1ef4:	80fb      	strh	r3, [r7, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    1ef6:	88fb      	ldrh	r3, [r7, #6]
    1ef8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1efc:	b29a      	uxth	r2, r3
    1efe:	88fb      	ldrh	r3, [r7, #6]
    1f00:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1f04:	b29b      	uxth	r3, r3
    1f06:	ea42 0303 	orr.w	r3, r2, r3
    1f0a:	b29b      	uxth	r3, r3
    1f0c:	b29b      	uxth	r3, r3
}
    1f0e:	4618      	mov	r0, r3
    1f10:	f107 070c 	add.w	r7, r7, #12
    1f14:	46bd      	mov	sp, r7
    1f16:	bc80      	pop	{r7}
    1f18:	4770      	bx	lr
    1f1a:	bf00      	nop

00001f1c <lwip_ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
    1f1c:	b580      	push	{r7, lr}
    1f1e:	b082      	sub	sp, #8
    1f20:	af00      	add	r7, sp, #0
    1f22:	4603      	mov	r3, r0
    1f24:	80fb      	strh	r3, [r7, #6]
  return lwip_htons(n);
    1f26:	88fb      	ldrh	r3, [r7, #6]
    1f28:	4618      	mov	r0, r3
    1f2a:	f7ff ffdf 	bl	1eec <lwip_htons>
    1f2e:	4603      	mov	r3, r0
}
    1f30:	4618      	mov	r0, r3
    1f32:	f107 0708 	add.w	r7, r7, #8
    1f36:	46bd      	mov	sp, r7
    1f38:	bd80      	pop	{r7, pc}
    1f3a:	bf00      	nop

00001f3c <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    1f3c:	b580      	push	{r7, lr}
    1f3e:	af00      	add	r7, sp, #0
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
    1f40:	f001 faa4 	bl	348c <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
    1f44:	f000 f88c 	bl	2060 <mem_init>
  memp_init();
    1f48:	f000 fbd6 	bl	26f8 <memp_init>
  pbuf_init();
  netif_init();
    1f4c:	f000 fd6a 	bl	2a24 <netif_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
    1f50:	f001 faca 	bl	34e8 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
    1f54:	bd80      	pop	{r7, pc}
    1f56:	bf00      	nop

00001f58 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
    1f58:	b480      	push	{r7}
    1f5a:	b085      	sub	sp, #20
    1f5c:	af00      	add	r7, sp, #0
    1f5e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
    1f60:	f240 63e0 	movw	r3, #1760	; 0x6e0
    1f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f68:	681b      	ldr	r3, [r3, #0]
    1f6a:	461a      	mov	r2, r3
    1f6c:	687b      	ldr	r3, [r7, #4]
    1f6e:	881b      	ldrh	r3, [r3, #0]
    1f70:	4413      	add	r3, r2
    1f72:	60bb      	str	r3, [r7, #8]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    1f74:	687a      	ldr	r2, [r7, #4]
    1f76:	68bb      	ldr	r3, [r7, #8]
    1f78:	429a      	cmp	r2, r3
    1f7a:	d032      	beq.n	1fe2 <plug_holes+0x8a>
    1f7c:	68bb      	ldr	r3, [r7, #8]
    1f7e:	791b      	ldrb	r3, [r3, #4]
    1f80:	2b00      	cmp	r3, #0
    1f82:	d12e      	bne.n	1fe2 <plug_holes+0x8a>
    1f84:	68ba      	ldr	r2, [r7, #8]
    1f86:	f240 63e4 	movw	r3, #1764	; 0x6e4
    1f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f8e:	681b      	ldr	r3, [r3, #0]
    1f90:	429a      	cmp	r2, r3
    1f92:	d026      	beq.n	1fe2 <plug_holes+0x8a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    1f94:	f240 63e8 	movw	r3, #1768	; 0x6e8
    1f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f9c:	681a      	ldr	r2, [r3, #0]
    1f9e:	68bb      	ldr	r3, [r7, #8]
    1fa0:	429a      	cmp	r2, r3
    1fa2:	d105      	bne.n	1fb0 <plug_holes+0x58>
      lfree = mem;
    1fa4:	f240 63e8 	movw	r3, #1768	; 0x6e8
    1fa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fac:	687a      	ldr	r2, [r7, #4]
    1fae:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
    1fb0:	68bb      	ldr	r3, [r7, #8]
    1fb2:	881a      	ldrh	r2, [r3, #0]
    1fb4:	687b      	ldr	r3, [r7, #4]
    1fb6:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    1fb8:	f240 63e0 	movw	r3, #1760	; 0x6e0
    1fbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fc0:	681b      	ldr	r3, [r3, #0]
    1fc2:	461a      	mov	r2, r3
    1fc4:	68bb      	ldr	r3, [r7, #8]
    1fc6:	881b      	ldrh	r3, [r3, #0]
    1fc8:	441a      	add	r2, r3
    1fca:	687b      	ldr	r3, [r7, #4]
    1fcc:	b299      	uxth	r1, r3
    1fce:	f240 63e0 	movw	r3, #1760	; 0x6e0
    1fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fd6:	681b      	ldr	r3, [r3, #0]
    1fd8:	b29b      	uxth	r3, r3
    1fda:	ebc3 0301 	rsb	r3, r3, r1
    1fde:	b29b      	uxth	r3, r3
    1fe0:	8053      	strh	r3, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
    1fe2:	f240 63e0 	movw	r3, #1760	; 0x6e0
    1fe6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fea:	681b      	ldr	r3, [r3, #0]
    1fec:	461a      	mov	r2, r3
    1fee:	687b      	ldr	r3, [r7, #4]
    1ff0:	885b      	ldrh	r3, [r3, #2]
    1ff2:	4413      	add	r3, r2
    1ff4:	60fb      	str	r3, [r7, #12]
  if (pmem != mem && pmem->used == 0) {
    1ff6:	68fa      	ldr	r2, [r7, #12]
    1ff8:	687b      	ldr	r3, [r7, #4]
    1ffa:	429a      	cmp	r2, r3
    1ffc:	d02a      	beq.n	2054 <MAIN_STACK_SIZE+0x54>
    1ffe:	68fb      	ldr	r3, [r7, #12]
    2000:	791b      	ldrb	r3, [r3, #4]
    2002:	2b00      	cmp	r3, #0
    2004:	d126      	bne.n	2054 <MAIN_STACK_SIZE+0x54>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    2006:	f240 63e8 	movw	r3, #1768	; 0x6e8
    200a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    200e:	681a      	ldr	r2, [r3, #0]
    2010:	687b      	ldr	r3, [r7, #4]
    2012:	429a      	cmp	r2, r3
    2014:	d105      	bne.n	2022 <MAIN_STACK_SIZE+0x22>
      lfree = pmem;
    2016:	f240 63e8 	movw	r3, #1768	; 0x6e8
    201a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    201e:	68fa      	ldr	r2, [r7, #12]
    2020:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
    2022:	687b      	ldr	r3, [r7, #4]
    2024:	881a      	ldrh	r2, [r3, #0]
    2026:	68fb      	ldr	r3, [r7, #12]
    2028:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    202a:	f240 63e0 	movw	r3, #1760	; 0x6e0
    202e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2032:	681b      	ldr	r3, [r3, #0]
    2034:	461a      	mov	r2, r3
    2036:	687b      	ldr	r3, [r7, #4]
    2038:	881b      	ldrh	r3, [r3, #0]
    203a:	441a      	add	r2, r3
    203c:	68fb      	ldr	r3, [r7, #12]
    203e:	b299      	uxth	r1, r3
    2040:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2044:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2048:	681b      	ldr	r3, [r3, #0]
    204a:	b29b      	uxth	r3, r3
    204c:	ebc3 0301 	rsb	r3, r3, r1
    2050:	b29b      	uxth	r3, r3
    2052:	8053      	strh	r3, [r2, #2]
  }
}
    2054:	f107 0714 	add.w	r7, r7, #20
    2058:	46bd      	mov	sp, r7
    205a:	bc80      	pop	{r7}
    205c:	4770      	bx	lr
    205e:	bf00      	nop

00002060 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
    2060:	b480      	push	{r7}
    2062:	b083      	sub	sp, #12
    2064:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    2066:	f243 1394 	movw	r3, #12692	; 0x3194
    206a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    206e:	f103 0303 	add.w	r3, r3, #3
    2072:	f023 0303 	bic.w	r3, r3, #3
    2076:	461a      	mov	r2, r3
    2078:	f240 63e0 	movw	r3, #1760	; 0x6e0
    207c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2080:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
    2082:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2086:	f2c2 0300 	movt	r3, #8192	; 0x2000
    208a:	681b      	ldr	r3, [r3, #0]
    208c:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
    208e:	687b      	ldr	r3, [r7, #4]
    2090:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
    2094:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
    2096:	687b      	ldr	r3, [r7, #4]
    2098:	f04f 0200 	mov.w	r2, #0
    209c:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
    209e:	687b      	ldr	r3, [r7, #4]
    20a0:	f04f 0200 	mov.w	r2, #0
    20a4:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    20a6:	f240 63e0 	movw	r3, #1760	; 0x6e0
    20aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20ae:	681b      	ldr	r3, [r3, #0]
    20b0:	f503 527a 	add.w	r2, r3, #16000	; 0x3e80
    20b4:	f240 63e4 	movw	r3, #1764	; 0x6e4
    20b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20bc:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
    20be:	f240 63e4 	movw	r3, #1764	; 0x6e4
    20c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20c6:	681b      	ldr	r3, [r3, #0]
    20c8:	f04f 0201 	mov.w	r2, #1
    20cc:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
    20ce:	f240 63e4 	movw	r3, #1764	; 0x6e4
    20d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20d6:	681b      	ldr	r3, [r3, #0]
    20d8:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
    20dc:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
    20de:	f240 63e4 	movw	r3, #1764	; 0x6e4
    20e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20e6:	681b      	ldr	r3, [r3, #0]
    20e8:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
    20ec:	805a      	strh	r2, [r3, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
    20ee:	f240 63e0 	movw	r3, #1760	; 0x6e0
    20f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20f6:	681b      	ldr	r3, [r3, #0]
    20f8:	461a      	mov	r2, r3
    20fa:	f240 63e8 	movw	r3, #1768	; 0x6e8
    20fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2102:	601a      	str	r2, [r3, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
    2104:	f247 0330 	movw	r3, #28720	; 0x7030
    2108:	f2c2 0300 	movt	r3, #8192	; 0x2000
    210c:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
    2110:	f8a3 2090 	strh.w	r2, [r3, #144]	; 0x90

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
    2114:	f107 070c 	add.w	r7, r7, #12
    2118:	46bd      	mov	sp, r7
    211a:	bc80      	pop	{r7}
    211c:	4770      	bx	lr
    211e:	bf00      	nop

00002120 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    2120:	b580      	push	{r7, lr}
    2122:	b084      	sub	sp, #16
    2124:	af00      	add	r7, sp, #0
    2126:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    2128:	687b      	ldr	r3, [r7, #4]
    212a:	2b00      	cmp	r3, #0
    212c:	d05e      	beq.n	21ec <mem_free+0xcc>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    212e:	687a      	ldr	r2, [r7, #4]
    2130:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2134:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2138:	681b      	ldr	r3, [r3, #0]
    213a:	429a      	cmp	r2, r3
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    213c:	687a      	ldr	r2, [r7, #4]
    213e:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2142:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2146:	681b      	ldr	r3, [r3, #0]
    2148:	429a      	cmp	r2, r3
    214a:	d307      	bcc.n	215c <mem_free+0x3c>
    214c:	687a      	ldr	r2, [r7, #4]
    214e:	f240 63e4 	movw	r3, #1764	; 0x6e4
    2152:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2156:	681b      	ldr	r3, [r3, #0]
    2158:	429a      	cmp	r2, r3
    215a:	d30f      	bcc.n	217c <mem_free+0x5c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    215c:	f247 0330 	movw	r3, #28720	; 0x7030
    2160:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2164:	f8b3 3098 	ldrh.w	r3, [r3, #152]	; 0x98
    2168:	f103 0301 	add.w	r3, r3, #1
    216c:	b29a      	uxth	r2, r3
    216e:	f247 0330 	movw	r3, #28720	; 0x7030
    2172:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2176:	f8a3 2098 	strh.w	r2, [r3, #152]	; 0x98
    SYS_ARCH_UNPROTECT(lev);
    return;
    217a:	e038      	b.n	21ee <mem_free+0xce>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    217c:	687b      	ldr	r3, [r7, #4]
    217e:	f1a3 0308 	sub.w	r3, r3, #8
    2182:	60fb      	str	r3, [r7, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
    2184:	68fb      	ldr	r3, [r7, #12]
    2186:	f04f 0200 	mov.w	r2, #0
    218a:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
    218c:	f240 63e8 	movw	r3, #1768	; 0x6e8
    2190:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2194:	681b      	ldr	r3, [r3, #0]
    2196:	68fa      	ldr	r2, [r7, #12]
    2198:	429a      	cmp	r2, r3
    219a:	d205      	bcs.n	21a8 <mem_free+0x88>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    219c:	f240 63e8 	movw	r3, #1768	; 0x6e8
    21a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21a4:	68fa      	ldr	r2, [r7, #12]
    21a6:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
    21a8:	f247 0330 	movw	r3, #28720	; 0x7030
    21ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21b0:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    21b4:	68fb      	ldr	r3, [r7, #12]
    21b6:	b299      	uxth	r1, r3
    21b8:	f240 63e0 	movw	r3, #1760	; 0x6e0
    21bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21c0:	681b      	ldr	r3, [r3, #0]
    21c2:	b29b      	uxth	r3, r3
    21c4:	ebc3 0301 	rsb	r3, r3, r1
    21c8:	b299      	uxth	r1, r3
    21ca:	68fb      	ldr	r3, [r7, #12]
    21cc:	881b      	ldrh	r3, [r3, #0]
    21ce:	ebc3 0301 	rsb	r3, r3, r1
    21d2:	b29b      	uxth	r3, r3
    21d4:	4413      	add	r3, r2
    21d6:	b29a      	uxth	r2, r3
    21d8:	f247 0330 	movw	r3, #28720	; 0x7030
    21dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21e0:	f8a3 2092 	strh.w	r2, [r3, #146]	; 0x92

  /* finally, see if prev or next are free also */
  plug_holes(mem);
    21e4:	68f8      	ldr	r0, [r7, #12]
    21e6:	f7ff feb7 	bl	1f58 <plug_holes>
    21ea:	e000      	b.n	21ee <mem_free+0xce>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
    21ec:	bf00      	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    21ee:	f107 0710 	add.w	r7, r7, #16
    21f2:	46bd      	mov	sp, r7
    21f4:	bd80      	pop	{r7, pc}
    21f6:	bf00      	nop

000021f8 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
    21f8:	b480      	push	{r7}
    21fa:	b089      	sub	sp, #36	; 0x24
    21fc:	af00      	add	r7, sp, #0
    21fe:	6078      	str	r0, [r7, #4]
    2200:	460b      	mov	r3, r1
    2202:	807b      	strh	r3, [r7, #2]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    2204:	887b      	ldrh	r3, [r7, #2]
    2206:	f103 0303 	add.w	r3, r3, #3
    220a:	b29b      	uxth	r3, r3
    220c:	f023 0303 	bic.w	r3, r3, #3
    2210:	807b      	strh	r3, [r7, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
    2212:	887b      	ldrh	r3, [r7, #2]
    2214:	2b0b      	cmp	r3, #11
    2216:	d802      	bhi.n	221e <mem_trim+0x26>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    2218:	f04f 030c 	mov.w	r3, #12
    221c:	807b      	strh	r3, [r7, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    221e:	887b      	ldrh	r3, [r7, #2]
    2220:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
    2224:	d902      	bls.n	222c <mem_trim+0x34>
    return NULL;
    2226:	f04f 0300 	mov.w	r3, #0
    222a:	e109      	b.n	2440 <mem_trim+0x248>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    222c:	687a      	ldr	r2, [r7, #4]
    222e:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2232:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2236:	681b      	ldr	r3, [r3, #0]
    2238:	429a      	cmp	r2, r3
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    223a:	687a      	ldr	r2, [r7, #4]
    223c:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2240:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2244:	681b      	ldr	r3, [r3, #0]
    2246:	429a      	cmp	r2, r3
    2248:	d307      	bcc.n	225a <mem_trim+0x62>
    224a:	687a      	ldr	r2, [r7, #4]
    224c:	f240 63e4 	movw	r3, #1764	; 0x6e4
    2250:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2254:	681b      	ldr	r3, [r3, #0]
    2256:	429a      	cmp	r2, r3
    2258:	d310      	bcc.n	227c <mem_trim+0x84>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    225a:	f247 0330 	movw	r3, #28720	; 0x7030
    225e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2262:	f8b3 3098 	ldrh.w	r3, [r3, #152]	; 0x98
    2266:	f103 0301 	add.w	r3, r3, #1
    226a:	b29a      	uxth	r2, r3
    226c:	f247 0330 	movw	r3, #28720	; 0x7030
    2270:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2274:	f8a3 2098 	strh.w	r2, [r3, #152]	; 0x98
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
    2278:	687b      	ldr	r3, [r7, #4]
    227a:	e0e1      	b.n	2440 <mem_trim+0x248>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    227c:	687b      	ldr	r3, [r7, #4]
    227e:	f1a3 0308 	sub.w	r3, r3, #8
    2282:	617b      	str	r3, [r7, #20]
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
    2284:	697b      	ldr	r3, [r7, #20]
    2286:	b29a      	uxth	r2, r3
    2288:	f240 63e0 	movw	r3, #1760	; 0x6e0
    228c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2290:	681b      	ldr	r3, [r3, #0]
    2292:	b29b      	uxth	r3, r3
    2294:	ebc3 0302 	rsb	r3, r3, r2
    2298:	823b      	strh	r3, [r7, #16]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    229a:	697b      	ldr	r3, [r7, #20]
    229c:	881a      	ldrh	r2, [r3, #0]
    229e:	8a3b      	ldrh	r3, [r7, #16]
    22a0:	ebc3 0302 	rsb	r3, r3, r2
    22a4:	b29b      	uxth	r3, r3
    22a6:	f1a3 0308 	sub.w	r3, r3, #8
    22aa:	81fb      	strh	r3, [r7, #14]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
    22ac:	887a      	ldrh	r2, [r7, #2]
    22ae:	89fb      	ldrh	r3, [r7, #14]
    22b0:	429a      	cmp	r2, r3
    22b2:	d902      	bls.n	22ba <mem_trim+0xc2>
    /* not supported */
    return NULL;
    22b4:	f04f 0300 	mov.w	r3, #0
    22b8:	e0c2      	b.n	2440 <mem_trim+0x248>
  }
  if (newsize == size) {
    22ba:	887a      	ldrh	r2, [r7, #2]
    22bc:	89fb      	ldrh	r3, [r7, #14]
    22be:	429a      	cmp	r2, r3
    22c0:	d101      	bne.n	22c6 <mem_trim+0xce>
    /* No change in size, simply return */
    return rmem;
    22c2:	687b      	ldr	r3, [r7, #4]
    22c4:	e0bc      	b.n	2440 <mem_trim+0x248>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
    22c6:	f240 63e0 	movw	r3, #1760	; 0x6e0
    22ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22ce:	681b      	ldr	r3, [r3, #0]
    22d0:	461a      	mov	r2, r3
    22d2:	697b      	ldr	r3, [r7, #20]
    22d4:	881b      	ldrh	r3, [r3, #0]
    22d6:	4413      	add	r3, r2
    22d8:	61bb      	str	r3, [r7, #24]
  if(mem2->used == 0) {
    22da:	69bb      	ldr	r3, [r7, #24]
    22dc:	791b      	ldrb	r3, [r3, #4]
    22de:	2b00      	cmp	r3, #0
    22e0:	d158      	bne.n	2394 <mem_trim+0x19c>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    22e2:	69bb      	ldr	r3, [r7, #24]
    22e4:	881b      	ldrh	r3, [r3, #0]
    22e6:	83fb      	strh	r3, [r7, #30]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    22e8:	8a3a      	ldrh	r2, [r7, #16]
    22ea:	887b      	ldrh	r3, [r7, #2]
    22ec:	4413      	add	r3, r2
    22ee:	b29b      	uxth	r3, r3
    22f0:	f103 0308 	add.w	r3, r3, #8
    22f4:	827b      	strh	r3, [r7, #18]
    if (lfree == mem2) {
    22f6:	f240 63e8 	movw	r3, #1768	; 0x6e8
    22fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22fe:	681a      	ldr	r2, [r3, #0]
    2300:	69bb      	ldr	r3, [r7, #24]
    2302:	429a      	cmp	r2, r3
    2304:	d10c      	bne.n	2320 <mem_trim+0x128>
      lfree = (struct mem *)(void *)&ram[ptr2];
    2306:	f240 63e0 	movw	r3, #1760	; 0x6e0
    230a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    230e:	681b      	ldr	r3, [r3, #0]
    2310:	461a      	mov	r2, r3
    2312:	8a7b      	ldrh	r3, [r7, #18]
    2314:	441a      	add	r2, r3
    2316:	f240 63e8 	movw	r3, #1768	; 0x6e8
    231a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    231e:	601a      	str	r2, [r3, #0]
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    2320:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2324:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2328:	681b      	ldr	r3, [r3, #0]
    232a:	461a      	mov	r2, r3
    232c:	8a7b      	ldrh	r3, [r7, #18]
    232e:	4413      	add	r3, r2
    2330:	61bb      	str	r3, [r7, #24]
    mem2->used = 0;
    2332:	69bb      	ldr	r3, [r7, #24]
    2334:	f04f 0200 	mov.w	r2, #0
    2338:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
    233a:	69bb      	ldr	r3, [r7, #24]
    233c:	8bfa      	ldrh	r2, [r7, #30]
    233e:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
    2340:	69bb      	ldr	r3, [r7, #24]
    2342:	8a3a      	ldrh	r2, [r7, #16]
    2344:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
    2346:	697b      	ldr	r3, [r7, #20]
    2348:	8a7a      	ldrh	r2, [r7, #18]
    234a:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
    234c:	69bb      	ldr	r3, [r7, #24]
    234e:	881b      	ldrh	r3, [r3, #0]
    2350:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
    2354:	d00a      	beq.n	236c <mem_trim+0x174>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    2356:	f240 63e0 	movw	r3, #1760	; 0x6e0
    235a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    235e:	681b      	ldr	r3, [r3, #0]
    2360:	461a      	mov	r2, r3
    2362:	69bb      	ldr	r3, [r7, #24]
    2364:	881b      	ldrh	r3, [r3, #0]
    2366:	4413      	add	r3, r2
    2368:	8a7a      	ldrh	r2, [r7, #18]
    236a:	805a      	strh	r2, [r3, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    236c:	f247 0330 	movw	r3, #28720	; 0x7030
    2370:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2374:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    2378:	8879      	ldrh	r1, [r7, #2]
    237a:	89fb      	ldrh	r3, [r7, #14]
    237c:	ebc3 0301 	rsb	r3, r3, r1
    2380:	b29b      	uxth	r3, r3
    2382:	4413      	add	r3, r2
    2384:	b29a      	uxth	r2, r3
    2386:	f247 0330 	movw	r3, #28720	; 0x7030
    238a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    238e:	f8a3 2092 	strh.w	r2, [r3, #146]	; 0x92
    2392:	e054      	b.n	243e <mem_trim+0x246>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    2394:	887b      	ldrh	r3, [r7, #2]
    2396:	f103 0214 	add.w	r2, r3, #20
    239a:	89fb      	ldrh	r3, [r7, #14]
    239c:	429a      	cmp	r2, r3
    239e:	d84e      	bhi.n	243e <mem_trim+0x246>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    23a0:	8a3a      	ldrh	r2, [r7, #16]
    23a2:	887b      	ldrh	r3, [r7, #2]
    23a4:	4413      	add	r3, r2
    23a6:	b29b      	uxth	r3, r3
    23a8:	f103 0308 	add.w	r3, r3, #8
    23ac:	827b      	strh	r3, [r7, #18]
    mem2 = (struct mem *)(void *)&ram[ptr2];
    23ae:	f240 63e0 	movw	r3, #1760	; 0x6e0
    23b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23b6:	681b      	ldr	r3, [r3, #0]
    23b8:	461a      	mov	r2, r3
    23ba:	8a7b      	ldrh	r3, [r7, #18]
    23bc:	4413      	add	r3, r2
    23be:	61bb      	str	r3, [r7, #24]
    if (mem2 < lfree) {
    23c0:	f240 63e8 	movw	r3, #1768	; 0x6e8
    23c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23c8:	681b      	ldr	r3, [r3, #0]
    23ca:	69ba      	ldr	r2, [r7, #24]
    23cc:	429a      	cmp	r2, r3
    23ce:	d205      	bcs.n	23dc <mem_trim+0x1e4>
      lfree = mem2;
    23d0:	f240 63e8 	movw	r3, #1768	; 0x6e8
    23d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23d8:	69ba      	ldr	r2, [r7, #24]
    23da:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
    23dc:	69bb      	ldr	r3, [r7, #24]
    23de:	f04f 0200 	mov.w	r2, #0
    23e2:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
    23e4:	697b      	ldr	r3, [r7, #20]
    23e6:	881a      	ldrh	r2, [r3, #0]
    23e8:	69bb      	ldr	r3, [r7, #24]
    23ea:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
    23ec:	69bb      	ldr	r3, [r7, #24]
    23ee:	8a3a      	ldrh	r2, [r7, #16]
    23f0:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
    23f2:	697b      	ldr	r3, [r7, #20]
    23f4:	8a7a      	ldrh	r2, [r7, #18]
    23f6:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
    23f8:	69bb      	ldr	r3, [r7, #24]
    23fa:	881b      	ldrh	r3, [r3, #0]
    23fc:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
    2400:	d00a      	beq.n	2418 <mem_trim+0x220>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    2402:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2406:	f2c2 0300 	movt	r3, #8192	; 0x2000
    240a:	681b      	ldr	r3, [r3, #0]
    240c:	461a      	mov	r2, r3
    240e:	69bb      	ldr	r3, [r7, #24]
    2410:	881b      	ldrh	r3, [r3, #0]
    2412:	4413      	add	r3, r2
    2414:	8a7a      	ldrh	r2, [r7, #18]
    2416:	805a      	strh	r2, [r3, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    2418:	f247 0330 	movw	r3, #28720	; 0x7030
    241c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2420:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    2424:	8879      	ldrh	r1, [r7, #2]
    2426:	89fb      	ldrh	r3, [r7, #14]
    2428:	ebc3 0301 	rsb	r3, r3, r1
    242c:	b29b      	uxth	r3, r3
    242e:	4413      	add	r3, r2
    2430:	b29a      	uxth	r2, r3
    2432:	f247 0330 	movw	r3, #28720	; 0x7030
    2436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    243a:	f8a3 2092 	strh.w	r2, [r3, #146]	; 0x92
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
    243e:	687b      	ldr	r3, [r7, #4]
}
    2440:	4618      	mov	r0, r3
    2442:	f107 0724 	add.w	r7, r7, #36	; 0x24
    2446:	46bd      	mov	sp, r7
    2448:	bc80      	pop	{r7}
    244a:	4770      	bx	lr

0000244c <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    244c:	b480      	push	{r7}
    244e:	b087      	sub	sp, #28
    2450:	af00      	add	r7, sp, #0
    2452:	4603      	mov	r3, r0
    2454:	80fb      	strh	r3, [r7, #6]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    2456:	88fb      	ldrh	r3, [r7, #6]
    2458:	2b00      	cmp	r3, #0
    245a:	d102      	bne.n	2462 <mem_malloc+0x16>
    return NULL;
    245c:	f04f 0300 	mov.w	r3, #0
    2460:	e144      	b.n	26ec <mem_malloc+0x2a0>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    2462:	88fb      	ldrh	r3, [r7, #6]
    2464:	f103 0303 	add.w	r3, r3, #3
    2468:	b29b      	uxth	r3, r3
    246a:	f023 0303 	bic.w	r3, r3, #3
    246e:	80fb      	strh	r3, [r7, #6]

  if(size < MIN_SIZE_ALIGNED) {
    2470:	88fb      	ldrh	r3, [r7, #6]
    2472:	2b0b      	cmp	r3, #11
    2474:	d802      	bhi.n	247c <mem_malloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    2476:	f04f 030c 	mov.w	r3, #12
    247a:	80fb      	strh	r3, [r7, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
    247c:	88fb      	ldrh	r3, [r7, #6]
    247e:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
    2482:	d902      	bls.n	248a <mem_malloc+0x3e>
    return NULL;
    2484:	f04f 0300 	mov.w	r3, #0
    2488:	e130      	b.n	26ec <mem_malloc+0x2a0>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    248a:	f240 63e8 	movw	r3, #1768	; 0x6e8
    248e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2492:	681b      	ldr	r3, [r3, #0]
    2494:	b29a      	uxth	r2, r3
    2496:	f240 63e0 	movw	r3, #1760	; 0x6e0
    249a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    249e:	681b      	ldr	r3, [r3, #0]
    24a0:	b29b      	uxth	r3, r3
    24a2:	ebc3 0302 	rsb	r3, r3, r2
    24a6:	81bb      	strh	r3, [r7, #12]
    24a8:	e108      	b.n	26bc <mem_malloc+0x270>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
    24aa:	f240 63e0 	movw	r3, #1760	; 0x6e0
    24ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    24b2:	681b      	ldr	r3, [r3, #0]
    24b4:	461a      	mov	r2, r3
    24b6:	89bb      	ldrh	r3, [r7, #12]
    24b8:	4413      	add	r3, r2
    24ba:	613b      	str	r3, [r7, #16]
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    24bc:	693b      	ldr	r3, [r7, #16]
    24be:	791b      	ldrb	r3, [r3, #4]
    24c0:	2b00      	cmp	r3, #0
    24c2:	f040 80f1 	bne.w	26a8 <mem_malloc+0x25c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    24c6:	693b      	ldr	r3, [r7, #16]
    24c8:	881b      	ldrh	r3, [r3, #0]
    24ca:	461a      	mov	r2, r3
    24cc:	89bb      	ldrh	r3, [r7, #12]
    24ce:	ebc3 0302 	rsb	r3, r3, r2
    24d2:	f1a3 0208 	sub.w	r2, r3, #8
    24d6:	88fb      	ldrh	r3, [r7, #6]
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    24d8:	429a      	cmp	r2, r3
    24da:	f0c0 80e5 	bcc.w	26a8 <mem_malloc+0x25c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    24de:	693b      	ldr	r3, [r7, #16]
    24e0:	881b      	ldrh	r3, [r3, #0]
    24e2:	461a      	mov	r2, r3
    24e4:	89bb      	ldrh	r3, [r7, #12]
    24e6:	ebc3 0302 	rsb	r3, r3, r2
    24ea:	f1a3 0208 	sub.w	r2, r3, #8
    24ee:	88fb      	ldrh	r3, [r7, #6]
    24f0:	f103 0314 	add.w	r3, r3, #20
    24f4:	429a      	cmp	r2, r3
    24f6:	d35e      	bcc.n	25b6 <mem_malloc+0x16a>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    24f8:	89ba      	ldrh	r2, [r7, #12]
    24fa:	88fb      	ldrh	r3, [r7, #6]
    24fc:	4413      	add	r3, r2
    24fe:	b29b      	uxth	r3, r3
    2500:	f103 0308 	add.w	r3, r3, #8
    2504:	81fb      	strh	r3, [r7, #14]
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
    2506:	f240 63e0 	movw	r3, #1760	; 0x6e0
    250a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    250e:	681b      	ldr	r3, [r3, #0]
    2510:	461a      	mov	r2, r3
    2512:	89fb      	ldrh	r3, [r7, #14]
    2514:	4413      	add	r3, r2
    2516:	617b      	str	r3, [r7, #20]
          mem2->used = 0;
    2518:	697b      	ldr	r3, [r7, #20]
    251a:	f04f 0200 	mov.w	r2, #0
    251e:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
    2520:	693b      	ldr	r3, [r7, #16]
    2522:	881a      	ldrh	r2, [r3, #0]
    2524:	697b      	ldr	r3, [r7, #20]
    2526:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
    2528:	697b      	ldr	r3, [r7, #20]
    252a:	89ba      	ldrh	r2, [r7, #12]
    252c:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    252e:	693b      	ldr	r3, [r7, #16]
    2530:	89fa      	ldrh	r2, [r7, #14]
    2532:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
    2534:	693b      	ldr	r3, [r7, #16]
    2536:	f04f 0201 	mov.w	r2, #1
    253a:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
    253c:	697b      	ldr	r3, [r7, #20]
    253e:	881b      	ldrh	r3, [r3, #0]
    2540:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
    2544:	d00a      	beq.n	255c <mem_malloc+0x110>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    2546:	f240 63e0 	movw	r3, #1760	; 0x6e0
    254a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    254e:	681b      	ldr	r3, [r3, #0]
    2550:	461a      	mov	r2, r3
    2552:	697b      	ldr	r3, [r7, #20]
    2554:	881b      	ldrh	r3, [r3, #0]
    2556:	4413      	add	r3, r2
    2558:	89fa      	ldrh	r2, [r7, #14]
    255a:	805a      	strh	r2, [r3, #2]
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    255c:	f247 0330 	movw	r3, #28720	; 0x7030
    2560:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2564:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    2568:	88fb      	ldrh	r3, [r7, #6]
    256a:	4413      	add	r3, r2
    256c:	b29b      	uxth	r3, r3
    256e:	f103 0308 	add.w	r3, r3, #8
    2572:	b29a      	uxth	r2, r3
    2574:	f247 0330 	movw	r3, #28720	; 0x7030
    2578:	f2c2 0300 	movt	r3, #8192	; 0x2000
    257c:	f8a3 2092 	strh.w	r2, [r3, #146]	; 0x92
    2580:	f247 0330 	movw	r3, #28720	; 0x7030
    2584:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2588:	f8b3 2094 	ldrh.w	r2, [r3, #148]	; 0x94
    258c:	f247 0330 	movw	r3, #28720	; 0x7030
    2590:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2594:	f8b3 3092 	ldrh.w	r3, [r3, #146]	; 0x92
    2598:	429a      	cmp	r2, r3
    259a:	d247      	bcs.n	262c <mem_malloc+0x1e0>
    259c:	f247 0330 	movw	r3, #28720	; 0x7030
    25a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25a4:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    25a8:	f247 0330 	movw	r3, #28720	; 0x7030
    25ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25b0:	f8a3 2094 	strh.w	r2, [r3, #148]	; 0x94
    25b4:	e03a      	b.n	262c <mem_malloc+0x1e0>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    25b6:	693b      	ldr	r3, [r7, #16]
    25b8:	f04f 0201 	mov.w	r2, #1
    25bc:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
    25be:	f247 0330 	movw	r3, #28720	; 0x7030
    25c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25c6:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    25ca:	693b      	ldr	r3, [r7, #16]
    25cc:	8819      	ldrh	r1, [r3, #0]
    25ce:	f240 63e0 	movw	r3, #1760	; 0x6e0
    25d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25d6:	681b      	ldr	r3, [r3, #0]
    25d8:	b298      	uxth	r0, r3
    25da:	693b      	ldr	r3, [r7, #16]
    25dc:	b29b      	uxth	r3, r3
    25de:	ebc3 0300 	rsb	r3, r3, r0
    25e2:	b29b      	uxth	r3, r3
    25e4:	440b      	add	r3, r1
    25e6:	b29b      	uxth	r3, r3
    25e8:	4413      	add	r3, r2
    25ea:	b29a      	uxth	r2, r3
    25ec:	f247 0330 	movw	r3, #28720	; 0x7030
    25f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25f4:	f8a3 2092 	strh.w	r2, [r3, #146]	; 0x92
    25f8:	f247 0330 	movw	r3, #28720	; 0x7030
    25fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2600:	f8b3 2094 	ldrh.w	r2, [r3, #148]	; 0x94
    2604:	f247 0330 	movw	r3, #28720	; 0x7030
    2608:	f2c2 0300 	movt	r3, #8192	; 0x2000
    260c:	f8b3 3092 	ldrh.w	r3, [r3, #146]	; 0x92
    2610:	429a      	cmp	r2, r3
    2612:	d20b      	bcs.n	262c <mem_malloc+0x1e0>
    2614:	f247 0330 	movw	r3, #28720	; 0x7030
    2618:	f2c2 0300 	movt	r3, #8192	; 0x2000
    261c:	f8b3 2092 	ldrh.w	r2, [r3, #146]	; 0x92
    2620:	f247 0330 	movw	r3, #28720	; 0x7030
    2624:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2628:	f8a3 2094 	strh.w	r2, [r3, #148]	; 0x94
        }

        if (mem == lfree) {
    262c:	f240 63e8 	movw	r3, #1768	; 0x6e8
    2630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2634:	681b      	ldr	r3, [r3, #0]
    2636:	693a      	ldr	r2, [r7, #16]
    2638:	429a      	cmp	r2, r3
    263a:	d131      	bne.n	26a0 <mem_malloc+0x254>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    263c:	e011      	b.n	2662 <mem_malloc+0x216>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)(void *)&ram[lfree->next];
    263e:	f240 63e0 	movw	r3, #1760	; 0x6e0
    2642:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2646:	681b      	ldr	r3, [r3, #0]
    2648:	461a      	mov	r2, r3
    264a:	f240 63e8 	movw	r3, #1768	; 0x6e8
    264e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2652:	681b      	ldr	r3, [r3, #0]
    2654:	881b      	ldrh	r3, [r3, #0]
    2656:	441a      	add	r2, r3
    2658:	f240 63e8 	movw	r3, #1768	; 0x6e8
    265c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2660:	601a      	str	r2, [r3, #0]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
    2662:	f240 63e8 	movw	r3, #1768	; 0x6e8
    2666:	f2c2 0300 	movt	r3, #8192	; 0x2000
    266a:	681b      	ldr	r3, [r3, #0]
    266c:	791b      	ldrb	r3, [r3, #4]
    266e:	2b00      	cmp	r3, #0
    2670:	d00b      	beq.n	268a <mem_malloc+0x23e>
    2672:	f240 63e8 	movw	r3, #1768	; 0x6e8
    2676:	f2c2 0300 	movt	r3, #8192	; 0x2000
    267a:	681a      	ldr	r2, [r3, #0]
    267c:	f240 63e4 	movw	r3, #1764	; 0x6e4
    2680:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2684:	681b      	ldr	r3, [r3, #0]
    2686:	429a      	cmp	r2, r3
    2688:	d1d9      	bne.n	263e <mem_malloc+0x1f2>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)(void *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
    268a:	f240 63e8 	movw	r3, #1768	; 0x6e8
    268e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2692:	681a      	ldr	r2, [r3, #0]
    2694:	f240 63e4 	movw	r3, #1764	; 0x6e4
    2698:	f2c2 0300 	movt	r3, #8192	; 0x2000
    269c:	681b      	ldr	r3, [r3, #0]
    269e:	429a      	cmp	r2, r3
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    26a0:	693b      	ldr	r3, [r7, #16]
    26a2:	f103 0308 	add.w	r3, r3, #8
    26a6:	e021      	b.n	26ec <mem_malloc+0x2a0>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    26a8:	f240 63e0 	movw	r3, #1760	; 0x6e0
    26ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26b0:	681b      	ldr	r3, [r3, #0]
    26b2:	461a      	mov	r2, r3
    26b4:	89bb      	ldrh	r3, [r7, #12]
    26b6:	4413      	add	r3, r2
    26b8:	881b      	ldrh	r3, [r3, #0]
    26ba:	81bb      	strh	r3, [r7, #12]
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    26bc:	89ba      	ldrh	r2, [r7, #12]
    26be:	88fb      	ldrh	r3, [r7, #6]
    26c0:	f5c3 537a 	rsb	r3, r3, #16000	; 0x3e80
    26c4:	429a      	cmp	r2, r3
    26c6:	f6ff aef0 	blt.w	24aa <mem_malloc+0x5e>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    26ca:	f247 0330 	movw	r3, #28720	; 0x7030
    26ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26d2:	f8b3 3096 	ldrh.w	r3, [r3, #150]	; 0x96
    26d6:	f103 0301 	add.w	r3, r3, #1
    26da:	b29a      	uxth	r2, r3
    26dc:	f247 0330 	movw	r3, #28720	; 0x7030
    26e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26e4:	f8a3 2096 	strh.w	r2, [r3, #150]	; 0x96
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
    26e8:	f04f 0300 	mov.w	r3, #0
}
    26ec:	4618      	mov	r0, r3
    26ee:	f107 071c 	add.w	r7, r7, #28
    26f2:	46bd      	mov	sp, r7
    26f4:	bc80      	pop	{r7}
    26f6:	4770      	bx	lr

000026f8 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    26f8:	b480      	push	{r7}
    26fa:	b083      	sub	sp, #12
    26fc:	af00      	add	r7, sp, #0
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    26fe:	f04f 0300 	mov.w	r3, #0
    2702:	80bb      	strh	r3, [r7, #4]
    2704:	e04d      	b.n	27a2 <memp_init+0xaa>
    MEMP_STATS_AVAIL(used, i, 0);
    2706:	88b9      	ldrh	r1, [r7, #4]
    2708:	f247 0230 	movw	r2, #28720	; 0x7030
    270c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2710:	460b      	mov	r3, r1
    2712:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2716:	440b      	add	r3, r1
    2718:	ea4f 0343 	mov.w	r3, r3, lsl #1
    271c:	4413      	add	r3, r2
    271e:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    2722:	f04f 0200 	mov.w	r2, #0
    2726:	801a      	strh	r2, [r3, #0]
    MEMP_STATS_AVAIL(max, i, 0);
    2728:	88b9      	ldrh	r1, [r7, #4]
    272a:	f247 0230 	movw	r2, #28720	; 0x7030
    272e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2732:	460b      	mov	r3, r1
    2734:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2738:	440b      	add	r3, r1
    273a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    273e:	4413      	add	r3, r2
    2740:	f103 039e 	add.w	r3, r3, #158	; 0x9e
    2744:	f04f 0200 	mov.w	r2, #0
    2748:	801a      	strh	r2, [r3, #0]
    MEMP_STATS_AVAIL(err, i, 0);
    274a:	88b9      	ldrh	r1, [r7, #4]
    274c:	f247 0230 	movw	r2, #28720	; 0x7030
    2750:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2754:	460b      	mov	r3, r1
    2756:	ea4f 0383 	mov.w	r3, r3, lsl #2
    275a:	440b      	add	r3, r1
    275c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2760:	4413      	add	r3, r2
    2762:	f103 03a0 	add.w	r3, r3, #160	; 0xa0
    2766:	f04f 0200 	mov.w	r2, #0
    276a:	801a      	strh	r2, [r3, #0]
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    276c:	88b9      	ldrh	r1, [r7, #4]
    276e:	88ba      	ldrh	r2, [r7, #4]
    2770:	f648 63a8 	movw	r3, #36520	; 0x8ea8
    2774:	f2c0 0300 	movt	r3, #0
    2778:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
    277c:	f247 0230 	movw	r2, #28720	; 0x7030
    2780:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2784:	460b      	mov	r3, r1
    2786:	ea4f 0383 	mov.w	r3, r3, lsl #2
    278a:	440b      	add	r3, r1
    278c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2790:	4413      	add	r3, r2
    2792:	f103 039a 	add.w	r3, r3, #154	; 0x9a
    2796:	4602      	mov	r2, r0
    2798:	801a      	strh	r2, [r3, #0]
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    279a:	88bb      	ldrh	r3, [r7, #4]
    279c:	f103 0301 	add.w	r3, r3, #1
    27a0:	80bb      	strh	r3, [r7, #4]
    27a2:	88bb      	ldrh	r3, [r7, #4]
    27a4:	2b06      	cmp	r3, #6
    27a6:	d9ae      	bls.n	2706 <memp_init+0xe>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    27a8:	f240 7308 	movw	r3, #1800	; 0x708
    27ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27b0:	f103 0303 	add.w	r3, r3, #3
    27b4:	f023 0303 	bic.w	r3, r3, #3
    27b8:	603b      	str	r3, [r7, #0]
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    27ba:	f04f 0300 	mov.w	r3, #0
    27be:	80bb      	strh	r3, [r7, #4]
    27c0:	e039      	b.n	2836 <memp_init+0x13e>
    memp_tab[i] = NULL;
    27c2:	88ba      	ldrh	r2, [r7, #4]
    27c4:	f240 63ec 	movw	r3, #1772	; 0x6ec
    27c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27cc:	f04f 0100 	mov.w	r1, #0
    27d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    27d4:	f04f 0300 	mov.w	r3, #0
    27d8:	80fb      	strh	r3, [r7, #6]
    27da:	e01e      	b.n	281a <memp_init+0x122>
      memp->next = memp_tab[i];
    27dc:	88ba      	ldrh	r2, [r7, #4]
    27de:	f240 63ec 	movw	r3, #1772	; 0x6ec
    27e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27e6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    27ea:	683b      	ldr	r3, [r7, #0]
    27ec:	601a      	str	r2, [r3, #0]
      memp_tab[i] = memp;
    27ee:	88ba      	ldrh	r2, [r7, #4]
    27f0:	f240 63ec 	movw	r3, #1772	; 0x6ec
    27f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27f8:	6839      	ldr	r1, [r7, #0]
    27fa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    27fe:	88ba      	ldrh	r2, [r7, #4]
    2800:	f648 6398 	movw	r3, #36504	; 0x8e98
    2804:	f2c0 0300 	movt	r3, #0
    2808:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    280c:	683a      	ldr	r2, [r7, #0]
    280e:	4413      	add	r3, r2
    2810:	603b      	str	r3, [r7, #0]
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    2812:	88fb      	ldrh	r3, [r7, #6]
    2814:	f103 0301 	add.w	r3, r3, #1
    2818:	80fb      	strh	r3, [r7, #6]
    281a:	88ba      	ldrh	r2, [r7, #4]
    281c:	f648 63a8 	movw	r3, #36520	; 0x8ea8
    2820:	f2c0 0300 	movt	r3, #0
    2824:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    2828:	88fa      	ldrh	r2, [r7, #6]
    282a:	429a      	cmp	r2, r3
    282c:	d3d6      	bcc.n	27dc <memp_init+0xe4>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    282e:	88bb      	ldrh	r3, [r7, #4]
    2830:	f103 0301 	add.w	r3, r3, #1
    2834:	80bb      	strh	r3, [r7, #4]
    2836:	88bb      	ldrh	r3, [r7, #4]
    2838:	2b06      	cmp	r3, #6
    283a:	d9c2      	bls.n	27c2 <memp_init+0xca>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    283c:	f107 070c 	add.w	r7, r7, #12
    2840:	46bd      	mov	sp, r7
    2842:	bc80      	pop	{r7}
    2844:	4770      	bx	lr
    2846:	bf00      	nop

00002848 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    2848:	b480      	push	{r7}
    284a:	b085      	sub	sp, #20
    284c:	af00      	add	r7, sp, #0
    284e:	4603      	mov	r3, r0
    2850:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    2852:	79fb      	ldrb	r3, [r7, #7]
    2854:	2b06      	cmp	r3, #6
    2856:	d902      	bls.n	285e <memp_malloc+0x16>
    2858:	f04f 0300 	mov.w	r3, #0
    285c:	e097      	b.n	298e <memp_malloc+0x146>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    285e:	79fa      	ldrb	r2, [r7, #7]
    2860:	f240 63ec 	movw	r3, #1772	; 0x6ec
    2864:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2868:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    286c:	60fb      	str	r3, [r7, #12]
  
  if (memp != NULL) {
    286e:	68fb      	ldr	r3, [r7, #12]
    2870:	2b00      	cmp	r3, #0
    2872:	d06a      	beq.n	294a <memp_malloc+0x102>
    memp_tab[type] = memp->next;
    2874:	79fa      	ldrb	r2, [r7, #7]
    2876:	68fb      	ldr	r3, [r7, #12]
    2878:	6819      	ldr	r1, [r3, #0]
    287a:	f240 63ec 	movw	r3, #1772	; 0x6ec
    287e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2882:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    2886:	79f9      	ldrb	r1, [r7, #7]
    2888:	79f8      	ldrb	r0, [r7, #7]
    288a:	f247 0230 	movw	r2, #28720	; 0x7030
    288e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2892:	4603      	mov	r3, r0
    2894:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2898:	4403      	add	r3, r0
    289a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    289e:	4413      	add	r3, r2
    28a0:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    28a4:	881b      	ldrh	r3, [r3, #0]
    28a6:	f103 0301 	add.w	r3, r3, #1
    28aa:	b298      	uxth	r0, r3
    28ac:	f247 0230 	movw	r2, #28720	; 0x7030
    28b0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    28b4:	460b      	mov	r3, r1
    28b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    28ba:	440b      	add	r3, r1
    28bc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    28c0:	4413      	add	r3, r2
    28c2:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    28c6:	4602      	mov	r2, r0
    28c8:	801a      	strh	r2, [r3, #0]
    28ca:	79f9      	ldrb	r1, [r7, #7]
    28cc:	f247 0230 	movw	r2, #28720	; 0x7030
    28d0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    28d4:	460b      	mov	r3, r1
    28d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    28da:	440b      	add	r3, r1
    28dc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    28e0:	4413      	add	r3, r2
    28e2:	f103 039e 	add.w	r3, r3, #158	; 0x9e
    28e6:	8818      	ldrh	r0, [r3, #0]
    28e8:	79f9      	ldrb	r1, [r7, #7]
    28ea:	f247 0230 	movw	r2, #28720	; 0x7030
    28ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
    28f2:	460b      	mov	r3, r1
    28f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    28f8:	440b      	add	r3, r1
    28fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
    28fe:	4413      	add	r3, r2
    2900:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    2904:	881b      	ldrh	r3, [r3, #0]
    2906:	4298      	cmp	r0, r3
    2908:	d240      	bcs.n	298c <memp_malloc+0x144>
    290a:	79f9      	ldrb	r1, [r7, #7]
    290c:	79f8      	ldrb	r0, [r7, #7]
    290e:	f247 0230 	movw	r2, #28720	; 0x7030
    2912:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2916:	4603      	mov	r3, r0
    2918:	ea4f 0383 	mov.w	r3, r3, lsl #2
    291c:	4403      	add	r3, r0
    291e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2922:	4413      	add	r3, r2
    2924:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    2928:	8818      	ldrh	r0, [r3, #0]
    292a:	f247 0230 	movw	r2, #28720	; 0x7030
    292e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2932:	460b      	mov	r3, r1
    2934:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2938:	440b      	add	r3, r1
    293a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    293e:	4413      	add	r3, r2
    2940:	f103 039e 	add.w	r3, r3, #158	; 0x9e
    2944:	4602      	mov	r2, r0
    2946:	801a      	strh	r2, [r3, #0]
    2948:	e020      	b.n	298c <memp_malloc+0x144>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
    294a:	79fa      	ldrb	r2, [r7, #7]
    294c:	f247 0130 	movw	r1, #28720	; 0x7030
    2950:	f2c2 0100 	movt	r1, #8192	; 0x2000
    2954:	4613      	mov	r3, r2
    2956:	ea4f 0383 	mov.w	r3, r3, lsl #2
    295a:	4413      	add	r3, r2
    295c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2960:	440b      	add	r3, r1
    2962:	f103 03a0 	add.w	r3, r3, #160	; 0xa0
    2966:	881b      	ldrh	r3, [r3, #0]
    2968:	f103 0301 	add.w	r3, r3, #1
    296c:	b298      	uxth	r0, r3
    296e:	f247 0130 	movw	r1, #28720	; 0x7030
    2972:	f2c2 0100 	movt	r1, #8192	; 0x2000
    2976:	4613      	mov	r3, r2
    2978:	ea4f 0383 	mov.w	r3, r3, lsl #2
    297c:	4413      	add	r3, r2
    297e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2982:	440b      	add	r3, r1
    2984:	f103 03a0 	add.w	r3, r3, #160	; 0xa0
    2988:	4602      	mov	r2, r0
    298a:	801a      	strh	r2, [r3, #0]
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
    298c:	68fb      	ldr	r3, [r7, #12]
}
    298e:	4618      	mov	r0, r3
    2990:	f107 0714 	add.w	r7, r7, #20
    2994:	46bd      	mov	sp, r7
    2996:	bc80      	pop	{r7}
    2998:	4770      	bx	lr
    299a:	bf00      	nop

0000299c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    299c:	b480      	push	{r7}
    299e:	b085      	sub	sp, #20
    29a0:	af00      	add	r7, sp, #0
    29a2:	4603      	mov	r3, r0
    29a4:	6039      	str	r1, [r7, #0]
    29a6:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    29a8:	683b      	ldr	r3, [r7, #0]
    29aa:	2b00      	cmp	r3, #0
    29ac:	d034      	beq.n	2a18 <memp_free+0x7c>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
    29ae:	683b      	ldr	r3, [r7, #0]
    29b0:	60fb      	str	r3, [r7, #12]
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    29b2:	79fa      	ldrb	r2, [r7, #7]
    29b4:	f247 0130 	movw	r1, #28720	; 0x7030
    29b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
    29bc:	4613      	mov	r3, r2
    29be:	ea4f 0383 	mov.w	r3, r3, lsl #2
    29c2:	4413      	add	r3, r2
    29c4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    29c8:	440b      	add	r3, r1
    29ca:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    29ce:	881b      	ldrh	r3, [r3, #0]
    29d0:	f103 33ff 	add.w	r3, r3, #4294967295
    29d4:	b298      	uxth	r0, r3
    29d6:	f247 0130 	movw	r1, #28720	; 0x7030
    29da:	f2c2 0100 	movt	r1, #8192	; 0x2000
    29de:	4613      	mov	r3, r2
    29e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    29e4:	4413      	add	r3, r2
    29e6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    29ea:	440b      	add	r3, r1
    29ec:	f103 039c 	add.w	r3, r3, #156	; 0x9c
    29f0:	4602      	mov	r2, r0
    29f2:	801a      	strh	r2, [r3, #0]
  
  memp->next = memp_tab[type]; 
    29f4:	79fa      	ldrb	r2, [r7, #7]
    29f6:	f240 63ec 	movw	r3, #1772	; 0x6ec
    29fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    2a02:	68fb      	ldr	r3, [r7, #12]
    2a04:	601a      	str	r2, [r3, #0]
  memp_tab[type] = memp;
    2a06:	79fa      	ldrb	r2, [r7, #7]
    2a08:	f240 63ec 	movw	r3, #1772	; 0x6ec
    2a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a10:	68f9      	ldr	r1, [r7, #12]
    2a12:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    2a16:	e000      	b.n	2a1a <memp_free+0x7e>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
    2a18:	bf00      	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    2a1a:	f107 0714 	add.w	r7, r7, #20
    2a1e:	46bd      	mov	sp, r7
    2a20:	bc80      	pop	{r7}
    2a22:	4770      	bx	lr

00002a24 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
    2a24:	b480      	push	{r7}
    2a26:	af00      	add	r7, sp, #0
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    2a28:	46bd      	mov	sp, r7
    2a2a:	bc80      	pop	{r7}
    2a2c:	4770      	bx	lr
    2a2e:	bf00      	nop

00002a30 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
    2a30:	b580      	push	{r7, lr}
    2a32:	b084      	sub	sp, #16
    2a34:	af00      	add	r7, sp, #0
    2a36:	60f8      	str	r0, [r7, #12]
    2a38:	60b9      	str	r1, [r7, #8]
    2a3a:	607a      	str	r2, [r7, #4]
    2a3c:	603b      	str	r3, [r7, #0]
  static u8_t netifnum = 0;

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
    2a3e:	68fb      	ldr	r3, [r7, #12]
    2a40:	f04f 0200 	mov.w	r2, #0
    2a44:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero(&netif->netmask);
    2a46:	68fb      	ldr	r3, [r7, #12]
    2a48:	f04f 0200 	mov.w	r2, #0
    2a4c:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero(&netif->gw);
    2a4e:	68fb      	ldr	r3, [r7, #12]
    2a50:	f04f 0200 	mov.w	r2, #0
    2a54:	60da      	str	r2, [r3, #12]
  netif->flags = 0;
    2a56:	68fb      	ldr	r3, [r7, #12]
    2a58:	f04f 0200 	mov.w	r2, #0
    2a5c:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    2a60:	68fb      	ldr	r3, [r7, #12]
    2a62:	69ba      	ldr	r2, [r7, #24]
    2a64:	61da      	str	r2, [r3, #28]
  netif->num = netifnum++;
    2a66:	f243 1334 	movw	r3, #12596	; 0x3134
    2a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a6e:	781b      	ldrb	r3, [r3, #0]
    2a70:	68fa      	ldr	r2, [r7, #12]
    2a72:	4619      	mov	r1, r3
    2a74:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
    2a78:	f103 0301 	add.w	r3, r3, #1
    2a7c:	b2da      	uxtb	r2, r3
    2a7e:	f243 1334 	movw	r3, #12596	; 0x3134
    2a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a86:	701a      	strb	r2, [r3, #0]
  netif->input = input;
    2a88:	68fb      	ldr	r3, [r7, #12]
    2a8a:	6a3a      	ldr	r2, [r7, #32]
    2a8c:	611a      	str	r2, [r3, #16]
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    2a8e:	68f8      	ldr	r0, [r7, #12]
    2a90:	68b9      	ldr	r1, [r7, #8]
    2a92:	687a      	ldr	r2, [r7, #4]
    2a94:	683b      	ldr	r3, [r7, #0]
    2a96:	f000 f81d 	bl	2ad4 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    2a9a:	69fb      	ldr	r3, [r7, #28]
    2a9c:	68f8      	ldr	r0, [r7, #12]
    2a9e:	4798      	blx	r3
    2aa0:	4603      	mov	r3, r0
    2aa2:	b2db      	uxtb	r3, r3
    2aa4:	2b00      	cmp	r3, #0
    2aa6:	d002      	beq.n	2aae <netif_add+0x7e>
    return NULL;
    2aa8:	f04f 0300 	mov.w	r3, #0
    2aac:	e00d      	b.n	2aca <netif_add+0x9a>
  }

  /* add this netif to the list */
  netif->next = netif_list;
    2aae:	f247 0328 	movw	r3, #28712	; 0x7028
    2ab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ab6:	681a      	ldr	r2, [r3, #0]
    2ab8:	68fb      	ldr	r3, [r7, #12]
    2aba:	601a      	str	r2, [r3, #0]
  netif_list = netif;
    2abc:	f247 0328 	movw	r3, #28712	; 0x7028
    2ac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ac4:	68fa      	ldr	r2, [r7, #12]
    2ac6:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
    2ac8:	68fb      	ldr	r3, [r7, #12]
}
    2aca:	4618      	mov	r0, r3
    2acc:	f107 0710 	add.w	r7, r7, #16
    2ad0:	46bd      	mov	sp, r7
    2ad2:	bd80      	pop	{r7, pc}

00002ad4 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
    2ad4:	b580      	push	{r7, lr}
    2ad6:	b084      	sub	sp, #16
    2ad8:	af00      	add	r7, sp, #0
    2ada:	60f8      	str	r0, [r7, #12]
    2adc:	60b9      	str	r1, [r7, #8]
    2ade:	607a      	str	r2, [r7, #4]
    2ae0:	603b      	str	r3, [r7, #0]
  netif_set_ipaddr(netif, ipaddr);
    2ae2:	68f8      	ldr	r0, [r7, #12]
    2ae4:	68b9      	ldr	r1, [r7, #8]
    2ae6:	f000 f80d 	bl	2b04 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
    2aea:	68f8      	ldr	r0, [r7, #12]
    2aec:	6879      	ldr	r1, [r7, #4]
    2aee:	f000 f831 	bl	2b54 <netif_set_netmask>
  netif_set_gw(netif, gw);
    2af2:	68f8      	ldr	r0, [r7, #12]
    2af4:	6839      	ldr	r1, [r7, #0]
    2af6:	f000 f819 	bl	2b2c <netif_set_gw>
}
    2afa:	f107 0710 	add.w	r7, r7, #16
    2afe:	46bd      	mov	sp, r7
    2b00:	bd80      	pop	{r7, pc}
    2b02:	bf00      	nop

00002b04 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    2b04:	b480      	push	{r7}
    2b06:	b083      	sub	sp, #12
    2b08:	af00      	add	r7, sp, #0
    2b0a:	6078      	str	r0, [r7, #4]
    2b0c:	6039      	str	r1, [r7, #0]
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    2b0e:	683b      	ldr	r3, [r7, #0]
    2b10:	2b00      	cmp	r3, #0
    2b12:	d002      	beq.n	2b1a <netif_set_ipaddr+0x16>
    2b14:	683b      	ldr	r3, [r7, #0]
    2b16:	681b      	ldr	r3, [r3, #0]
    2b18:	e001      	b.n	2b1e <netif_set_ipaddr+0x1a>
    2b1a:	f04f 0300 	mov.w	r3, #0
    2b1e:	687a      	ldr	r2, [r7, #4]
    2b20:	6053      	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
    2b22:	f107 070c 	add.w	r7, r7, #12
    2b26:	46bd      	mov	sp, r7
    2b28:	bc80      	pop	{r7}
    2b2a:	4770      	bx	lr

00002b2c <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
    2b2c:	b480      	push	{r7}
    2b2e:	b083      	sub	sp, #12
    2b30:	af00      	add	r7, sp, #0
    2b32:	6078      	str	r0, [r7, #4]
    2b34:	6039      	str	r1, [r7, #0]
  ip_addr_set(&(netif->gw), gw);
    2b36:	683b      	ldr	r3, [r7, #0]
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d002      	beq.n	2b42 <netif_set_gw+0x16>
    2b3c:	683b      	ldr	r3, [r7, #0]
    2b3e:	681b      	ldr	r3, [r3, #0]
    2b40:	e001      	b.n	2b46 <netif_set_gw+0x1a>
    2b42:	f04f 0300 	mov.w	r3, #0
    2b46:	687a      	ldr	r2, [r7, #4]
    2b48:	60d3      	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
    2b4a:	f107 070c 	add.w	r7, r7, #12
    2b4e:	46bd      	mov	sp, r7
    2b50:	bc80      	pop	{r7}
    2b52:	4770      	bx	lr

00002b54 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
    2b54:	b480      	push	{r7}
    2b56:	b083      	sub	sp, #12
    2b58:	af00      	add	r7, sp, #0
    2b5a:	6078      	str	r0, [r7, #4]
    2b5c:	6039      	str	r1, [r7, #0]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    2b5e:	683b      	ldr	r3, [r7, #0]
    2b60:	2b00      	cmp	r3, #0
    2b62:	d002      	beq.n	2b6a <netif_set_netmask+0x16>
    2b64:	683b      	ldr	r3, [r7, #0]
    2b66:	681b      	ldr	r3, [r3, #0]
    2b68:	e001      	b.n	2b6e <netif_set_netmask+0x1a>
    2b6a:	f04f 0300 	mov.w	r3, #0
    2b6e:	687a      	ldr	r2, [r7, #4]
    2b70:	6093      	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
    2b72:	f107 070c 	add.w	r7, r7, #12
    2b76:	46bd      	mov	sp, r7
    2b78:	bc80      	pop	{r7}
    2b7a:	4770      	bx	lr

00002b7c <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
    2b7c:	b480      	push	{r7}
    2b7e:	b083      	sub	sp, #12
    2b80:	af00      	add	r7, sp, #0
    2b82:	6078      	str	r0, [r7, #4]
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    2b84:	f247 032c 	movw	r3, #28716	; 0x702c
    2b88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b8c:	687a      	ldr	r2, [r7, #4]
    2b8e:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    2b90:	f107 070c 	add.w	r7, r7, #12
    2b94:	46bd      	mov	sp, r7
    2b96:	bc80      	pop	{r7}
    2b98:	4770      	bx	lr
    2b9a:	bf00      	nop

00002b9c <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
    2b9c:	b580      	push	{r7, lr}
    2b9e:	b082      	sub	sp, #8
    2ba0:	af00      	add	r7, sp, #0
    2ba2:	6078      	str	r0, [r7, #4]
  if (!(netif->flags & NETIF_FLAG_UP)) {
    2ba4:	687b      	ldr	r3, [r7, #4]
    2ba6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    2baa:	f003 0301 	and.w	r3, r3, #1
    2bae:	2b00      	cmp	r3, #0
    2bb0:	d11d      	bne.n	2bee <netif_set_up+0x52>
    netif->flags |= NETIF_FLAG_UP;
    2bb2:	687b      	ldr	r3, [r7, #4]
    2bb4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    2bb8:	f043 0301 	orr.w	r3, r3, #1
    2bbc:	b2da      	uxtb	r2, r3
    2bbe:	687b      	ldr	r3, [r7, #4]
    2bc0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
    2bc4:	687b      	ldr	r3, [r7, #4]
    2bc6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    2bca:	f003 0310 	and.w	r3, r3, #16
    2bce:	2b00      	cmp	r3, #0
    2bd0:	d00d      	beq.n	2bee <netif_set_up+0x52>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
    2bd2:	687b      	ldr	r3, [r7, #4]
    2bd4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    2bd8:	f003 0320 	and.w	r3, r3, #32
    2bdc:	2b00      	cmp	r3, #0
    2bde:	d006      	beq.n	2bee <netif_set_up+0x52>
        etharp_gratuitous(netif);
    2be0:	687b      	ldr	r3, [r7, #4]
    2be2:	f103 0304 	add.w	r3, r3, #4
    2be6:	6878      	ldr	r0, [r7, #4]
    2be8:	4619      	mov	r1, r3
    2bea:	f7ff f8c1 	bl	1d70 <etharp_request>
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
    2bee:	f107 0708 	add.w	r7, r7, #8
    2bf2:	46bd      	mov	sp, r7
    2bf4:	bd80      	pop	{r7, pc}
    2bf6:	bf00      	nop

00002bf8 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    2bf8:	b580      	push	{r7, lr}
    2bfa:	b088      	sub	sp, #32
    2bfc:	af00      	add	r7, sp, #0
    2bfe:	4613      	mov	r3, r2
    2c00:	4602      	mov	r2, r0
    2c02:	71fa      	strb	r2, [r7, #7]
    2c04:	460a      	mov	r2, r1
    2c06:	80ba      	strh	r2, [r7, #4]
    2c08:	70fb      	strb	r3, [r7, #3]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
    2c0a:	f04f 0300 	mov.w	r3, #0
    2c0e:	837b      	strh	r3, [r7, #26]
  switch (layer) {
    2c10:	79fb      	ldrb	r3, [r7, #7]
    2c12:	2b03      	cmp	r3, #3
    2c14:	d817      	bhi.n	2c46 <pbuf_alloc+0x4e>
    2c16:	a201      	add	r2, pc, #4	; (adr r2, 2c1c <pbuf_alloc+0x24>)
    2c18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2c1c:	00002c2d 	.word	0x00002c2d
    2c20:	00002c35 	.word	0x00002c35
    2c24:	00002c3d 	.word	0x00002c3d
    2c28:	00002c4d 	.word	0x00002c4d
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    2c2c:	8b7b      	ldrh	r3, [r7, #26]
    2c2e:	f103 0314 	add.w	r3, r3, #20
    2c32:	837b      	strh	r3, [r7, #26]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    2c34:	8b7b      	ldrh	r3, [r7, #26]
    2c36:	f103 0314 	add.w	r3, r3, #20
    2c3a:	837b      	strh	r3, [r7, #26]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    2c3c:	8b7b      	ldrh	r3, [r7, #26]
    2c3e:	f103 030e 	add.w	r3, r3, #14
    2c42:	837b      	strh	r3, [r7, #26]
    break;
    2c44:	e003      	b.n	2c4e <pbuf_alloc+0x56>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
    2c46:	f04f 0300 	mov.w	r3, #0
    2c4a:	e0fb      	b.n	2e44 <pbuf_alloc+0x24c>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
    2c4c:	bf00      	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
    2c4e:	78fb      	ldrb	r3, [r7, #3]
    2c50:	2b03      	cmp	r3, #3
    2c52:	f200 80eb 	bhi.w	2e2c <pbuf_alloc+0x234>
    2c56:	a201      	add	r2, pc, #4	; (adr r2, 2c5c <pbuf_alloc+0x64>)
    2c58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2c5c:	00002d6d 	.word	0x00002d6d
    2c60:	00002def 	.word	0x00002def
    2c64:	00002def 	.word	0x00002def
    2c68:	00002c6d 	.word	0x00002c6d
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    2c6c:	f04f 0006 	mov.w	r0, #6
    2c70:	f7ff fdea 	bl	2848 <memp_malloc>
    2c74:	4603      	mov	r3, r0
    2c76:	60fb      	str	r3, [r7, #12]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    2c78:	68fb      	ldr	r3, [r7, #12]
    2c7a:	2b00      	cmp	r3, #0
    2c7c:	d102      	bne.n	2c84 <pbuf_alloc+0x8c>
      PBUF_POOL_IS_EMPTY();
      return NULL;
    2c7e:	f04f 0300 	mov.w	r3, #0
    2c82:	e0df      	b.n	2e44 <pbuf_alloc+0x24c>
    }
    p->type = type;
    2c84:	68fb      	ldr	r3, [r7, #12]
    2c86:	78fa      	ldrb	r2, [r7, #3]
    2c88:	731a      	strb	r2, [r3, #12]
    p->next = NULL;
    2c8a:	68fb      	ldr	r3, [r7, #12]
    2c8c:	f04f 0200 	mov.w	r2, #0
    2c90:	601a      	str	r2, [r3, #0]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    2c92:	8b7b      	ldrh	r3, [r7, #26]
    2c94:	f103 0210 	add.w	r2, r3, #16
    2c98:	68fb      	ldr	r3, [r7, #12]
    2c9a:	4413      	add	r3, r2
    2c9c:	f103 0303 	add.w	r3, r3, #3
    2ca0:	f023 0303 	bic.w	r3, r3, #3
    2ca4:	461a      	mov	r2, r3
    2ca6:	68fb      	ldr	r3, [r7, #12]
    2ca8:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    2caa:	68fb      	ldr	r3, [r7, #12]
    2cac:	88ba      	ldrh	r2, [r7, #4]
    2cae:	811a      	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    2cb0:	8b7b      	ldrh	r3, [r7, #26]
    2cb2:	f103 0303 	add.w	r3, r3, #3
    2cb6:	f023 0303 	bic.w	r3, r3, #3
    2cba:	f5c3 7214 	rsb	r2, r3, #592	; 0x250
    2cbe:	88bb      	ldrh	r3, [r7, #4]
    2cc0:	429a      	cmp	r2, r3
    2cc2:	bfb8      	it	lt
    2cc4:	4613      	movlt	r3, r2
    2cc6:	b29a      	uxth	r2, r3
    2cc8:	68fb      	ldr	r3, [r7, #12]
    2cca:	815a      	strh	r2, [r3, #10]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    2ccc:	68fb      	ldr	r3, [r7, #12]
    2cce:	f04f 0201 	mov.w	r2, #1
    2cd2:	81da      	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    2cd4:	68fb      	ldr	r3, [r7, #12]
    2cd6:	617b      	str	r3, [r7, #20]
    /* remaining length to be allocated */
    rem_len = length - p->len;
    2cd8:	88ba      	ldrh	r2, [r7, #4]
    2cda:	68fb      	ldr	r3, [r7, #12]
    2cdc:	895b      	ldrh	r3, [r3, #10]
    2cde:	ebc3 0302 	rsb	r3, r3, r2
    2ce2:	61fb      	str	r3, [r7, #28]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    2ce4:	e03e      	b.n	2d64 <pbuf_alloc+0x16c>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    2ce6:	f04f 0006 	mov.w	r0, #6
    2cea:	f7ff fdad 	bl	2848 <memp_malloc>
    2cee:	4603      	mov	r3, r0
    2cf0:	613b      	str	r3, [r7, #16]
      if (q == NULL) {
    2cf2:	693b      	ldr	r3, [r7, #16]
    2cf4:	2b00      	cmp	r3, #0
    2cf6:	d105      	bne.n	2d04 <pbuf_alloc+0x10c>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
    2cf8:	68f8      	ldr	r0, [r7, #12]
    2cfa:	f000 f9fb 	bl	30f4 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
    2cfe:	f04f 0300 	mov.w	r3, #0
    2d02:	e09f      	b.n	2e44 <pbuf_alloc+0x24c>
      }
      q->type = type;
    2d04:	693b      	ldr	r3, [r7, #16]
    2d06:	78fa      	ldrb	r2, [r7, #3]
    2d08:	731a      	strb	r2, [r3, #12]
      q->flags = 0;
    2d0a:	693b      	ldr	r3, [r7, #16]
    2d0c:	f04f 0200 	mov.w	r2, #0
    2d10:	735a      	strb	r2, [r3, #13]
      q->next = NULL;
    2d12:	693b      	ldr	r3, [r7, #16]
    2d14:	f04f 0200 	mov.w	r2, #0
    2d18:	601a      	str	r2, [r3, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
    2d1a:	697b      	ldr	r3, [r7, #20]
    2d1c:	693a      	ldr	r2, [r7, #16]
    2d1e:	601a      	str	r2, [r3, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
    2d20:	69fb      	ldr	r3, [r7, #28]
    2d22:	b29a      	uxth	r2, r3
    2d24:	693b      	ldr	r3, [r7, #16]
    2d26:	811a      	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    2d28:	69fb      	ldr	r3, [r7, #28]
    2d2a:	b29a      	uxth	r2, r3
    2d2c:	f240 234f 	movw	r3, #591	; 0x24f
    2d30:	429a      	cmp	r2, r3
    2d32:	d802      	bhi.n	2d3a <pbuf_alloc+0x142>
    2d34:	69fb      	ldr	r3, [r7, #28]
    2d36:	b29b      	uxth	r3, r3
    2d38:	e001      	b.n	2d3e <pbuf_alloc+0x146>
    2d3a:	f44f 7314 	mov.w	r3, #592	; 0x250
    2d3e:	693a      	ldr	r2, [r7, #16]
    2d40:	8153      	strh	r3, [r2, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    2d42:	693b      	ldr	r3, [r7, #16]
    2d44:	f103 0210 	add.w	r2, r3, #16
    2d48:	693b      	ldr	r3, [r7, #16]
    2d4a:	605a      	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    2d4c:	693b      	ldr	r3, [r7, #16]
    2d4e:	f04f 0201 	mov.w	r2, #1
    2d52:	81da      	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    2d54:	693b      	ldr	r3, [r7, #16]
    2d56:	895b      	ldrh	r3, [r3, #10]
    2d58:	69fa      	ldr	r2, [r7, #28]
    2d5a:	ebc3 0302 	rsb	r3, r3, r2
    2d5e:	61fb      	str	r3, [r7, #28]
      /* remember this pbuf for linkage in next iteration */
      r = q;
    2d60:	693b      	ldr	r3, [r7, #16]
    2d62:	617b      	str	r3, [r7, #20]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    2d64:	69fb      	ldr	r3, [r7, #28]
    2d66:	2b00      	cmp	r3, #0
    2d68:	dcbd      	bgt.n	2ce6 <pbuf_alloc+0xee>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
    2d6a:	e062      	b.n	2e32 <pbuf_alloc+0x23a>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    2d6c:	8b7b      	ldrh	r3, [r7, #26]
    2d6e:	f103 0313 	add.w	r3, r3, #19
    2d72:	b29b      	uxth	r3, r3
    2d74:	4619      	mov	r1, r3
    2d76:	f64f 73fc 	movw	r3, #65532	; 0xfffc
    2d7a:	f2c0 0300 	movt	r3, #0
    2d7e:	ea01 0303 	and.w	r3, r1, r3
    2d82:	4619      	mov	r1, r3
    2d84:	88bb      	ldrh	r3, [r7, #4]
    2d86:	f103 0303 	add.w	r3, r3, #3
    2d8a:	b29b      	uxth	r3, r3
    2d8c:	461a      	mov	r2, r3
    2d8e:	f64f 73fc 	movw	r3, #65532	; 0xfffc
    2d92:	f2c0 0300 	movt	r3, #0
    2d96:	ea02 0303 	and.w	r3, r2, r3
    2d9a:	461a      	mov	r2, r3
    2d9c:	eb01 0302 	add.w	r3, r1, r2
    2da0:	b29b      	uxth	r3, r3
    2da2:	4618      	mov	r0, r3
    2da4:	f7ff fb52 	bl	244c <mem_malloc>
    2da8:	4603      	mov	r3, r0
    2daa:	60fb      	str	r3, [r7, #12]
    if (p == NULL) {
    2dac:	68fb      	ldr	r3, [r7, #12]
    2dae:	2b00      	cmp	r3, #0
    2db0:	d102      	bne.n	2db8 <pbuf_alloc+0x1c0>
      return NULL;
    2db2:	f04f 0300 	mov.w	r3, #0
    2db6:	e045      	b.n	2e44 <pbuf_alloc+0x24c>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    2db8:	8b7b      	ldrh	r3, [r7, #26]
    2dba:	f103 0210 	add.w	r2, r3, #16
    2dbe:	68fb      	ldr	r3, [r7, #12]
    2dc0:	4413      	add	r3, r2
    2dc2:	f103 0303 	add.w	r3, r3, #3
    2dc6:	f023 0303 	bic.w	r3, r3, #3
    2dca:	461a      	mov	r2, r3
    2dcc:	68fb      	ldr	r3, [r7, #12]
    2dce:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
    2dd0:	68fb      	ldr	r3, [r7, #12]
    2dd2:	88ba      	ldrh	r2, [r7, #4]
    2dd4:	811a      	strh	r2, [r3, #8]
    2dd6:	68fb      	ldr	r3, [r7, #12]
    2dd8:	891a      	ldrh	r2, [r3, #8]
    2dda:	68fb      	ldr	r3, [r7, #12]
    2ddc:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
    2dde:	68fb      	ldr	r3, [r7, #12]
    2de0:	f04f 0200 	mov.w	r2, #0
    2de4:	601a      	str	r2, [r3, #0]
    p->type = type;
    2de6:	68fb      	ldr	r3, [r7, #12]
    2de8:	78fa      	ldrb	r2, [r7, #3]
    2dea:	731a      	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
    2dec:	e021      	b.n	2e32 <pbuf_alloc+0x23a>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    2dee:	f04f 0005 	mov.w	r0, #5
    2df2:	f7ff fd29 	bl	2848 <memp_malloc>
    2df6:	4603      	mov	r3, r0
    2df8:	60fb      	str	r3, [r7, #12]
    if (p == NULL) {
    2dfa:	68fb      	ldr	r3, [r7, #12]
    2dfc:	2b00      	cmp	r3, #0
    2dfe:	d102      	bne.n	2e06 <pbuf_alloc+0x20e>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    2e00:	f04f 0300 	mov.w	r3, #0
    2e04:	e01e      	b.n	2e44 <pbuf_alloc+0x24c>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    2e06:	68fb      	ldr	r3, [r7, #12]
    2e08:	f04f 0200 	mov.w	r2, #0
    2e0c:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
    2e0e:	68fb      	ldr	r3, [r7, #12]
    2e10:	88ba      	ldrh	r2, [r7, #4]
    2e12:	811a      	strh	r2, [r3, #8]
    2e14:	68fb      	ldr	r3, [r7, #12]
    2e16:	891a      	ldrh	r2, [r3, #8]
    2e18:	68fb      	ldr	r3, [r7, #12]
    2e1a:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
    2e1c:	68fb      	ldr	r3, [r7, #12]
    2e1e:	f04f 0200 	mov.w	r2, #0
    2e22:	601a      	str	r2, [r3, #0]
    p->type = type;
    2e24:	68fb      	ldr	r3, [r7, #12]
    2e26:	78fa      	ldrb	r2, [r7, #3]
    2e28:	731a      	strb	r2, [r3, #12]
    break;
    2e2a:	e002      	b.n	2e32 <pbuf_alloc+0x23a>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
    2e2c:	f04f 0300 	mov.w	r3, #0
    2e30:	e008      	b.n	2e44 <pbuf_alloc+0x24c>
  }
  /* set reference count */
  p->ref = 1;
    2e32:	68fb      	ldr	r3, [r7, #12]
    2e34:	f04f 0201 	mov.w	r2, #1
    2e38:	81da      	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
    2e3a:	68fb      	ldr	r3, [r7, #12]
    2e3c:	f04f 0200 	mov.w	r2, #0
    2e40:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
    2e42:	68fb      	ldr	r3, [r7, #12]
}
    2e44:	4618      	mov	r0, r3
    2e46:	f107 0720 	add.w	r7, r7, #32
    2e4a:	46bd      	mov	sp, r7
    2e4c:	bd80      	pop	{r7, pc}
    2e4e:	bf00      	nop

00002e50 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
    2e50:	b480      	push	{r7}
    2e52:	b087      	sub	sp, #28
    2e54:	af00      	add	r7, sp, #0
    2e56:	607b      	str	r3, [r7, #4]
    2e58:	4603      	mov	r3, r0
    2e5a:	73fb      	strb	r3, [r7, #15]
    2e5c:	460b      	mov	r3, r1
    2e5e:	81bb      	strh	r3, [r7, #12]
    2e60:	4613      	mov	r3, r2
    2e62:	72fb      	strb	r3, [r7, #11]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
    2e64:	f04f 0300 	mov.w	r3, #0
    2e68:	82fb      	strh	r3, [r7, #22]
  switch (l) {
    2e6a:	7bfb      	ldrb	r3, [r7, #15]
    2e6c:	2b03      	cmp	r3, #3
    2e6e:	d818      	bhi.n	2ea2 <pbuf_alloced_custom+0x52>
    2e70:	a201      	add	r2, pc, #4	; (adr r2, 2e78 <pbuf_alloced_custom+0x28>)
    2e72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2e76:	bf00      	nop
    2e78:	00002e89 	.word	0x00002e89
    2e7c:	00002e91 	.word	0x00002e91
    2e80:	00002e99 	.word	0x00002e99
    2e84:	00002ea9 	.word	0x00002ea9
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    2e88:	8afb      	ldrh	r3, [r7, #22]
    2e8a:	f103 0314 	add.w	r3, r3, #20
    2e8e:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    2e90:	8afb      	ldrh	r3, [r7, #22]
    2e92:	f103 0314 	add.w	r3, r3, #20
    2e96:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    2e98:	8afb      	ldrh	r3, [r7, #22]
    2e9a:	f103 030e 	add.w	r3, r3, #14
    2e9e:	82fb      	strh	r3, [r7, #22]
    break;
    2ea0:	e003      	b.n	2eaa <pbuf_alloced_custom+0x5a>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
    2ea2:	f04f 0300 	mov.w	r3, #0
    2ea6:	e036      	b.n	2f16 <pbuf_alloced_custom+0xc6>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
    2ea8:	bf00      	nop
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length < payload_mem_len) {
    2eaa:	8afb      	ldrh	r3, [r7, #22]
    2eac:	f103 0303 	add.w	r3, r3, #3
    2eb0:	f023 0203 	bic.w	r2, r3, #3
    2eb4:	89bb      	ldrh	r3, [r7, #12]
    2eb6:	441a      	add	r2, r3
    2eb8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    2eba:	429a      	cmp	r2, r3
    2ebc:	da02      	bge.n	2ec4 <pbuf_alloced_custom+0x74>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
    2ebe:	f04f 0300 	mov.w	r3, #0
    2ec2:	e028      	b.n	2f16 <pbuf_alloced_custom+0xc6>
  }

  p->pbuf.next = NULL;
    2ec4:	687b      	ldr	r3, [r7, #4]
    2ec6:	f04f 0200 	mov.w	r2, #0
    2eca:	601a      	str	r2, [r3, #0]
  if (payload_mem != NULL) {
    2ecc:	6a3b      	ldr	r3, [r7, #32]
    2ece:	2b00      	cmp	r3, #0
    2ed0:	d00a      	beq.n	2ee8 <pbuf_alloced_custom+0x98>
    p->pbuf.payload = LWIP_MEM_ALIGN((void *)((u8_t *)payload_mem + offset));
    2ed2:	8afa      	ldrh	r2, [r7, #22]
    2ed4:	6a3b      	ldr	r3, [r7, #32]
    2ed6:	4413      	add	r3, r2
    2ed8:	f103 0303 	add.w	r3, r3, #3
    2edc:	f023 0303 	bic.w	r3, r3, #3
    2ee0:	461a      	mov	r2, r3
    2ee2:	687b      	ldr	r3, [r7, #4]
    2ee4:	605a      	str	r2, [r3, #4]
    2ee6:	e003      	b.n	2ef0 <pbuf_alloced_custom+0xa0>
  } else {
    p->pbuf.payload = NULL;
    2ee8:	687b      	ldr	r3, [r7, #4]
    2eea:	f04f 0200 	mov.w	r2, #0
    2eee:	605a      	str	r2, [r3, #4]
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    2ef0:	687b      	ldr	r3, [r7, #4]
    2ef2:	f04f 0202 	mov.w	r2, #2
    2ef6:	735a      	strb	r2, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
    2ef8:	687b      	ldr	r3, [r7, #4]
    2efa:	89ba      	ldrh	r2, [r7, #12]
    2efc:	811a      	strh	r2, [r3, #8]
    2efe:	687b      	ldr	r3, [r7, #4]
    2f00:	891a      	ldrh	r2, [r3, #8]
    2f02:	687b      	ldr	r3, [r7, #4]
    2f04:	815a      	strh	r2, [r3, #10]
  p->pbuf.type = type;
    2f06:	687b      	ldr	r3, [r7, #4]
    2f08:	7afa      	ldrb	r2, [r7, #11]
    2f0a:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
    2f0c:	687b      	ldr	r3, [r7, #4]
    2f0e:	f04f 0201 	mov.w	r2, #1
    2f12:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
    2f14:	687b      	ldr	r3, [r7, #4]
}
    2f16:	4618      	mov	r0, r3
    2f18:	f107 071c 	add.w	r7, r7, #28
    2f1c:	46bd      	mov	sp, r7
    2f1e:	bc80      	pop	{r7}
    2f20:	4770      	bx	lr
    2f22:	bf00      	nop

00002f24 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    2f24:	b580      	push	{r7, lr}
    2f26:	b086      	sub	sp, #24
    2f28:	af00      	add	r7, sp, #0
    2f2a:	6078      	str	r0, [r7, #4]
    2f2c:	460b      	mov	r3, r1
    2f2e:	807b      	strh	r3, [r7, #2]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
    2f30:	687b      	ldr	r3, [r7, #4]
    2f32:	7b1b      	ldrb	r3, [r3, #12]
    2f34:	2b03      	cmp	r3, #3
    2f36:	d006      	beq.n	2f46 <pbuf_realloc+0x22>
    2f38:	687b      	ldr	r3, [r7, #4]
    2f3a:	7b1b      	ldrb	r3, [r3, #12]
    2f3c:	2b01      	cmp	r3, #1
    2f3e:	d002      	beq.n	2f46 <pbuf_realloc+0x22>
    2f40:	687b      	ldr	r3, [r7, #4]
    2f42:	7b1b      	ldrb	r3, [r3, #12]
    2f44:	2b00      	cmp	r3, #0
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    2f46:	687b      	ldr	r3, [r7, #4]
    2f48:	891b      	ldrh	r3, [r3, #8]
    2f4a:	887a      	ldrh	r2, [r7, #2]
    2f4c:	429a      	cmp	r2, r3
    2f4e:	d24f      	bcs.n	2ff0 <pbuf_realloc+0xcc>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    2f50:	887a      	ldrh	r2, [r7, #2]
    2f52:	687b      	ldr	r3, [r7, #4]
    2f54:	891b      	ldrh	r3, [r3, #8]
    2f56:	ebc3 0302 	rsb	r3, r3, r2
    2f5a:	617b      	str	r3, [r7, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
    2f5c:	887b      	ldrh	r3, [r7, #2]
    2f5e:	827b      	strh	r3, [r7, #18]
  q = p;
    2f60:	687b      	ldr	r3, [r7, #4]
    2f62:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    2f64:	e010      	b.n	2f88 <pbuf_realloc+0x64>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    2f66:	68fb      	ldr	r3, [r7, #12]
    2f68:	895b      	ldrh	r3, [r3, #10]
    2f6a:	8a7a      	ldrh	r2, [r7, #18]
    2f6c:	ebc3 0302 	rsb	r3, r3, r2
    2f70:	827b      	strh	r3, [r7, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
    2f72:	68fb      	ldr	r3, [r7, #12]
    2f74:	891a      	ldrh	r2, [r3, #8]
    2f76:	697b      	ldr	r3, [r7, #20]
    2f78:	b29b      	uxth	r3, r3
    2f7a:	4413      	add	r3, r2
    2f7c:	b29a      	uxth	r2, r3
    2f7e:	68fb      	ldr	r3, [r7, #12]
    2f80:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
    2f82:	68fb      	ldr	r3, [r7, #12]
    2f84:	681b      	ldr	r3, [r3, #0]
    2f86:	60fb      	str	r3, [r7, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    2f88:	68fb      	ldr	r3, [r7, #12]
    2f8a:	895b      	ldrh	r3, [r3, #10]
    2f8c:	8a7a      	ldrh	r2, [r7, #18]
    2f8e:	429a      	cmp	r2, r3
    2f90:	d8e9      	bhi.n	2f66 <pbuf_realloc+0x42>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    2f92:	68fb      	ldr	r3, [r7, #12]
    2f94:	7b1b      	ldrb	r3, [r3, #12]
    2f96:	2b00      	cmp	r3, #0
    2f98:	d115      	bne.n	2fc6 <pbuf_realloc+0xa2>
    2f9a:	68fb      	ldr	r3, [r7, #12]
    2f9c:	895b      	ldrh	r3, [r3, #10]
    2f9e:	8a7a      	ldrh	r2, [r7, #18]
    2fa0:	429a      	cmp	r2, r3
    2fa2:	d010      	beq.n	2fc6 <pbuf_realloc+0xa2>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    2fa4:	68fb      	ldr	r3, [r7, #12]
    2fa6:	685b      	ldr	r3, [r3, #4]
    2fa8:	b29a      	uxth	r2, r3
    2faa:	68fb      	ldr	r3, [r7, #12]
    2fac:	b29b      	uxth	r3, r3
    2fae:	ebc3 0302 	rsb	r3, r3, r2
    2fb2:	b29a      	uxth	r2, r3
    2fb4:	8a7b      	ldrh	r3, [r7, #18]
    2fb6:	4413      	add	r3, r2
    2fb8:	b29b      	uxth	r3, r3
    2fba:	68f8      	ldr	r0, [r7, #12]
    2fbc:	4619      	mov	r1, r3
    2fbe:	f7ff f91b 	bl	21f8 <mem_trim>
    2fc2:	4603      	mov	r3, r0
    2fc4:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    2fc6:	68fb      	ldr	r3, [r7, #12]
    2fc8:	8a7a      	ldrh	r2, [r7, #18]
    2fca:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
    2fcc:	68fb      	ldr	r3, [r7, #12]
    2fce:	895a      	ldrh	r2, [r3, #10]
    2fd0:	68fb      	ldr	r3, [r7, #12]
    2fd2:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    2fd4:	68fb      	ldr	r3, [r7, #12]
    2fd6:	681b      	ldr	r3, [r3, #0]
    2fd8:	2b00      	cmp	r3, #0
    2fda:	d004      	beq.n	2fe6 <pbuf_realloc+0xc2>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    2fdc:	68fb      	ldr	r3, [r7, #12]
    2fde:	681b      	ldr	r3, [r3, #0]
    2fe0:	4618      	mov	r0, r3
    2fe2:	f000 f887 	bl	30f4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
    2fe6:	68fb      	ldr	r3, [r7, #12]
    2fe8:	f04f 0200 	mov.w	r2, #0
    2fec:	601a      	str	r2, [r3, #0]
    2fee:	e000      	b.n	2ff2 <pbuf_realloc+0xce>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
    2ff0:	bf00      	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
    2ff2:	f107 0718 	add.w	r7, r7, #24
    2ff6:	46bd      	mov	sp, r7
    2ff8:	bd80      	pop	{r7, pc}
    2ffa:	bf00      	nop

00002ffc <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    2ffc:	b480      	push	{r7}
    2ffe:	b087      	sub	sp, #28
    3000:	af00      	add	r7, sp, #0
    3002:	6078      	str	r0, [r7, #4]
    3004:	460b      	mov	r3, r1
    3006:	807b      	strh	r3, [r7, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    3008:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    300c:	2b00      	cmp	r3, #0
    300e:	d002      	beq.n	3016 <pbuf_header+0x1a>
    3010:	687b      	ldr	r3, [r7, #4]
    3012:	2b00      	cmp	r3, #0
    3014:	d102      	bne.n	301c <pbuf_header+0x20>
    return 0;
    3016:	f04f 0300 	mov.w	r3, #0
    301a:	e065      	b.n	30e8 <pbuf_header+0xec>
  }
 
  if (header_size_increment < 0){
    301c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    3020:	2b00      	cmp	r3, #0
    3022:	da0c      	bge.n	303e <pbuf_header+0x42>
    increment_magnitude = -header_size_increment;
    3024:	887b      	ldrh	r3, [r7, #2]
    3026:	f1c3 0300 	rsb	r3, r3, #0
    302a:	b29b      	uxth	r3, r3
    302c:	82fb      	strh	r3, [r7, #22]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    302e:	687b      	ldr	r3, [r7, #4]
    3030:	895b      	ldrh	r3, [r3, #10]
    3032:	8afa      	ldrh	r2, [r7, #22]
    3034:	429a      	cmp	r2, r3
    3036:	d904      	bls.n	3042 <pbuf_header+0x46>
    3038:	f04f 0301 	mov.w	r3, #1
    303c:	e054      	b.n	30e8 <pbuf_header+0xec>
  } else {
    increment_magnitude = header_size_increment;
    303e:	887b      	ldrh	r3, [r7, #2]
    3040:	82fb      	strh	r3, [r7, #22]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    3042:	687b      	ldr	r3, [r7, #4]
    3044:	7b1b      	ldrb	r3, [r3, #12]
    3046:	81fb      	strh	r3, [r7, #14]
  /* remember current payload pointer */
  payload = p->payload;
    3048:	687b      	ldr	r3, [r7, #4]
    304a:	685b      	ldr	r3, [r3, #4]
    304c:	613b      	str	r3, [r7, #16]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    304e:	89fb      	ldrh	r3, [r7, #14]
    3050:	2b00      	cmp	r3, #0
    3052:	d002      	beq.n	305a <pbuf_header+0x5e>
    3054:	89fb      	ldrh	r3, [r7, #14]
    3056:	2b03      	cmp	r3, #3
    3058:	d116      	bne.n	3088 <pbuf_header+0x8c>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    305a:	687b      	ldr	r3, [r7, #4]
    305c:	685a      	ldr	r2, [r3, #4]
    305e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    3062:	f1c3 0300 	rsb	r3, r3, #0
    3066:	441a      	add	r2, r3
    3068:	687b      	ldr	r3, [r7, #4]
    306a:	605a      	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    306c:	687b      	ldr	r3, [r7, #4]
    306e:	685b      	ldr	r3, [r3, #4]
    3070:	461a      	mov	r2, r3
    3072:	687b      	ldr	r3, [r7, #4]
    3074:	f103 0310 	add.w	r3, r3, #16
    3078:	429a      	cmp	r2, r3
    307a:	d224      	bcs.n	30c6 <pbuf_header+0xca>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
    307c:	687b      	ldr	r3, [r7, #4]
    307e:	693a      	ldr	r2, [r7, #16]
    3080:	605a      	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
    3082:	f04f 0301 	mov.w	r3, #1
    3086:	e02f      	b.n	30e8 <pbuf_header+0xec>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    3088:	89fb      	ldrh	r3, [r7, #14]
    308a:	2b02      	cmp	r3, #2
    308c:	d002      	beq.n	3094 <pbuf_header+0x98>
    308e:	89fb      	ldrh	r3, [r7, #14]
    3090:	2b01      	cmp	r3, #1
    3092:	d115      	bne.n	30c0 <pbuf_header+0xc4>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    3094:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    3098:	2b00      	cmp	r3, #0
    309a:	da0e      	bge.n	30ba <pbuf_header+0xbe>
    309c:	687b      	ldr	r3, [r7, #4]
    309e:	895b      	ldrh	r3, [r3, #10]
    30a0:	8afa      	ldrh	r2, [r7, #22]
    30a2:	429a      	cmp	r2, r3
    30a4:	d809      	bhi.n	30ba <pbuf_header+0xbe>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    30a6:	687b      	ldr	r3, [r7, #4]
    30a8:	685a      	ldr	r2, [r3, #4]
    30aa:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    30ae:	f1c3 0300 	rsb	r3, r3, #0
    30b2:	441a      	add	r2, r3
    30b4:	687b      	ldr	r3, [r7, #4]
    30b6:	605a      	str	r2, [r3, #4]
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    30b8:	e006      	b.n	30c8 <pbuf_header+0xcc>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
    30ba:	f04f 0301 	mov.w	r3, #1
    30be:	e013      	b.n	30e8 <pbuf_header+0xec>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
    30c0:	f04f 0301 	mov.w	r3, #1
    30c4:	e010      	b.n	30e8 <pbuf_header+0xec>
  type = p->type;
  /* remember current payload pointer */
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    30c6:	bf00      	nop
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    30c8:	687b      	ldr	r3, [r7, #4]
    30ca:	895a      	ldrh	r2, [r3, #10]
    30cc:	887b      	ldrh	r3, [r7, #2]
    30ce:	4413      	add	r3, r2
    30d0:	b29a      	uxth	r2, r3
    30d2:	687b      	ldr	r3, [r7, #4]
    30d4:	815a      	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
    30d6:	687b      	ldr	r3, [r7, #4]
    30d8:	891a      	ldrh	r2, [r3, #8]
    30da:	887b      	ldrh	r3, [r7, #2]
    30dc:	4413      	add	r3, r2
    30de:	b29a      	uxth	r2, r3
    30e0:	687b      	ldr	r3, [r7, #4]
    30e2:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    30e4:	f04f 0300 	mov.w	r3, #0
}
    30e8:	4618      	mov	r0, r3
    30ea:	f107 071c 	add.w	r7, r7, #28
    30ee:	46bd      	mov	sp, r7
    30f0:	bc80      	pop	{r7}
    30f2:	4770      	bx	lr

000030f4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    30f4:	b580      	push	{r7, lr}
    30f6:	b086      	sub	sp, #24
    30f8:	af00      	add	r7, sp, #0
    30fa:	6078      	str	r0, [r7, #4]
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    30fc:	687b      	ldr	r3, [r7, #4]
    30fe:	2b00      	cmp	r3, #0
    3100:	d102      	bne.n	3108 <pbuf_free+0x14>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
    3102:	f04f 0300 	mov.w	r3, #0
    3106:	e054      	b.n	31b2 <pbuf_free+0xbe>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    3108:	687b      	ldr	r3, [r7, #4]
    310a:	7b1b      	ldrb	r3, [r3, #12]
    310c:	2b00      	cmp	r3, #0
    310e:	d006      	beq.n	311e <pbuf_free+0x2a>
    3110:	687b      	ldr	r3, [r7, #4]
    3112:	7b1b      	ldrb	r3, [r3, #12]
    3114:	2b01      	cmp	r3, #1
    3116:	d002      	beq.n	311e <pbuf_free+0x2a>
    3118:	687b      	ldr	r3, [r7, #4]
    311a:	7b1b      	ldrb	r3, [r3, #12]
    311c:	2b02      	cmp	r3, #2
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
    311e:	f04f 0300 	mov.w	r3, #0
    3122:	747b      	strb	r3, [r7, #17]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    3124:	e041      	b.n	31aa <pbuf_free+0xb6>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    3126:	687b      	ldr	r3, [r7, #4]
    3128:	89db      	ldrh	r3, [r3, #14]
    312a:	f103 33ff 	add.w	r3, r3, #4294967295
    312e:	b29a      	uxth	r2, r3
    3130:	687b      	ldr	r3, [r7, #4]
    3132:	81da      	strh	r2, [r3, #14]
    3134:	687b      	ldr	r3, [r7, #4]
    3136:	89db      	ldrh	r3, [r3, #14]
    3138:	827b      	strh	r3, [r7, #18]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    313a:	8a7b      	ldrh	r3, [r7, #18]
    313c:	2b00      	cmp	r3, #0
    313e:	d131      	bne.n	31a4 <pbuf_free+0xb0>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    3140:	687b      	ldr	r3, [r7, #4]
    3142:	681b      	ldr	r3, [r3, #0]
    3144:	60fb      	str	r3, [r7, #12]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    3146:	687b      	ldr	r3, [r7, #4]
    3148:	7b1b      	ldrb	r3, [r3, #12]
    314a:	817b      	strh	r3, [r7, #10]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    314c:	687b      	ldr	r3, [r7, #4]
    314e:	7b5b      	ldrb	r3, [r3, #13]
    3150:	f003 0302 	and.w	r3, r3, #2
    3154:	2b00      	cmp	r3, #0
    3156:	d006      	beq.n	3166 <pbuf_free+0x72>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
    3158:	687b      	ldr	r3, [r7, #4]
    315a:	617b      	str	r3, [r7, #20]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
    315c:	697b      	ldr	r3, [r7, #20]
    315e:	691b      	ldr	r3, [r3, #16]
    3160:	6878      	ldr	r0, [r7, #4]
    3162:	4798      	blx	r3
    3164:	e017      	b.n	3196 <pbuf_free+0xa2>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    3166:	897b      	ldrh	r3, [r7, #10]
    3168:	2b03      	cmp	r3, #3
    316a:	d105      	bne.n	3178 <pbuf_free+0x84>
          memp_free(MEMP_PBUF_POOL, p);
    316c:	f04f 0006 	mov.w	r0, #6
    3170:	6879      	ldr	r1, [r7, #4]
    3172:	f7ff fc13 	bl	299c <memp_free>
    3176:	e00e      	b.n	3196 <pbuf_free+0xa2>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    3178:	897b      	ldrh	r3, [r7, #10]
    317a:	2b01      	cmp	r3, #1
    317c:	d002      	beq.n	3184 <pbuf_free+0x90>
    317e:	897b      	ldrh	r3, [r7, #10]
    3180:	2b02      	cmp	r3, #2
    3182:	d105      	bne.n	3190 <pbuf_free+0x9c>
          memp_free(MEMP_PBUF, p);
    3184:	f04f 0005 	mov.w	r0, #5
    3188:	6879      	ldr	r1, [r7, #4]
    318a:	f7ff fc07 	bl	299c <memp_free>
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    318e:	e002      	b.n	3196 <pbuf_free+0xa2>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
    3190:	6878      	ldr	r0, [r7, #4]
    3192:	f7fe ffc5 	bl	2120 <mem_free>
        }
      }
      count++;
    3196:	7c7b      	ldrb	r3, [r7, #17]
    3198:	f103 0301 	add.w	r3, r3, #1
    319c:	747b      	strb	r3, [r7, #17]
      /* proceed to next pbuf */
      p = q;
    319e:	68fb      	ldr	r3, [r7, #12]
    31a0:	607b      	str	r3, [r7, #4]
    31a2:	e002      	b.n	31aa <pbuf_free+0xb6>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
    31a4:	f04f 0300 	mov.w	r3, #0
    31a8:	607b      	str	r3, [r7, #4]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    31aa:	687b      	ldr	r3, [r7, #4]
    31ac:	2b00      	cmp	r3, #0
    31ae:	d1ba      	bne.n	3126 <pbuf_free+0x32>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
    31b0:	7c7b      	ldrb	r3, [r7, #17]
}
    31b2:	4618      	mov	r0, r3
    31b4:	f107 0718 	add.w	r7, r7, #24
    31b8:	46bd      	mov	sp, r7
    31ba:	bd80      	pop	{r7, pc}

000031bc <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
    31bc:	b480      	push	{r7}
    31be:	b085      	sub	sp, #20
    31c0:	af00      	add	r7, sp, #0
    31c2:	6078      	str	r0, [r7, #4]
  u8_t len;

  len = 0;
    31c4:	f04f 0300 	mov.w	r3, #0
    31c8:	73fb      	strb	r3, [r7, #15]
  while (p != NULL) {
    31ca:	e006      	b.n	31da <pbuf_clen+0x1e>
    ++len;
    31cc:	7bfb      	ldrb	r3, [r7, #15]
    31ce:	f103 0301 	add.w	r3, r3, #1
    31d2:	73fb      	strb	r3, [r7, #15]
    p = p->next;
    31d4:	687b      	ldr	r3, [r7, #4]
    31d6:	681b      	ldr	r3, [r3, #0]
    31d8:	607b      	str	r3, [r7, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    31da:	687b      	ldr	r3, [r7, #4]
    31dc:	2b00      	cmp	r3, #0
    31de:	d1f5      	bne.n	31cc <pbuf_clen+0x10>
    ++len;
    p = p->next;
  }
  return len;
    31e0:	7bfb      	ldrb	r3, [r7, #15]
}
    31e2:	4618      	mov	r0, r3
    31e4:	f107 0714 	add.w	r7, r7, #20
    31e8:	46bd      	mov	sp, r7
    31ea:	bc80      	pop	{r7}
    31ec:	4770      	bx	lr
    31ee:	bf00      	nop

000031f0 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
    31f0:	b480      	push	{r7}
    31f2:	b083      	sub	sp, #12
    31f4:	af00      	add	r7, sp, #0
    31f6:	6078      	str	r0, [r7, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    31f8:	687b      	ldr	r3, [r7, #4]
    31fa:	2b00      	cmp	r3, #0
    31fc:	d006      	beq.n	320c <pbuf_ref+0x1c>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    31fe:	687b      	ldr	r3, [r7, #4]
    3200:	89db      	ldrh	r3, [r3, #14]
    3202:	f103 0301 	add.w	r3, r3, #1
    3206:	b29a      	uxth	r2, r3
    3208:	687b      	ldr	r3, [r7, #4]
    320a:	81da      	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
  }
}
    320c:	f107 070c 	add.w	r7, r7, #12
    3210:	46bd      	mov	sp, r7
    3212:	bc80      	pop	{r7}
    3214:	4770      	bx	lr
    3216:	bf00      	nop

00003218 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    3218:	b480      	push	{r7}
    321a:	b085      	sub	sp, #20
    321c:	af00      	add	r7, sp, #0
    321e:	6078      	str	r0, [r7, #4]
    3220:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    3222:	687b      	ldr	r3, [r7, #4]
    3224:	2b00      	cmp	r3, #0
    3226:	d01f      	beq.n	3268 <pbuf_cat+0x50>
    3228:	683b      	ldr	r3, [r7, #0]
    322a:	2b00      	cmp	r3, #0
    322c:	d01c      	beq.n	3268 <pbuf_cat+0x50>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    322e:	687b      	ldr	r3, [r7, #4]
    3230:	60fb      	str	r3, [r7, #12]
    3232:	e00a      	b.n	324a <pbuf_cat+0x32>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    3234:	68fb      	ldr	r3, [r7, #12]
    3236:	891a      	ldrh	r2, [r3, #8]
    3238:	683b      	ldr	r3, [r7, #0]
    323a:	891b      	ldrh	r3, [r3, #8]
    323c:	4413      	add	r3, r2
    323e:	b29a      	uxth	r2, r3
    3240:	68fb      	ldr	r3, [r7, #12]
    3242:	811a      	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    3244:	68fb      	ldr	r3, [r7, #12]
    3246:	681b      	ldr	r3, [r3, #0]
    3248:	60fb      	str	r3, [r7, #12]
    324a:	68fb      	ldr	r3, [r7, #12]
    324c:	681b      	ldr	r3, [r3, #0]
    324e:	2b00      	cmp	r3, #0
    3250:	d1f0      	bne.n	3234 <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    3252:	68fb      	ldr	r3, [r7, #12]
    3254:	891a      	ldrh	r2, [r3, #8]
    3256:	683b      	ldr	r3, [r7, #0]
    3258:	891b      	ldrh	r3, [r3, #8]
    325a:	4413      	add	r3, r2
    325c:	b29a      	uxth	r2, r3
    325e:	68fb      	ldr	r3, [r7, #12]
    3260:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    3262:	68fb      	ldr	r3, [r7, #12]
    3264:	683a      	ldr	r2, [r7, #0]
    3266:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    3268:	f107 0714 	add.w	r7, r7, #20
    326c:	46bd      	mov	sp, r7
    326e:	bc80      	pop	{r7}
    3270:	4770      	bx	lr
    3272:	bf00      	nop

00003274 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    3274:	b580      	push	{r7, lr}
    3276:	b082      	sub	sp, #8
    3278:	af00      	add	r7, sp, #0
    327a:	6078      	str	r0, [r7, #4]
    327c:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
    327e:	6878      	ldr	r0, [r7, #4]
    3280:	6839      	ldr	r1, [r7, #0]
    3282:	f7ff ffc9 	bl	3218 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
    3286:	6838      	ldr	r0, [r7, #0]
    3288:	f7ff ffb2 	bl	31f0 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    328c:	f107 0708 	add.w	r7, r7, #8
    3290:	46bd      	mov	sp, r7
    3292:	bd80      	pop	{r7, pc}

00003294 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    3294:	b580      	push	{r7, lr}
    3296:	b084      	sub	sp, #16
    3298:	af00      	add	r7, sp, #0
    329a:	6078      	str	r0, [r7, #4]
    329c:	6039      	str	r1, [r7, #0]
  u16_t offset_to=0, offset_from=0, len;
    329e:	f04f 0300 	mov.w	r3, #0
    32a2:	817b      	strh	r3, [r7, #10]
    32a4:	f04f 0300 	mov.w	r3, #0
    32a8:	81bb      	strh	r3, [r7, #12]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    32aa:	687b      	ldr	r3, [r7, #4]
    32ac:	2b00      	cmp	r3, #0
    32ae:	d008      	beq.n	32c2 <pbuf_copy+0x2e>
    32b0:	683b      	ldr	r3, [r7, #0]
    32b2:	2b00      	cmp	r3, #0
    32b4:	d005      	beq.n	32c2 <pbuf_copy+0x2e>
    32b6:	687b      	ldr	r3, [r7, #4]
    32b8:	891a      	ldrh	r2, [r3, #8]
    32ba:	683b      	ldr	r3, [r7, #0]
    32bc:	891b      	ldrh	r3, [r3, #8]
    32be:	429a      	cmp	r2, r3
    32c0:	d202      	bcs.n	32c8 <pbuf_copy+0x34>
    32c2:	f04f 03f2 	mov.w	r3, #242	; 0xf2
    32c6:	e06c      	b.n	33a2 <pbuf_copy+0x10e>
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    32c8:	687b      	ldr	r3, [r7, #4]
    32ca:	895b      	ldrh	r3, [r3, #10]
    32cc:	461a      	mov	r2, r3
    32ce:	897b      	ldrh	r3, [r7, #10]
    32d0:	ebc3 0202 	rsb	r2, r3, r2
    32d4:	683b      	ldr	r3, [r7, #0]
    32d6:	895b      	ldrh	r3, [r3, #10]
    32d8:	4619      	mov	r1, r3
    32da:	89bb      	ldrh	r3, [r7, #12]
    32dc:	ebc3 0301 	rsb	r3, r3, r1
    32e0:	429a      	cmp	r2, r3
    32e2:	db06      	blt.n	32f2 <pbuf_copy+0x5e>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    32e4:	683b      	ldr	r3, [r7, #0]
    32e6:	895a      	ldrh	r2, [r3, #10]
    32e8:	89bb      	ldrh	r3, [r7, #12]
    32ea:	ebc3 0302 	rsb	r3, r3, r2
    32ee:	81fb      	strh	r3, [r7, #14]
    32f0:	e005      	b.n	32fe <pbuf_copy+0x6a>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    32f2:	687b      	ldr	r3, [r7, #4]
    32f4:	895a      	ldrh	r2, [r3, #10]
    32f6:	897b      	ldrh	r3, [r7, #10]
    32f8:	ebc3 0302 	rsb	r3, r3, r2
    32fc:	81fb      	strh	r3, [r7, #14]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    32fe:	687b      	ldr	r3, [r7, #4]
    3300:	685a      	ldr	r2, [r3, #4]
    3302:	897b      	ldrh	r3, [r7, #10]
    3304:	eb02 0103 	add.w	r1, r2, r3
    3308:	683b      	ldr	r3, [r7, #0]
    330a:	685a      	ldr	r2, [r3, #4]
    330c:	89bb      	ldrh	r3, [r7, #12]
    330e:	441a      	add	r2, r3
    3310:	89fb      	ldrh	r3, [r7, #14]
    3312:	4608      	mov	r0, r1
    3314:	4611      	mov	r1, r2
    3316:	461a      	mov	r2, r3
    3318:	f005 fc84 	bl	8c24 <memcpy>
    offset_to += len;
    331c:	897a      	ldrh	r2, [r7, #10]
    331e:	89fb      	ldrh	r3, [r7, #14]
    3320:	4413      	add	r3, r2
    3322:	817b      	strh	r3, [r7, #10]
    offset_from += len;
    3324:	89ba      	ldrh	r2, [r7, #12]
    3326:	89fb      	ldrh	r3, [r7, #14]
    3328:	4413      	add	r3, r2
    332a:	81bb      	strh	r3, [r7, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
    332c:	687b      	ldr	r3, [r7, #4]
    332e:	895b      	ldrh	r3, [r3, #10]
    3330:	897a      	ldrh	r2, [r7, #10]
    3332:	429a      	cmp	r2, r3
    3334:	d105      	bne.n	3342 <pbuf_copy+0xae>
      /* on to next p_to (if any) */
      offset_to = 0;
    3336:	f04f 0300 	mov.w	r3, #0
    333a:	817b      	strh	r3, [r7, #10]
      p_to = p_to->next;
    333c:	687b      	ldr	r3, [r7, #4]
    333e:	681b      	ldr	r3, [r3, #0]
    3340:	607b      	str	r3, [r7, #4]
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
    3342:	683b      	ldr	r3, [r7, #0]
    3344:	895b      	ldrh	r3, [r3, #10]
    3346:	89ba      	ldrh	r2, [r7, #12]
    3348:	429a      	cmp	r2, r3
    334a:	d305      	bcc.n	3358 <pbuf_copy+0xc4>
      /* on to next p_from (if any) */
      offset_from = 0;
    334c:	f04f 0300 	mov.w	r3, #0
    3350:	81bb      	strh	r3, [r7, #12]
      p_from = p_from->next;
    3352:	683b      	ldr	r3, [r7, #0]
    3354:	681b      	ldr	r3, [r3, #0]
    3356:	603b      	str	r3, [r7, #0]
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    3358:	683b      	ldr	r3, [r7, #0]
    335a:	2b00      	cmp	r3, #0
    335c:	d00c      	beq.n	3378 <pbuf_copy+0xe4>
    335e:	683b      	ldr	r3, [r7, #0]
    3360:	895a      	ldrh	r2, [r3, #10]
    3362:	683b      	ldr	r3, [r7, #0]
    3364:	891b      	ldrh	r3, [r3, #8]
    3366:	429a      	cmp	r2, r3
    3368:	d106      	bne.n	3378 <pbuf_copy+0xe4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    336a:	683b      	ldr	r3, [r7, #0]
    336c:	681b      	ldr	r3, [r3, #0]
    336e:	2b00      	cmp	r3, #0
    3370:	d002      	beq.n	3378 <pbuf_copy+0xe4>
    3372:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    3376:	e014      	b.n	33a2 <pbuf_copy+0x10e>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    3378:	687b      	ldr	r3, [r7, #4]
    337a:	2b00      	cmp	r3, #0
    337c:	d00c      	beq.n	3398 <pbuf_copy+0x104>
    337e:	687b      	ldr	r3, [r7, #4]
    3380:	895a      	ldrh	r2, [r3, #10]
    3382:	687b      	ldr	r3, [r7, #4]
    3384:	891b      	ldrh	r3, [r3, #8]
    3386:	429a      	cmp	r2, r3
    3388:	d106      	bne.n	3398 <pbuf_copy+0x104>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    338a:	687b      	ldr	r3, [r7, #4]
    338c:	681b      	ldr	r3, [r3, #0]
    338e:	2b00      	cmp	r3, #0
    3390:	d002      	beq.n	3398 <pbuf_copy+0x104>
    3392:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    3396:	e004      	b.n	33a2 <pbuf_copy+0x10e>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    3398:	683b      	ldr	r3, [r7, #0]
    339a:	2b00      	cmp	r3, #0
    339c:	d194      	bne.n	32c8 <pbuf_copy+0x34>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
    339e:	f04f 0300 	mov.w	r3, #0
    33a2:	b25b      	sxtb	r3, r3
}
    33a4:	4618      	mov	r0, r3
    33a6:	f107 0710 	add.w	r7, r7, #16
    33aa:	46bd      	mov	sp, r7
    33ac:	bd80      	pop	{r7, pc}
    33ae:	bf00      	nop

000033b0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    33b0:	b580      	push	{r7, lr}
    33b2:	b086      	sub	sp, #24
    33b4:	af00      	add	r7, sp, #0
    33b6:	6078      	str	r0, [r7, #4]
    33b8:	6039      	str	r1, [r7, #0]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
    33ba:	f04f 0300 	mov.w	r3, #0
    33be:	75fb      	strb	r3, [r7, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
    33c0:	687b      	ldr	r3, [r7, #4]
    33c2:	685b      	ldr	r3, [r3, #4]
    33c4:	613b      	str	r3, [r7, #16]
  proto = IPH_PROTO(iphdr);
    33c6:	693b      	ldr	r3, [r7, #16]
    33c8:	7a5b      	ldrb	r3, [r3, #9]
    33ca:	82bb      	strh	r3, [r7, #20]

  prev = NULL;
    33cc:	f04f 0300 	mov.w	r3, #0
    33d0:	60fb      	str	r3, [r7, #12]
  pcb = raw_pcbs;
    33d2:	f243 1338 	movw	r3, #12600	; 0x3138
    33d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33da:	681b      	ldr	r3, [r3, #0]
    33dc:	60bb      	str	r3, [r7, #8]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    33de:	e049      	b.n	3474 <raw_input+0xc4>
    if ((pcb->protocol == proto) &&
    33e0:	68bb      	ldr	r3, [r7, #8]
    33e2:	7c1b      	ldrb	r3, [r3, #16]
    33e4:	461a      	mov	r2, r3
    33e6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
    33ea:	429a      	cmp	r2, r3
    33ec:	d13d      	bne.n	346a <raw_input+0xba>
        (ip_addr_isany(&pcb->local_ip) ||
    33ee:	68bb      	ldr	r3, [r7, #8]
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
    33f0:	2b00      	cmp	r3, #0
    33f2:	d00c      	beq.n	340e <raw_input+0x5e>
        (ip_addr_isany(&pcb->local_ip) ||
    33f4:	68bb      	ldr	r3, [r7, #8]
    33f6:	681b      	ldr	r3, [r3, #0]
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
    33f8:	2b00      	cmp	r3, #0
    33fa:	d008      	beq.n	340e <raw_input+0x5e>
        (ip_addr_isany(&pcb->local_ip) ||
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    33fc:	68bb      	ldr	r3, [r7, #8]
    33fe:	681a      	ldr	r2, [r3, #0]
    3400:	f247 131c 	movw	r3, #28956	; 0x711c
    3404:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3408:	681b      	ldr	r3, [r3, #0]
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
    340a:	429a      	cmp	r2, r3
    340c:	d12d      	bne.n	346a <raw_input+0xba>
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
    340e:	68bb      	ldr	r3, [r7, #8]
    3410:	695b      	ldr	r3, [r3, #20]
    3412:	2b00      	cmp	r3, #0
    3414:	d029      	beq.n	346a <raw_input+0xba>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    3416:	68bb      	ldr	r3, [r7, #8]
    3418:	f8d3 c014 	ldr.w	ip, [r3, #20]
    341c:	68bb      	ldr	r3, [r7, #8]
    341e:	699b      	ldr	r3, [r3, #24]
    3420:	4618      	mov	r0, r3
    3422:	68b9      	ldr	r1, [r7, #8]
    3424:	687a      	ldr	r2, [r7, #4]
    3426:	f247 1314 	movw	r3, #28948	; 0x7114
    342a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    342e:	47e0      	blx	ip
    3430:	4603      	mov	r3, r0
    3432:	2b00      	cmp	r3, #0
    3434:	d019      	beq.n	346a <raw_input+0xba>
            /* receive function ate the packet */
            p = NULL;
    3436:	f04f 0300 	mov.w	r3, #0
    343a:	607b      	str	r3, [r7, #4]
            eaten = 1;
    343c:	f04f 0301 	mov.w	r3, #1
    3440:	75fb      	strb	r3, [r7, #23]
            if (prev != NULL) {
    3442:	68fb      	ldr	r3, [r7, #12]
    3444:	2b00      	cmp	r3, #0
    3446:	d010      	beq.n	346a <raw_input+0xba>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    3448:	68bb      	ldr	r3, [r7, #8]
    344a:	68da      	ldr	r2, [r3, #12]
    344c:	68fb      	ldr	r3, [r7, #12]
    344e:	60da      	str	r2, [r3, #12]
              pcb->next = raw_pcbs;
    3450:	f243 1338 	movw	r3, #12600	; 0x3138
    3454:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3458:	681a      	ldr	r2, [r3, #0]
    345a:	68bb      	ldr	r3, [r7, #8]
    345c:	60da      	str	r2, [r3, #12]
              raw_pcbs = pcb;
    345e:	f243 1338 	movw	r3, #12600	; 0x3138
    3462:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3466:	68ba      	ldr	r2, [r7, #8]
    3468:	601a      	str	r2, [r3, #0]
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    346a:	68bb      	ldr	r3, [r7, #8]
    346c:	60fb      	str	r3, [r7, #12]
    pcb = pcb->next;
    346e:	68bb      	ldr	r3, [r7, #8]
    3470:	68db      	ldr	r3, [r3, #12]
    3472:	60bb      	str	r3, [r7, #8]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    3474:	7dfb      	ldrb	r3, [r7, #23]
    3476:	2b00      	cmp	r3, #0
    3478:	d102      	bne.n	3480 <raw_input+0xd0>
    347a:	68bb      	ldr	r3, [r7, #8]
    347c:	2b00      	cmp	r3, #0
    347e:	d1af      	bne.n	33e0 <raw_input+0x30>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
    3480:	7dfb      	ldrb	r3, [r7, #23]
}
    3482:	4618      	mov	r0, r3
    3484:	f107 0718 	add.w	r7, r7, #24
    3488:	46bd      	mov	sp, r7
    348a:	bd80      	pop	{r7, pc}

0000348c <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
    348c:	b480      	push	{r7}
    348e:	af00      	add	r7, sp, #0
#endif /* MEMP_STATS */
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
    3490:	46bd      	mov	sp, r7
    3492:	bc80      	pop	{r7}
    3494:	4770      	bx	lr
    3496:	bf00      	nop

00003498 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
    3498:	b580      	push	{r7, lr}
    349a:	b082      	sub	sp, #8
    349c:	af00      	add	r7, sp, #0
    349e:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
    34a0:	f001 fe2e 	bl	5100 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    34a4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    34a8:	f243 4199 	movw	r1, #13465	; 0x3499
    34ac:	f2c0 0100 	movt	r1, #0
    34b0:	f04f 0200 	mov.w	r2, #0
    34b4:	f000 f838 	bl	3528 <sys_timeout>
}
    34b8:	f107 0708 	add.w	r7, r7, #8
    34bc:	46bd      	mov	sp, r7
    34be:	bd80      	pop	{r7, pc}

000034c0 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
    34c0:	b580      	push	{r7, lr}
    34c2:	b082      	sub	sp, #8
    34c4:	af00      	add	r7, sp, #0
    34c6:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
    34c8:	f7fd fdac 	bl	1024 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    34cc:	f241 3088 	movw	r0, #5000	; 0x1388
    34d0:	f243 41c1 	movw	r1, #13505	; 0x34c1
    34d4:	f2c0 0100 	movt	r1, #0
    34d8:	f04f 0200 	mov.w	r2, #0
    34dc:	f000 f824 	bl	3528 <sys_timeout>
}
    34e0:	f107 0708 	add.w	r7, r7, #8
    34e4:	46bd      	mov	sp, r7
    34e6:	bd80      	pop	{r7, pc}

000034e8 <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
    34e8:	b580      	push	{r7, lr}
    34ea:	af00      	add	r7, sp, #0
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    34ec:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    34f0:	f243 4199 	movw	r1, #13465	; 0x3499
    34f4:	f2c0 0100 	movt	r1, #0
    34f8:	f04f 0200 	mov.w	r2, #0
    34fc:	f000 f814 	bl	3528 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    3500:	f241 3088 	movw	r0, #5000	; 0x1388
    3504:	f243 41c1 	movw	r1, #13505	; 0x34c1
    3508:	f2c0 0100 	movt	r1, #0
    350c:	f04f 0200 	mov.w	r2, #0
    3510:	f000 f80a 	bl	3528 <sys_timeout>
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
    3514:	f7fd fa86 	bl	a24 <sys_now>
    3518:	4602      	mov	r2, r0
    351a:	f243 1340 	movw	r3, #12608	; 0x3140
    351e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3522:	601a      	str	r2, [r3, #0]
#endif
}
    3524:	bd80      	pop	{r7, pc}
    3526:	bf00      	nop

00003528 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    3528:	b580      	push	{r7, lr}
    352a:	b086      	sub	sp, #24
    352c:	af00      	add	r7, sp, #0
    352e:	60f8      	str	r0, [r7, #12]
    3530:	60b9      	str	r1, [r7, #8]
    3532:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    3534:	f04f 0004 	mov.w	r0, #4
    3538:	f7ff f986 	bl	2848 <memp_malloc>
    353c:	4603      	mov	r3, r0
    353e:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
    3540:	693b      	ldr	r3, [r7, #16]
    3542:	2b00      	cmp	r3, #0
    3544:	d077      	beq.n	3636 <sys_timeout+0x10e>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
    3546:	693b      	ldr	r3, [r7, #16]
    3548:	f04f 0200 	mov.w	r2, #0
    354c:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
    354e:	693b      	ldr	r3, [r7, #16]
    3550:	68ba      	ldr	r2, [r7, #8]
    3552:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
    3554:	693b      	ldr	r3, [r7, #16]
    3556:	687a      	ldr	r2, [r7, #4]
    3558:	60da      	str	r2, [r3, #12]
  timeout->time = msecs;
    355a:	693b      	ldr	r3, [r7, #16]
    355c:	68fa      	ldr	r2, [r7, #12]
    355e:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
    3560:	f243 133c 	movw	r3, #12604	; 0x313c
    3564:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3568:	681b      	ldr	r3, [r3, #0]
    356a:	2b00      	cmp	r3, #0
    356c:	d106      	bne.n	357c <sys_timeout+0x54>
    next_timeout = timeout;
    356e:	f243 133c 	movw	r3, #12604	; 0x313c
    3572:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3576:	693a      	ldr	r2, [r7, #16]
    3578:	601a      	str	r2, [r3, #0]
    return;
    357a:	e05d      	b.n	3638 <sys_timeout+0x110>
  }

  if (next_timeout->time > msecs) {
    357c:	f243 133c 	movw	r3, #12604	; 0x313c
    3580:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3584:	681b      	ldr	r3, [r3, #0]
    3586:	685a      	ldr	r2, [r3, #4]
    3588:	68fb      	ldr	r3, [r7, #12]
    358a:	429a      	cmp	r2, r3
    358c:	d91c      	bls.n	35c8 <sys_timeout+0xa0>
    next_timeout->time -= msecs;
    358e:	f243 133c 	movw	r3, #12604	; 0x313c
    3592:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3596:	681a      	ldr	r2, [r3, #0]
    3598:	f243 133c 	movw	r3, #12604	; 0x313c
    359c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35a0:	681b      	ldr	r3, [r3, #0]
    35a2:	6859      	ldr	r1, [r3, #4]
    35a4:	68fb      	ldr	r3, [r7, #12]
    35a6:	ebc3 0301 	rsb	r3, r3, r1
    35aa:	6053      	str	r3, [r2, #4]
    timeout->next = next_timeout;
    35ac:	f243 133c 	movw	r3, #12604	; 0x313c
    35b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35b4:	681a      	ldr	r2, [r3, #0]
    35b6:	693b      	ldr	r3, [r7, #16]
    35b8:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
    35ba:	f243 133c 	movw	r3, #12604	; 0x313c
    35be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35c2:	693a      	ldr	r2, [r7, #16]
    35c4:	601a      	str	r2, [r3, #0]
    35c6:	e037      	b.n	3638 <sys_timeout+0x110>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
    35c8:	f243 133c 	movw	r3, #12604	; 0x313c
    35cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35d0:	681b      	ldr	r3, [r3, #0]
    35d2:	617b      	str	r3, [r7, #20]
    35d4:	e02b      	b.n	362e <sys_timeout+0x106>
      timeout->time -= t->time;
    35d6:	693b      	ldr	r3, [r7, #16]
    35d8:	685a      	ldr	r2, [r3, #4]
    35da:	697b      	ldr	r3, [r7, #20]
    35dc:	685b      	ldr	r3, [r3, #4]
    35de:	ebc3 0202 	rsb	r2, r3, r2
    35e2:	693b      	ldr	r3, [r7, #16]
    35e4:	605a      	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
    35e6:	697b      	ldr	r3, [r7, #20]
    35e8:	681b      	ldr	r3, [r3, #0]
    35ea:	2b00      	cmp	r3, #0
    35ec:	d006      	beq.n	35fc <sys_timeout+0xd4>
    35ee:	697b      	ldr	r3, [r7, #20]
    35f0:	681b      	ldr	r3, [r3, #0]
    35f2:	685a      	ldr	r2, [r3, #4]
    35f4:	693b      	ldr	r3, [r7, #16]
    35f6:	685b      	ldr	r3, [r3, #4]
    35f8:	429a      	cmp	r2, r3
    35fa:	d915      	bls.n	3628 <sys_timeout+0x100>
        if (t->next != NULL) {
    35fc:	697b      	ldr	r3, [r7, #20]
    35fe:	681b      	ldr	r3, [r3, #0]
    3600:	2b00      	cmp	r3, #0
    3602:	d009      	beq.n	3618 <sys_timeout+0xf0>
          t->next->time -= timeout->time;
    3604:	697b      	ldr	r3, [r7, #20]
    3606:	681b      	ldr	r3, [r3, #0]
    3608:	697a      	ldr	r2, [r7, #20]
    360a:	6812      	ldr	r2, [r2, #0]
    360c:	6851      	ldr	r1, [r2, #4]
    360e:	693a      	ldr	r2, [r7, #16]
    3610:	6852      	ldr	r2, [r2, #4]
    3612:	ebc2 0201 	rsb	r2, r2, r1
    3616:	605a      	str	r2, [r3, #4]
        }
        timeout->next = t->next;
    3618:	697b      	ldr	r3, [r7, #20]
    361a:	681a      	ldr	r2, [r3, #0]
    361c:	693b      	ldr	r3, [r7, #16]
    361e:	601a      	str	r2, [r3, #0]
        t->next = timeout;
    3620:	697b      	ldr	r3, [r7, #20]
    3622:	693a      	ldr	r2, [r7, #16]
    3624:	601a      	str	r2, [r3, #0]
        break;
    3626:	e007      	b.n	3638 <sys_timeout+0x110>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
    3628:	697b      	ldr	r3, [r7, #20]
    362a:	681b      	ldr	r3, [r3, #0]
    362c:	617b      	str	r3, [r7, #20]
    362e:	697b      	ldr	r3, [r7, #20]
    3630:	2b00      	cmp	r3, #0
    3632:	d1d0      	bne.n	35d6 <sys_timeout+0xae>
    3634:	e000      	b.n	3638 <sys_timeout+0x110>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
    3636:	bf00      	nop
        t->next = timeout;
        break;
      }
    }
  }
}
    3638:	f107 0718 	add.w	r7, r7, #24
    363c:	46bd      	mov	sp, r7
    363e:	bd80      	pop	{r7, pc}

00003640 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    3640:	b590      	push	{r4, r7, lr}
    3642:	b08d      	sub	sp, #52	; 0x34
    3644:	af02      	add	r7, sp, #8
    3646:	6078      	str	r0, [r7, #4]
    3648:	6039      	str	r1, [r7, #0]
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
    364a:	f247 0330 	movw	r3, #28720	; 0x7030
    364e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3652:	f8b3 307a 	ldrh.w	r3, [r3, #122]	; 0x7a
    3656:	f103 0301 	add.w	r3, r3, #1
    365a:	b29a      	uxth	r2, r3
    365c:	f247 0330 	movw	r3, #28720	; 0x7030
    3660:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3664:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;
    3668:	687b      	ldr	r3, [r7, #4]
    366a:	685b      	ldr	r3, [r3, #4]
    366c:	61fb      	str	r3, [r7, #28]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    366e:	687b      	ldr	r3, [r7, #4]
    3670:	891b      	ldrh	r3, [r3, #8]
    3672:	461c      	mov	r4, r3
    3674:	69fb      	ldr	r3, [r7, #28]
    3676:	781a      	ldrb	r2, [r3, #0]
    3678:	785b      	ldrb	r3, [r3, #1]
    367a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    367e:	ea43 0302 	orr.w	r3, r3, r2
    3682:	b29b      	uxth	r3, r3
    3684:	4618      	mov	r0, r3
    3686:	f7fe fc49 	bl	1f1c <lwip_ntohs>
    368a:	4603      	mov	r3, r0
    368c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3690:	b29b      	uxth	r3, r3
    3692:	f003 030f 	and.w	r3, r3, #15
    3696:	f103 0302 	add.w	r3, r3, #2
    369a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    369e:	429c      	cmp	r4, r3
    36a0:	db1e      	blt.n	36e0 <udp_input+0xa0>
    36a2:	69fb      	ldr	r3, [r7, #28]
    36a4:	781a      	ldrb	r2, [r3, #0]
    36a6:	785b      	ldrb	r3, [r3, #1]
    36a8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    36ac:	ea43 0302 	orr.w	r3, r3, r2
    36b0:	b29b      	uxth	r3, r3
    36b2:	4618      	mov	r0, r3
    36b4:	f7fe fc32 	bl	1f1c <lwip_ntohs>
    36b8:	4603      	mov	r3, r0
    36ba:	ea4f 2313 	mov.w	r3, r3, lsr #8
    36be:	b29b      	uxth	r3, r3
    36c0:	f003 030f 	and.w	r3, r3, #15
    36c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    36c8:	b29b      	uxth	r3, r3
    36ca:	f1c3 0300 	rsb	r3, r3, #0
    36ce:	b29b      	uxth	r3, r3
    36d0:	b21b      	sxth	r3, r3
    36d2:	6878      	ldr	r0, [r7, #4]
    36d4:	4619      	mov	r1, r3
    36d6:	f7ff fc91 	bl	2ffc <pbuf_header>
    36da:	4603      	mov	r3, r0
    36dc:	2b00      	cmp	r3, #0
    36de:	d021      	beq.n	3724 <udp_input+0xe4>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    36e0:	f247 0330 	movw	r3, #28720	; 0x7030
    36e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36e8:	f8b3 3082 	ldrh.w	r3, [r3, #130]	; 0x82
    36ec:	f103 0301 	add.w	r3, r3, #1
    36f0:	b29a      	uxth	r2, r3
    36f2:	f247 0330 	movw	r3, #28720	; 0x7030
    36f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36fa:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
    UDP_STATS_INC(udp.drop);
    36fe:	f247 0330 	movw	r3, #28720	; 0x7030
    3702:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3706:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
    370a:	f103 0301 	add.w	r3, r3, #1
    370e:	b29a      	uxth	r2, r3
    3710:	f247 0330 	movw	r3, #28720	; 0x7030
    3714:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3718:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    snmp_inc_udpinerrors();
    pbuf_free(p);
    371c:	6878      	ldr	r0, [r7, #4]
    371e:	f7ff fce9 	bl	30f4 <pbuf_free>
    goto end;
    3722:	e18b      	b.n	3a3c <udp_input+0x3fc>
  }

  udphdr = (struct udp_hdr *)p->payload;
    3724:	687b      	ldr	r3, [r7, #4]
    3726:	685b      	ldr	r3, [r3, #4]
    3728:	60fb      	str	r3, [r7, #12]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    372a:	f247 131c 	movw	r3, #28956	; 0x711c
    372e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3732:	681b      	ldr	r3, [r3, #0]
    3734:	4618      	mov	r0, r3
    3736:	6839      	ldr	r1, [r7, #0]
    3738:	f001 fc9c 	bl	5074 <ip4_addr_isbroadcast>
    373c:	4603      	mov	r3, r0
    373e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
    3742:	68fb      	ldr	r3, [r7, #12]
    3744:	781a      	ldrb	r2, [r3, #0]
    3746:	785b      	ldrb	r3, [r3, #1]
    3748:	ea4f 2303 	mov.w	r3, r3, lsl #8
    374c:	ea43 0302 	orr.w	r3, r3, r2
    3750:	b29b      	uxth	r3, r3
    3752:	4618      	mov	r0, r3
    3754:	f7fe fbe2 	bl	1f1c <lwip_ntohs>
    3758:	4603      	mov	r3, r0
    375a:	847b      	strh	r3, [r7, #34]	; 0x22
  dest = ntohs(udphdr->dest);
    375c:	68fb      	ldr	r3, [r7, #12]
    375e:	789a      	ldrb	r2, [r3, #2]
    3760:	78db      	ldrb	r3, [r3, #3]
    3762:	ea4f 2303 	mov.w	r3, r3, lsl #8
    3766:	ea43 0302 	orr.w	r3, r3, r2
    376a:	b29b      	uxth	r3, r3
    376c:	4618      	mov	r0, r3
    376e:	f7fe fbd5 	bl	1f1c <lwip_ntohs>
    3772:	4603      	mov	r3, r0
    3774:	84bb      	strh	r3, [r7, #36]	; 0x24
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    3776:	f04f 0300 	mov.w	r3, #0
    377a:	617b      	str	r3, [r7, #20]
    local_match = 0;
    377c:	f04f 0300 	mov.w	r3, #0
    3780:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    uncon_pcb = NULL;
    3784:	f04f 0300 	mov.w	r3, #0
    3788:	61bb      	str	r3, [r7, #24]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    378a:	f247 1310 	movw	r3, #28944	; 0x7110
    378e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3792:	681b      	ldr	r3, [r3, #0]
    3794:	613b      	str	r3, [r7, #16]
    3796:	e074      	b.n	3882 <udp_input+0x242>
      local_match = 0;
    3798:	f04f 0300 	mov.w	r3, #0
    379c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
    37a0:	693b      	ldr	r3, [r7, #16]
    37a2:	8a5b      	ldrh	r3, [r3, #18]
    37a4:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    37a6:	429a      	cmp	r2, r3
    37a8:	d126      	bne.n	37f8 <udp_input+0x1b8>
    37aa:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    37ae:	2b00      	cmp	r3, #0
    37b0:	d106      	bne.n	37c0 <udp_input+0x180>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    37b2:	693b      	ldr	r3, [r7, #16]
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
    37b4:	2b00      	cmp	r3, #0
    37b6:	d010      	beq.n	37da <udp_input+0x19a>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    37b8:	693b      	ldr	r3, [r7, #16]
    37ba:	681b      	ldr	r3, [r3, #0]
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
    37bc:	2b00      	cmp	r3, #0
    37be:	d00c      	beq.n	37da <udp_input+0x19a>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
    37c0:	693b      	ldr	r3, [r7, #16]
    37c2:	681a      	ldr	r2, [r3, #0]
    37c4:	f247 131c 	movw	r3, #28956	; 0x711c
    37c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37cc:	681b      	ldr	r3, [r3, #0]
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
    37ce:	429a      	cmp	r2, r3
    37d0:	d003      	beq.n	37da <udp_input+0x19a>
    37d2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    37d6:	2b00      	cmp	r3, #0
    37d8:	d00e      	beq.n	37f8 <udp_input+0x1b8>
#if IP_SOF_BROADCAST_RECV
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
    37da:	f04f 0301 	mov.w	r3, #1
    37de:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        if ((uncon_pcb == NULL) && 
    37e2:	69bb      	ldr	r3, [r7, #24]
    37e4:	2b00      	cmp	r3, #0
    37e6:	d107      	bne.n	37f8 <udp_input+0x1b8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    37e8:	693b      	ldr	r3, [r7, #16]
    37ea:	7c1b      	ldrb	r3, [r3, #16]
    37ec:	f003 0304 	and.w	r3, r3, #4
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
        if ((uncon_pcb == NULL) && 
    37f0:	2b00      	cmp	r3, #0
    37f2:	d101      	bne.n	37f8 <udp_input+0x1b8>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
    37f4:	693b      	ldr	r3, [r7, #16]
    37f6:	61bb      	str	r3, [r7, #24]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    37f8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    37fc:	2b00      	cmp	r3, #0
    37fe:	d03b      	beq.n	3878 <udp_input+0x238>
          (pcb->remote_port == src) &&
    3800:	693b      	ldr	r3, [r7, #16]
    3802:	8a9b      	ldrh	r3, [r3, #20]
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    3804:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
    3806:	429a      	cmp	r2, r3
    3808:	d136      	bne.n	3878 <udp_input+0x238>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
    380a:	693b      	ldr	r3, [r7, #16]
    380c:	f103 0304 	add.w	r3, r3, #4
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    3810:	2b00      	cmp	r3, #0
    3812:	d00c      	beq.n	382e <udp_input+0x1ee>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
    3814:	693b      	ldr	r3, [r7, #16]
    3816:	685b      	ldr	r3, [r3, #4]
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    3818:	2b00      	cmp	r3, #0
    381a:	d008      	beq.n	382e <udp_input+0x1ee>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    381c:	693b      	ldr	r3, [r7, #16]
    381e:	685a      	ldr	r2, [r3, #4]
    3820:	f247 1314 	movw	r3, #28948	; 0x7114
    3824:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3828:	681b      	ldr	r3, [r3, #0]
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    382a:	429a      	cmp	r2, r3
    382c:	d124      	bne.n	3878 <udp_input+0x238>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
    382e:	697b      	ldr	r3, [r7, #20]
    3830:	2b00      	cmp	r3, #0
    3832:	d011      	beq.n	3858 <udp_input+0x218>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
    3834:	693b      	ldr	r3, [r7, #16]
    3836:	68da      	ldr	r2, [r3, #12]
    3838:	697b      	ldr	r3, [r7, #20]
    383a:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
    383c:	f247 1310 	movw	r3, #28944	; 0x7110
    3840:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3844:	681a      	ldr	r2, [r3, #0]
    3846:	693b      	ldr	r3, [r7, #16]
    3848:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
    384a:	f247 1310 	movw	r3, #28944	; 0x7110
    384e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3852:	693a      	ldr	r2, [r7, #16]
    3854:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
    3856:	e017      	b.n	3888 <udp_input+0x248>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
    3858:	f247 0330 	movw	r3, #28720	; 0x7030
    385c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3860:	f8b3 308e 	ldrh.w	r3, [r3, #142]	; 0x8e
    3864:	f103 0301 	add.w	r3, r3, #1
    3868:	b29a      	uxth	r2, r3
    386a:	f247 0330 	movw	r3, #28720	; 0x7030
    386e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3872:	f8a3 208e 	strh.w	r2, [r3, #142]	; 0x8e
        }
        break;
    3876:	e007      	b.n	3888 <udp_input+0x248>
      }
      prev = pcb;
    3878:	693b      	ldr	r3, [r7, #16]
    387a:	617b      	str	r3, [r7, #20]
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    387c:	693b      	ldr	r3, [r7, #16]
    387e:	68db      	ldr	r3, [r3, #12]
    3880:	613b      	str	r3, [r7, #16]
    3882:	693b      	ldr	r3, [r7, #16]
    3884:	2b00      	cmp	r3, #0
    3886:	d187      	bne.n	3798 <udp_input+0x158>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
    3888:	693b      	ldr	r3, [r7, #16]
    388a:	2b00      	cmp	r3, #0
    388c:	d101      	bne.n	3892 <udp_input+0x252>
      pcb = uncon_pcb;
    388e:	69bb      	ldr	r3, [r7, #24]
    3890:	613b      	str	r3, [r7, #16]
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    3892:	693b      	ldr	r3, [r7, #16]
    3894:	2b00      	cmp	r3, #0
    3896:	d109      	bne.n	38ac <udp_input+0x26c>
    3898:	683b      	ldr	r3, [r7, #0]
    389a:	685a      	ldr	r2, [r3, #4]
    389c:	f247 131c 	movw	r3, #28956	; 0x711c
    38a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38a4:	681b      	ldr	r3, [r3, #0]
    38a6:	429a      	cmp	r2, r3
    38a8:	f040 80c5 	bne.w	3a36 <udp_input+0x3f6>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
    38ac:	68fb      	ldr	r3, [r7, #12]
    38ae:	799a      	ldrb	r2, [r3, #6]
    38b0:	79db      	ldrb	r3, [r3, #7]
    38b2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    38b6:	ea43 0302 	orr.w	r3, r3, r2
    38ba:	b29b      	uxth	r3, r3
    38bc:	2b00      	cmp	r3, #0
    38be:	d034      	beq.n	392a <udp_input+0x2ea>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    38c0:	687b      	ldr	r3, [r7, #4]
    38c2:	891b      	ldrh	r3, [r3, #8]
    38c4:	9300      	str	r3, [sp, #0]
    38c6:	6878      	ldr	r0, [r7, #4]
    38c8:	f247 1114 	movw	r1, #28948	; 0x7114
    38cc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    38d0:	f247 121c 	movw	r2, #28956	; 0x711c
    38d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    38d8:	f04f 0311 	mov.w	r3, #17
    38dc:	f000 fe00 	bl	44e0 <inet_chksum_pseudo>
    38e0:	4603      	mov	r3, r0
    38e2:	2b00      	cmp	r3, #0
    38e4:	d021      	beq.n	392a <udp_input+0x2ea>
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
    38e6:	f247 0330 	movw	r3, #28720	; 0x7030
    38ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38ee:	f8b3 3080 	ldrh.w	r3, [r3, #128]	; 0x80
    38f2:	f103 0301 	add.w	r3, r3, #1
    38f6:	b29a      	uxth	r2, r3
    38f8:	f247 0330 	movw	r3, #28720	; 0x7030
    38fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3900:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
          UDP_STATS_INC(udp.drop);
    3904:	f247 0330 	movw	r3, #28720	; 0x7030
    3908:	f2c2 0300 	movt	r3, #8192	; 0x2000
    390c:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
    3910:	f103 0301 	add.w	r3, r3, #1
    3914:	b29a      	uxth	r2, r3
    3916:	f247 0330 	movw	r3, #28720	; 0x7030
    391a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    391e:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
          snmp_inc_udpinerrors();
          pbuf_free(p);
    3922:	6878      	ldr	r0, [r7, #4]
    3924:	f7ff fbe6 	bl	30f4 <pbuf_free>
          goto end;
    3928:	e088      	b.n	3a3c <udp_input+0x3fc>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
    392a:	6878      	ldr	r0, [r7, #4]
    392c:	f06f 0107 	mvn.w	r1, #7
    3930:	f7ff fb64 	bl	2ffc <pbuf_header>
    3934:	4603      	mov	r3, r0
    3936:	2b00      	cmp	r3, #0
    3938:	d012      	beq.n	3960 <udp_input+0x320>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
    393a:	f247 0330 	movw	r3, #28720	; 0x7030
    393e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3942:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
    3946:	f103 0301 	add.w	r3, r3, #1
    394a:	b29a      	uxth	r2, r3
    394c:	f247 0330 	movw	r3, #28720	; 0x7030
    3950:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3954:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
      snmp_inc_udpinerrors();
      pbuf_free(p);
    3958:	6878      	ldr	r0, [r7, #4]
    395a:	f7ff fbcb 	bl	30f4 <pbuf_free>
      goto end;
    395e:	e06d      	b.n	3a3c <udp_input+0x3fc>
    }
    if (pcb != NULL) {
    3960:	693b      	ldr	r3, [r7, #16]
    3962:	2b00      	cmp	r3, #0
    3964:	d017      	beq.n	3996 <udp_input+0x356>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
    3966:	693b      	ldr	r3, [r7, #16]
    3968:	699b      	ldr	r3, [r3, #24]
    396a:	2b00      	cmp	r3, #0
    396c:	d00f      	beq.n	398e <udp_input+0x34e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    396e:	693b      	ldr	r3, [r7, #16]
    3970:	f8d3 c018 	ldr.w	ip, [r3, #24]
    3974:	693b      	ldr	r3, [r7, #16]
    3976:	69db      	ldr	r3, [r3, #28]
    3978:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
    397a:	9200      	str	r2, [sp, #0]
    397c:	4618      	mov	r0, r3
    397e:	6939      	ldr	r1, [r7, #16]
    3980:	687a      	ldr	r2, [r7, #4]
    3982:	f247 1314 	movw	r3, #28948	; 0x7114
    3986:	f2c2 0300 	movt	r3, #8192	; 0x2000
    398a:	47e0      	blx	ip
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    398c:	e056      	b.n	3a3c <udp_input+0x3fc>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
    398e:	6878      	ldr	r0, [r7, #4]
    3990:	f7ff fbb0 	bl	30f4 <pbuf_free>
        goto end;
    3994:	e052      	b.n	3a3c <udp_input+0x3fc>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    3996:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    399a:	2b00      	cmp	r3, #0
    399c:	d129      	bne.n	39f2 <udp_input+0x3b2>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    399e:	f247 131c 	movw	r3, #28956	; 0x711c
    39a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    39a6:	681b      	ldr	r3, [r3, #0]
    39a8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    39ac:	2be0      	cmp	r3, #224	; 0xe0
    39ae:	d020      	beq.n	39f2 <udp_input+0x3b2>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    39b0:	69fb      	ldr	r3, [r7, #28]
    39b2:	781a      	ldrb	r2, [r3, #0]
    39b4:	785b      	ldrb	r3, [r3, #1]
    39b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    39ba:	ea43 0302 	orr.w	r3, r3, r2
    39be:	b29b      	uxth	r3, r3
    39c0:	4618      	mov	r0, r3
    39c2:	f7fe faab 	bl	1f1c <lwip_ntohs>
    39c6:	4603      	mov	r3, r0
    39c8:	ea4f 2313 	mov.w	r3, r3, lsr #8
    39cc:	b29b      	uxth	r3, r3
    39ce:	f003 030f 	and.w	r3, r3, #15
    39d2:	f103 0302 	add.w	r3, r3, #2
    39d6:	b29b      	uxth	r3, r3
    39d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    39dc:	b29b      	uxth	r3, r3
    39de:	b21b      	sxth	r3, r3
    39e0:	6878      	ldr	r0, [r7, #4]
    39e2:	4619      	mov	r1, r3
    39e4:	f7ff fb0a 	bl	2ffc <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
    39e8:	6878      	ldr	r0, [r7, #4]
    39ea:	f04f 0103 	mov.w	r1, #3
    39ee:	f000 fc4b 	bl	4288 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
    39f2:	f247 0330 	movw	r3, #28720	; 0x7030
    39f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    39fa:	f8b3 3088 	ldrh.w	r3, [r3, #136]	; 0x88
    39fe:	f103 0301 	add.w	r3, r3, #1
    3a02:	b29a      	uxth	r2, r3
    3a04:	f247 0330 	movw	r3, #28720	; 0x7030
    3a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a0c:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
      UDP_STATS_INC(udp.drop);
    3a10:	f247 0330 	movw	r3, #28720	; 0x7030
    3a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a18:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
    3a1c:	f103 0301 	add.w	r3, r3, #1
    3a20:	b29a      	uxth	r2, r3
    3a22:	f247 0330 	movw	r3, #28720	; 0x7030
    3a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a2a:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
      snmp_inc_udpnoports();
      pbuf_free(p);
    3a2e:	6878      	ldr	r0, [r7, #4]
    3a30:	f7ff fb60 	bl	30f4 <pbuf_free>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    3a34:	e002      	b.n	3a3c <udp_input+0x3fc>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
    3a36:	6878      	ldr	r0, [r7, #4]
    3a38:	f7ff fb5c 	bl	30f4 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
    3a3c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    3a40:	46bd      	mov	sp, r7
    3a42:	bd90      	pop	{r4, r7, pc}

00003a44 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
    3a44:	b580      	push	{r7, lr}
    3a46:	b088      	sub	sp, #32
    3a48:	af02      	add	r7, sp, #8
    3a4a:	60f8      	str	r0, [r7, #12]
    3a4c:	60b9      	str	r1, [r7, #8]
    3a4e:	607a      	str	r2, [r7, #4]
    3a50:	807b      	strh	r3, [r7, #2]

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
    3a52:	6878      	ldr	r0, [r7, #4]
    3a54:	f000 fe60 	bl	4718 <ip_route>
    3a58:	4603      	mov	r3, r0
    3a5a:	617b      	str	r3, [r7, #20]
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    3a5c:	697b      	ldr	r3, [r7, #20]
    3a5e:	2b00      	cmp	r3, #0
    3a60:	d111      	bne.n	3a86 <udp_sendto+0x42>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    3a62:	f247 0330 	movw	r3, #28720	; 0x7030
    3a66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a6a:	f8b3 3086 	ldrh.w	r3, [r3, #134]	; 0x86
    3a6e:	f103 0301 	add.w	r3, r3, #1
    3a72:	b29a      	uxth	r2, r3
    3a74:	f247 0330 	movw	r3, #28720	; 0x7030
    3a78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3a7c:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
    return ERR_RTE;
    3a80:	f04f 03fc 	mov.w	r3, #252	; 0xfc
    3a84:	e00a      	b.n	3a9c <udp_sendto+0x58>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    3a86:	887b      	ldrh	r3, [r7, #2]
    3a88:	697a      	ldr	r2, [r7, #20]
    3a8a:	9200      	str	r2, [sp, #0]
    3a8c:	68f8      	ldr	r0, [r7, #12]
    3a8e:	68b9      	ldr	r1, [r7, #8]
    3a90:	687a      	ldr	r2, [r7, #4]
    3a92:	f000 f809 	bl	3aa8 <udp_sendto_if>
    3a96:	4603      	mov	r3, r0
    3a98:	b2db      	uxtb	r3, r3
    3a9a:	b2db      	uxtb	r3, r3
    3a9c:	b25b      	sxtb	r3, r3
#endif /* LWIP_CHECKSUM_ON_COPY */
}
    3a9e:	4618      	mov	r0, r3
    3aa0:	f107 0718 	add.w	r7, r7, #24
    3aa4:	46bd      	mov	sp, r7
    3aa6:	bd80      	pop	{r7, pc}

00003aa8 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
    3aa8:	b580      	push	{r7, lr}
    3aaa:	b08e      	sub	sp, #56	; 0x38
    3aac:	af04      	add	r7, sp, #16
    3aae:	60f8      	str	r0, [r7, #12]
    3ab0:	60b9      	str	r1, [r7, #8]
    3ab2:	607a      	str	r2, [r7, #4]
    3ab4:	807b      	strh	r3, [r7, #2]
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
    3ab6:	68fb      	ldr	r3, [r7, #12]
    3ab8:	8a5b      	ldrh	r3, [r3, #18]
    3aba:	2b00      	cmp	r3, #0
    3abc:	d110      	bne.n	3ae0 <udp_sendto_if+0x38>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    3abe:	68fa      	ldr	r2, [r7, #12]
    3ac0:	68fb      	ldr	r3, [r7, #12]
    3ac2:	8a5b      	ldrh	r3, [r3, #18]
    3ac4:	68f8      	ldr	r0, [r7, #12]
    3ac6:	4611      	mov	r1, r2
    3ac8:	461a      	mov	r2, r3
    3aca:	f000 f8f7 	bl	3cbc <udp_bind>
    3ace:	4603      	mov	r3, r0
    3ad0:	b2db      	uxtb	r3, r3
    3ad2:	77fb      	strb	r3, [r7, #31]
    if (err != ERR_OK) {
    3ad4:	f997 301f 	ldrsb.w	r3, [r7, #31]
    3ad8:	2b00      	cmp	r3, #0
    3ada:	d001      	beq.n	3ae0 <udp_sendto_if+0x38>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
    3adc:	7ffb      	ldrb	r3, [r7, #31]
    3ade:	e0e6      	b.n	3cae <udp_sendto_if+0x206>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    3ae0:	68b8      	ldr	r0, [r7, #8]
    3ae2:	f04f 0108 	mov.w	r1, #8
    3ae6:	f7ff fa89 	bl	2ffc <pbuf_header>
    3aea:	4603      	mov	r3, r0
    3aec:	2b00      	cmp	r3, #0
    3aee:	d018      	beq.n	3b22 <udp_sendto_if+0x7a>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    3af0:	f04f 0001 	mov.w	r0, #1
    3af4:	f04f 0108 	mov.w	r1, #8
    3af8:	f04f 0200 	mov.w	r2, #0
    3afc:	f7ff f87c 	bl	2bf8 <pbuf_alloc>
    3b00:	4603      	mov	r3, r0
    3b02:	623b      	str	r3, [r7, #32]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    3b04:	6a3b      	ldr	r3, [r7, #32]
    3b06:	2b00      	cmp	r3, #0
    3b08:	d102      	bne.n	3b10 <udp_sendto_if+0x68>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    3b0a:	f04f 03ff 	mov.w	r3, #255	; 0xff
    3b0e:	e0ce      	b.n	3cae <udp_sendto_if+0x206>
    }
    if (p->tot_len != 0) {
    3b10:	68bb      	ldr	r3, [r7, #8]
    3b12:	891b      	ldrh	r3, [r3, #8]
    3b14:	2b00      	cmp	r3, #0
    3b16:	d007      	beq.n	3b28 <udp_sendto_if+0x80>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
    3b18:	6a38      	ldr	r0, [r7, #32]
    3b1a:	68b9      	ldr	r1, [r7, #8]
    3b1c:	f7ff fbaa 	bl	3274 <pbuf_chain>
    3b20:	e003      	b.n	3b2a <udp_sendto_if+0x82>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    3b22:	68bb      	ldr	r3, [r7, #8]
    3b24:	623b      	str	r3, [r7, #32]
    3b26:	e000      	b.n	3b2a <udp_sendto_if+0x82>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
    3b28:	bf00      	nop
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
    3b2a:	6a3b      	ldr	r3, [r7, #32]
    3b2c:	685b      	ldr	r3, [r3, #4]
    3b2e:	617b      	str	r3, [r7, #20]
  udphdr->src = htons(pcb->local_port);
    3b30:	68fb      	ldr	r3, [r7, #12]
    3b32:	8a5b      	ldrh	r3, [r3, #18]
    3b34:	4618      	mov	r0, r3
    3b36:	f7fe f9d9 	bl	1eec <lwip_htons>
    3b3a:	4603      	mov	r3, r0
    3b3c:	461a      	mov	r2, r3
    3b3e:	697b      	ldr	r3, [r7, #20]
    3b40:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    3b44:	f04f 0000 	mov.w	r0, #0
    3b48:	ea40 0101 	orr.w	r1, r0, r1
    3b4c:	7019      	strb	r1, [r3, #0]
    3b4e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3b52:	b292      	uxth	r2, r2
    3b54:	f04f 0100 	mov.w	r1, #0
    3b58:	ea41 0202 	orr.w	r2, r1, r2
    3b5c:	705a      	strb	r2, [r3, #1]
  udphdr->dest = htons(dst_port);
    3b5e:	887b      	ldrh	r3, [r7, #2]
    3b60:	4618      	mov	r0, r3
    3b62:	f7fe f9c3 	bl	1eec <lwip_htons>
    3b66:	4603      	mov	r3, r0
    3b68:	461a      	mov	r2, r3
    3b6a:	697b      	ldr	r3, [r7, #20]
    3b6c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    3b70:	f04f 0000 	mov.w	r0, #0
    3b74:	ea40 0101 	orr.w	r1, r0, r1
    3b78:	7099      	strb	r1, [r3, #2]
    3b7a:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3b7e:	b292      	uxth	r2, r2
    3b80:	f04f 0100 	mov.w	r1, #0
    3b84:	ea41 0202 	orr.w	r2, r1, r2
    3b88:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
    3b8a:	697b      	ldr	r3, [r7, #20]
    3b8c:	f04f 0200 	mov.w	r2, #0
    3b90:	719a      	strb	r2, [r3, #6]
    3b92:	f04f 0200 	mov.w	r2, #0
    3b96:	71da      	strb	r2, [r3, #7]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    3b98:	68fb      	ldr	r3, [r7, #12]
    3b9a:	2b00      	cmp	r3, #0
    3b9c:	d003      	beq.n	3ba6 <udp_sendto_if+0xfe>
    3b9e:	68fb      	ldr	r3, [r7, #12]
    3ba0:	681b      	ldr	r3, [r3, #0]
    3ba2:	2b00      	cmp	r3, #0
    3ba4:	d104      	bne.n	3bb0 <udp_sendto_if+0x108>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    3ba6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3ba8:	f103 0304 	add.w	r3, r3, #4
    3bac:	61bb      	str	r3, [r7, #24]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    3bae:	e014      	b.n	3bda <udp_sendto_if+0x132>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    3bb0:	68fb      	ldr	r3, [r7, #12]
    3bb2:	681a      	ldr	r2, [r3, #0]
    3bb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3bb6:	685b      	ldr	r3, [r3, #4]
    3bb8:	429a      	cmp	r2, r3
    3bba:	d00c      	beq.n	3bd6 <udp_sendto_if+0x12e>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
    3bbc:	6a3a      	ldr	r2, [r7, #32]
    3bbe:	68bb      	ldr	r3, [r7, #8]
    3bc0:	429a      	cmp	r2, r3
    3bc2:	d005      	beq.n	3bd0 <udp_sendto_if+0x128>
        /* free the header pbuf */
        pbuf_free(q);
    3bc4:	6a38      	ldr	r0, [r7, #32]
    3bc6:	f7ff fa95 	bl	30f4 <pbuf_free>
        q = NULL;
    3bca:	f04f 0300 	mov.w	r3, #0
    3bce:	623b      	str	r3, [r7, #32]
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
    3bd0:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    3bd4:	e06b      	b.n	3cae <udp_sendto_if+0x206>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
    3bd6:	68fb      	ldr	r3, [r7, #12]
    3bd8:	61bb      	str	r3, [r7, #24]
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    3bda:	6a3b      	ldr	r3, [r7, #32]
    3bdc:	891b      	ldrh	r3, [r3, #8]
    3bde:	4618      	mov	r0, r3
    3be0:	f7fe f984 	bl	1eec <lwip_htons>
    3be4:	4603      	mov	r3, r0
    3be6:	461a      	mov	r2, r3
    3be8:	697b      	ldr	r3, [r7, #20]
    3bea:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    3bee:	f04f 0000 	mov.w	r0, #0
    3bf2:	ea40 0101 	orr.w	r1, r0, r1
    3bf6:	7119      	strb	r1, [r3, #4]
    3bf8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    3bfc:	b292      	uxth	r2, r2
    3bfe:	f04f 0100 	mov.w	r1, #0
    3c02:	ea41 0202 	orr.w	r2, r1, r2
    3c06:	715a      	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    3c08:	68fb      	ldr	r3, [r7, #12]
    3c0a:	7c1b      	ldrb	r3, [r3, #16]
    3c0c:	f003 0301 	and.w	r3, r3, #1
    3c10:	2b00      	cmp	r3, #0
    3c12:	d120      	bne.n	3c56 <udp_sendto_if+0x1ae>
        acc = udpchksum + (u16_t)~(chksum);
        udpchksum = FOLD_U32T(acc);
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    3c14:	6a3b      	ldr	r3, [r7, #32]
    3c16:	891b      	ldrh	r3, [r3, #8]
    3c18:	9300      	str	r3, [sp, #0]
    3c1a:	6a38      	ldr	r0, [r7, #32]
    3c1c:	69b9      	ldr	r1, [r7, #24]
    3c1e:	687a      	ldr	r2, [r7, #4]
    3c20:	f04f 0311 	mov.w	r3, #17
    3c24:	f000 fc5c 	bl	44e0 <inet_chksum_pseudo>
    3c28:	4603      	mov	r3, r0
    3c2a:	84fb      	strh	r3, [r7, #38]	; 0x26
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
    3c2c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    3c2e:	2b00      	cmp	r3, #0
    3c30:	d102      	bne.n	3c38 <udp_sendto_if+0x190>
        udpchksum = 0xffff;
    3c32:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3c36:	84fb      	strh	r3, [r7, #38]	; 0x26
      }
      udphdr->chksum = udpchksum;
    3c38:	697b      	ldr	r3, [r7, #20]
    3c3a:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
    3c3e:	f04f 0100 	mov.w	r1, #0
    3c42:	ea41 0202 	orr.w	r2, r1, r2
    3c46:	719a      	strb	r2, [r3, #6]
    3c48:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    3c4c:	f04f 0100 	mov.w	r1, #0
    3c50:	ea41 0202 	orr.w	r2, r1, r2
    3c54:	71da      	strb	r2, [r3, #7]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    3c56:	68fb      	ldr	r3, [r7, #12]
    3c58:	7a9b      	ldrb	r3, [r3, #10]
    3c5a:	68fa      	ldr	r2, [r7, #12]
    3c5c:	7a52      	ldrb	r2, [r2, #9]
    3c5e:	9200      	str	r2, [sp, #0]
    3c60:	f04f 0211 	mov.w	r2, #17
    3c64:	9201      	str	r2, [sp, #4]
    3c66:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    3c68:	9202      	str	r2, [sp, #8]
    3c6a:	6a38      	ldr	r0, [r7, #32]
    3c6c:	69b9      	ldr	r1, [r7, #24]
    3c6e:	687a      	ldr	r2, [r7, #4]
    3c70:	f000 ffc0 	bl	4bf4 <ip_output_if>
    3c74:	4603      	mov	r3, r0
    3c76:	b2db      	uxtb	r3, r3
    3c78:	77fb      	strb	r3, [r7, #31]
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
    3c7a:	6a3a      	ldr	r2, [r7, #32]
    3c7c:	68bb      	ldr	r3, [r7, #8]
    3c7e:	429a      	cmp	r2, r3
    3c80:	d005      	beq.n	3c8e <udp_sendto_if+0x1e6>
    /* free the header pbuf */
    pbuf_free(q);
    3c82:	6a38      	ldr	r0, [r7, #32]
    3c84:	f7ff fa36 	bl	30f4 <pbuf_free>
    q = NULL;
    3c88:	f04f 0300 	mov.w	r3, #0
    3c8c:	623b      	str	r3, [r7, #32]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
    3c8e:	f247 0330 	movw	r3, #28720	; 0x7030
    3c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c96:	f8b3 3078 	ldrh.w	r3, [r3, #120]	; 0x78
    3c9a:	f103 0301 	add.w	r3, r3, #1
    3c9e:	b29a      	uxth	r2, r3
    3ca0:	f247 0330 	movw	r3, #28720	; 0x7030
    3ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ca8:	f8a3 2078 	strh.w	r2, [r3, #120]	; 0x78
  return err;
    3cac:	7ffb      	ldrb	r3, [r7, #31]
    3cae:	b25b      	sxtb	r3, r3
}
    3cb0:	4618      	mov	r0, r3
    3cb2:	f107 0728 	add.w	r7, r7, #40	; 0x28
    3cb6:	46bd      	mov	sp, r7
    3cb8:	bd80      	pop	{r7, pc}
    3cba:	bf00      	nop

00003cbc <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    3cbc:	b480      	push	{r7}
    3cbe:	b087      	sub	sp, #28
    3cc0:	af00      	add	r7, sp, #0
    3cc2:	60f8      	str	r0, [r7, #12]
    3cc4:	60b9      	str	r1, [r7, #8]
    3cc6:	4613      	mov	r3, r2
    3cc8:	80fb      	strh	r3, [r7, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
    3cca:	f04f 0300 	mov.w	r3, #0
    3cce:	75fb      	strb	r3, [r7, #23]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    3cd0:	f247 1310 	movw	r3, #28944	; 0x7110
    3cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3cd8:	681b      	ldr	r3, [r3, #0]
    3cda:	613b      	str	r3, [r7, #16]
    3cdc:	e026      	b.n	3d2c <udp_bind+0x70>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
    3cde:	68fa      	ldr	r2, [r7, #12]
    3ce0:	693b      	ldr	r3, [r7, #16]
    3ce2:	429a      	cmp	r2, r3
    3ce4:	d103      	bne.n	3cee <udp_bind+0x32>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
    3ce6:	f04f 0301 	mov.w	r3, #1
    3cea:	75fb      	strb	r3, [r7, #23]
    3cec:	e01b      	b.n	3d26 <udp_bind+0x6a>
             ((ipcb->so_options & SOF_REUSEADDR) == 0)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    3cee:	693b      	ldr	r3, [r7, #16]
    3cf0:	8a5b      	ldrh	r3, [r3, #18]
    3cf2:	88fa      	ldrh	r2, [r7, #6]
    3cf4:	429a      	cmp	r2, r3
    3cf6:	d116      	bne.n	3d26 <udp_bind+0x6a>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
    3cf8:	693b      	ldr	r3, [r7, #16]
             ((ipcb->so_options & SOF_REUSEADDR) == 0)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    3cfa:	2b00      	cmp	r3, #0
    3cfc:	d010      	beq.n	3d20 <udp_bind+0x64>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
    3cfe:	693b      	ldr	r3, [r7, #16]
    3d00:	681b      	ldr	r3, [r3, #0]
             ((ipcb->so_options & SOF_REUSEADDR) == 0)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    3d02:	2b00      	cmp	r3, #0
    3d04:	d00c      	beq.n	3d20 <udp_bind+0x64>
    3d06:	68bb      	ldr	r3, [r7, #8]
    3d08:	2b00      	cmp	r3, #0
    3d0a:	d009      	beq.n	3d20 <udp_bind+0x64>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
    3d0c:	68bb      	ldr	r3, [r7, #8]
    3d0e:	681b      	ldr	r3, [r3, #0]
             ((ipcb->so_options & SOF_REUSEADDR) == 0)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    3d10:	2b00      	cmp	r3, #0
    3d12:	d005      	beq.n	3d20 <udp_bind+0x64>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    3d14:	693b      	ldr	r3, [r7, #16]
    3d16:	681a      	ldr	r2, [r3, #0]
    3d18:	68bb      	ldr	r3, [r7, #8]
    3d1a:	681b      	ldr	r3, [r3, #0]
             ((ipcb->so_options & SOF_REUSEADDR) == 0)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    3d1c:	429a      	cmp	r2, r3
    3d1e:	d102      	bne.n	3d26 <udp_bind+0x6a>
           ip_addr_isany(ipaddr) ||
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
    3d20:	f04f 03f8 	mov.w	r3, #248	; 0xf8
    3d24:	e052      	b.n	3dcc <udp_bind+0x110>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    3d26:	693b      	ldr	r3, [r7, #16]
    3d28:	68db      	ldr	r3, [r3, #12]
    3d2a:	613b      	str	r3, [r7, #16]
    3d2c:	693b      	ldr	r3, [r7, #16]
    3d2e:	2b00      	cmp	r3, #0
    3d30:	d1d5      	bne.n	3cde <udp_bind+0x22>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
    3d32:	68bb      	ldr	r3, [r7, #8]
    3d34:	2b00      	cmp	r3, #0
    3d36:	d002      	beq.n	3d3e <udp_bind+0x82>
    3d38:	68bb      	ldr	r3, [r7, #8]
    3d3a:	681b      	ldr	r3, [r3, #0]
    3d3c:	e001      	b.n	3d42 <udp_bind+0x86>
    3d3e:	f04f 0300 	mov.w	r3, #0
    3d42:	68fa      	ldr	r2, [r7, #12]
    3d44:	6013      	str	r3, [r2, #0]

  /* no port specified? */
  if (port == 0) {
    3d46:	88fb      	ldrh	r3, [r7, #6]
    3d48:	2b00      	cmp	r3, #0
    3d4a:	d12a      	bne.n	3da2 <udp_bind+0xe6>
/* From http://www.iana.org/assignments/port-numbers:
   "The Dynamic and/or Private Ports are those from 49152 through 65535" */
#define UDP_LOCAL_PORT_RANGE_START  0xc000
#define UDP_LOCAL_PORT_RANGE_END    0xffff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    3d4c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3d50:	80fb      	strh	r3, [r7, #6]
    ipcb = udp_pcbs;
    3d52:	f247 1310 	movw	r3, #28944	; 0x7110
    3d56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d5a:	681b      	ldr	r3, [r3, #0]
    3d5c:	613b      	str	r3, [r7, #16]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
    3d5e:	e012      	b.n	3d86 <udp_bind+0xca>
      if (ipcb->local_port == port) {
    3d60:	693b      	ldr	r3, [r7, #16]
    3d62:	8a5b      	ldrh	r3, [r3, #18]
    3d64:	88fa      	ldrh	r2, [r7, #6]
    3d66:	429a      	cmp	r2, r3
    3d68:	d10a      	bne.n	3d80 <udp_bind+0xc4>
        /* port is already used by another udp_pcb */
        port++;
    3d6a:	88fb      	ldrh	r3, [r7, #6]
    3d6c:	f103 0301 	add.w	r3, r3, #1
    3d70:	80fb      	strh	r3, [r7, #6]
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
    3d72:	f247 1310 	movw	r3, #28944	; 0x7110
    3d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d7a:	681b      	ldr	r3, [r3, #0]
    3d7c:	613b      	str	r3, [r7, #16]
    3d7e:	e002      	b.n	3d86 <udp_bind+0xca>
      } else {
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    3d80:	693b      	ldr	r3, [r7, #16]
    3d82:	68db      	ldr	r3, [r3, #12]
    3d84:	613b      	str	r3, [r7, #16]
#define UDP_LOCAL_PORT_RANGE_START  0xc000
#define UDP_LOCAL_PORT_RANGE_END    0xffff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
    3d86:	693b      	ldr	r3, [r7, #16]
    3d88:	2b00      	cmp	r3, #0
    3d8a:	d004      	beq.n	3d96 <udp_bind+0xda>
    3d8c:	88fa      	ldrh	r2, [r7, #6]
    3d8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3d92:	429a      	cmp	r2, r3
    3d94:	d1e4      	bne.n	3d60 <udp_bind+0xa4>
      } else {
        /* go on with next udp pcb */
        ipcb = ipcb->next;
      }
    }
    if (ipcb != NULL) {
    3d96:	693b      	ldr	r3, [r7, #16]
    3d98:	2b00      	cmp	r3, #0
    3d9a:	d002      	beq.n	3da2 <udp_bind+0xe6>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    3d9c:	f04f 03f8 	mov.w	r3, #248	; 0xf8
    3da0:	e014      	b.n	3dcc <udp_bind+0x110>
    }
  }
  pcb->local_port = port;
    3da2:	68fb      	ldr	r3, [r7, #12]
    3da4:	88fa      	ldrh	r2, [r7, #6]
    3da6:	825a      	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    3da8:	7dfb      	ldrb	r3, [r7, #23]
    3daa:	2b00      	cmp	r3, #0
    3dac:	d10c      	bne.n	3dc8 <udp_bind+0x10c>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
    3dae:	f247 1310 	movw	r3, #28944	; 0x7110
    3db2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3db6:	681a      	ldr	r2, [r3, #0]
    3db8:	68fb      	ldr	r3, [r7, #12]
    3dba:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
    3dbc:	f247 1310 	movw	r3, #28944	; 0x7110
    3dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dc4:	68fa      	ldr	r2, [r7, #12]
    3dc6:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
    3dc8:	f04f 0300 	mov.w	r3, #0
    3dcc:	b25b      	sxtb	r3, r3
}
    3dce:	4618      	mov	r0, r3
    3dd0:	f107 071c 	add.w	r7, r7, #28
    3dd4:	46bd      	mov	sp, r7
    3dd6:	bc80      	pop	{r7}
    3dd8:	4770      	bx	lr
    3dda:	bf00      	nop

00003ddc <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
    3ddc:	b480      	push	{r7}
    3dde:	b085      	sub	sp, #20
    3de0:	af00      	add	r7, sp, #0
    3de2:	60f8      	str	r0, [r7, #12]
    3de4:	60b9      	str	r1, [r7, #8]
    3de6:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
    3de8:	68fb      	ldr	r3, [r7, #12]
    3dea:	68ba      	ldr	r2, [r7, #8]
    3dec:	619a      	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
    3dee:	68fb      	ldr	r3, [r7, #12]
    3df0:	687a      	ldr	r2, [r7, #4]
    3df2:	61da      	str	r2, [r3, #28]
}
    3df4:	f107 0714 	add.w	r7, r7, #20
    3df8:	46bd      	mov	sp, r7
    3dfa:	bc80      	pop	{r7}
    3dfc:	4770      	bx	lr
    3dfe:	bf00      	nop

00003e00 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
    3e00:	b580      	push	{r7, lr}
    3e02:	b082      	sub	sp, #8
    3e04:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    3e06:	f04f 0001 	mov.w	r0, #1
    3e0a:	f7fe fd1d 	bl	2848 <memp_malloc>
    3e0e:	4603      	mov	r3, r0
    3e10:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
    3e12:	687b      	ldr	r3, [r7, #4]
    3e14:	2b00      	cmp	r3, #0
    3e16:	d00a      	beq.n	3e2e <udp_new+0x2e>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
    3e18:	6878      	ldr	r0, [r7, #4]
    3e1a:	f04f 0100 	mov.w	r1, #0
    3e1e:	f04f 0220 	mov.w	r2, #32
    3e22:	f004 ffc7 	bl	8db4 <memset>
    pcb->ttl = UDP_TTL;
    3e26:	687b      	ldr	r3, [r7, #4]
    3e28:	f04f 32ff 	mov.w	r2, #4294967295
    3e2c:	729a      	strb	r2, [r3, #10]
  }
  return pcb;
    3e2e:	687b      	ldr	r3, [r7, #4]
}
    3e30:	4618      	mov	r0, r3
    3e32:	f107 0708 	add.w	r7, r7, #8
    3e36:	46bd      	mov	sp, r7
    3e38:	bd80      	pop	{r7, pc}
    3e3a:	bf00      	nop

00003e3c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    3e3c:	b580      	push	{r7, lr}
    3e3e:	b08e      	sub	sp, #56	; 0x38
    3e40:	af04      	add	r7, sp, #16
    3e42:	6078      	str	r0, [r7, #4]
    3e44:	6039      	str	r1, [r7, #0]
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    3e46:	f247 0330 	movw	r3, #28720	; 0x7030
    3e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e4e:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
    3e52:	f103 0301 	add.w	r3, r3, #1
    3e56:	b29a      	uxth	r2, r3
    3e58:	f247 0330 	movw	r3, #28720	; 0x7030
    3e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3e60:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
    3e64:	687b      	ldr	r3, [r7, #4]
    3e66:	685b      	ldr	r3, [r3, #4]
    3e68:	617b      	str	r3, [r7, #20]
  hlen = IPH_HL(iphdr) * 4;
    3e6a:	697b      	ldr	r3, [r7, #20]
    3e6c:	781a      	ldrb	r2, [r3, #0]
    3e6e:	785b      	ldrb	r3, [r3, #1]
    3e70:	ea4f 2303 	mov.w	r3, r3, lsl #8
    3e74:	ea43 0302 	orr.w	r3, r3, r2
    3e78:	b29b      	uxth	r3, r3
    3e7a:	4618      	mov	r0, r3
    3e7c:	f7fe f84e 	bl	1f1c <lwip_ntohs>
    3e80:	4603      	mov	r3, r0
    3e82:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3e86:	b29b      	uxth	r3, r3
    3e88:	f003 030f 	and.w	r3, r3, #15
    3e8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    3e90:	b29b      	uxth	r3, r3
    3e92:	837b      	strh	r3, [r7, #26]
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    3e94:	8b7b      	ldrh	r3, [r7, #26]
    3e96:	f1c3 0300 	rsb	r3, r3, #0
    3e9a:	b29b      	uxth	r3, r3
    3e9c:	b21b      	sxth	r3, r3
    3e9e:	6878      	ldr	r0, [r7, #4]
    3ea0:	4619      	mov	r1, r3
    3ea2:	f7ff f8ab 	bl	2ffc <pbuf_header>
    3ea6:	4603      	mov	r3, r0
    3ea8:	2b00      	cmp	r3, #0
    3eaa:	f040 81ba 	bne.w	4222 <icmp_input+0x3e6>
    3eae:	687b      	ldr	r3, [r7, #4]
    3eb0:	891b      	ldrh	r3, [r3, #8]
    3eb2:	2b03      	cmp	r3, #3
    3eb4:	f240 81b5 	bls.w	4222 <icmp_input+0x3e6>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
    3eb8:	687b      	ldr	r3, [r7, #4]
    3eba:	685b      	ldr	r3, [r3, #4]
    3ebc:	781b      	ldrb	r3, [r3, #0]
    3ebe:	73fb      	strb	r3, [r7, #15]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
    3ec0:	7bfb      	ldrb	r3, [r7, #15]
    3ec2:	2b00      	cmp	r3, #0
    3ec4:	f000 81a5 	beq.w	4212 <icmp_input+0x3d6>
    3ec8:	2b08      	cmp	r3, #8
    3eca:	f040 8183 	bne.w	41d4 <icmp_input+0x398>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
    3ece:	f04f 0301 	mov.w	r3, #1
    3ed2:	61fb      	str	r3, [r7, #28]
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
    3ed4:	f247 131c 	movw	r3, #28956	; 0x711c
    3ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3edc:	681b      	ldr	r3, [r3, #0]
    3ede:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3ee2:	2be0      	cmp	r3, #224	; 0xe0
    3ee4:	d102      	bne.n	3eec <icmp_input+0xb0>
        accepted = 0;
    3ee6:	f04f 0300 	mov.w	r3, #0
    3eea:	61fb      	str	r3, [r7, #28]
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    3eec:	f247 131c 	movw	r3, #28956	; 0x711c
    3ef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ef4:	681b      	ldr	r3, [r3, #0]
    3ef6:	4618      	mov	r0, r3
    3ef8:	6839      	ldr	r1, [r7, #0]
    3efa:	f001 f8bb 	bl	5074 <ip4_addr_isbroadcast>
    3efe:	4603      	mov	r3, r0
    3f00:	2b00      	cmp	r3, #0
    3f02:	d002      	beq.n	3f0a <icmp_input+0xce>
        accepted = 0;
    3f04:	f04f 0300 	mov.w	r3, #0
    3f08:	61fb      	str	r3, [r7, #28]
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    3f0a:	69fb      	ldr	r3, [r7, #28]
    3f0c:	2b00      	cmp	r3, #0
    3f0e:	d112      	bne.n	3f36 <icmp_input+0xfa>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
    3f10:	f247 0330 	movw	r3, #28720	; 0x7030
    3f14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f18:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
    3f1c:	f103 0301 	add.w	r3, r3, #1
    3f20:	b29a      	uxth	r2, r3
    3f22:	f247 0330 	movw	r3, #28720	; 0x7030
    3f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f2a:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
        pbuf_free(p);
    3f2e:	6878      	ldr	r0, [r7, #4]
    3f30:	f7ff f8e0 	bl	30f4 <pbuf_free>
        return;
    3f34:	e1a4      	b.n	4280 <icmp_input+0x444>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    3f36:	687b      	ldr	r3, [r7, #4]
    3f38:	891b      	ldrh	r3, [r3, #8]
    3f3a:	2b07      	cmp	r3, #7
    3f3c:	f240 8170 	bls.w	4220 <icmp_input+0x3e4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
    3f40:	6878      	ldr	r0, [r7, #4]
    3f42:	f000 fb89 	bl	4658 <inet_chksum_pbuf>
    3f46:	4603      	mov	r3, r0
    3f48:	2b00      	cmp	r3, #0
    3f4a:	d012      	beq.n	3f72 <icmp_input+0x136>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
    3f4c:	6878      	ldr	r0, [r7, #4]
    3f4e:	f7ff f8d1 	bl	30f4 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
    3f52:	f247 0330 	movw	r3, #28720	; 0x7030
    3f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f5a:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    3f5e:	f103 0301 	add.w	r3, r3, #1
    3f62:	b29a      	uxth	r2, r3
    3f64:	f247 0330 	movw	r3, #28720	; 0x7030
    3f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f6c:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
      snmp_inc_icmpinerrors();
      return;
    3f70:	e186      	b.n	4280 <icmp_input+0x444>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    3f72:	6878      	ldr	r0, [r7, #4]
    3f74:	f04f 0122 	mov.w	r1, #34	; 0x22
    3f78:	f7ff f840 	bl	2ffc <pbuf_header>
    3f7c:	4603      	mov	r3, r0
    3f7e:	2b00      	cmp	r3, #0
    3f80:	d037      	beq.n	3ff2 <icmp_input+0x1b6>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    3f82:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
    3f86:	6878      	ldr	r0, [r7, #4]
    3f88:	4619      	mov	r1, r3
    3f8a:	f7ff f837 	bl	2ffc <pbuf_header>
    3f8e:	4603      	mov	r3, r0
    3f90:	2b00      	cmp	r3, #0
    3f92:	f040 8159 	bne.w	4248 <icmp_input+0x40c>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    3f96:	687b      	ldr	r3, [r7, #4]
    3f98:	891b      	ldrh	r3, [r3, #8]
    3f9a:	f04f 0002 	mov.w	r0, #2
    3f9e:	4619      	mov	r1, r3
    3fa0:	f04f 0200 	mov.w	r2, #0
    3fa4:	f7fe fe28 	bl	2bf8 <pbuf_alloc>
    3fa8:	4603      	mov	r3, r0
    3faa:	623b      	str	r3, [r7, #32]
      if (r == NULL) {
    3fac:	6a3b      	ldr	r3, [r7, #32]
    3fae:	2b00      	cmp	r3, #0
    3fb0:	f000 814c 	beq.w	424c <icmp_input+0x410>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    3fb4:	6a38      	ldr	r0, [r7, #32]
    3fb6:	6879      	ldr	r1, [r7, #4]
    3fb8:	f7ff f96c 	bl	3294 <pbuf_copy>
    3fbc:	4603      	mov	r3, r0
    3fbe:	b2db      	uxtb	r3, r3
    3fc0:	2b00      	cmp	r3, #0
    3fc2:	f040 8145 	bne.w	4250 <icmp_input+0x414>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
    3fc6:	6a3b      	ldr	r3, [r7, #32]
    3fc8:	685b      	ldr	r3, [r3, #4]
    3fca:	617b      	str	r3, [r7, #20]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    3fcc:	8b7b      	ldrh	r3, [r7, #26]
    3fce:	f1c3 0300 	rsb	r3, r3, #0
    3fd2:	b29b      	uxth	r3, r3
    3fd4:	b21b      	sxth	r3, r3
    3fd6:	6a38      	ldr	r0, [r7, #32]
    3fd8:	4619      	mov	r1, r3
    3fda:	f7ff f80f 	bl	2ffc <pbuf_header>
    3fde:	4603      	mov	r3, r0
    3fe0:	2b00      	cmp	r3, #0
    3fe2:	f040 8137 	bne.w	4254 <icmp_input+0x418>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    3fe6:	6878      	ldr	r0, [r7, #4]
    3fe8:	f7ff f884 	bl	30f4 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    3fec:	6a3b      	ldr	r3, [r7, #32]
    3fee:	607b      	str	r3, [r7, #4]
    3ff0:	e008      	b.n	4004 <icmp_input+0x1c8>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    3ff2:	6878      	ldr	r0, [r7, #4]
    3ff4:	f06f 0121 	mvn.w	r1, #33	; 0x21
    3ff8:	f7ff f800 	bl	2ffc <pbuf_header>
    3ffc:	4603      	mov	r3, r0
    3ffe:	2b00      	cmp	r3, #0
    4000:	f040 812a 	bne.w	4258 <icmp_input+0x41c>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    4004:	687b      	ldr	r3, [r7, #4]
    4006:	685b      	ldr	r3, [r3, #4]
    4008:	613b      	str	r3, [r7, #16]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    400a:	f247 131c 	movw	r3, #28956	; 0x711c
    400e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4012:	681a      	ldr	r2, [r3, #0]
    4014:	697b      	ldr	r3, [r7, #20]
    4016:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    401a:	f04f 0000 	mov.w	r0, #0
    401e:	ea40 0101 	orr.w	r1, r0, r1
    4022:	7319      	strb	r1, [r3, #12]
    4024:	ea4f 2112 	mov.w	r1, r2, lsr #8
    4028:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    402c:	f04f 0000 	mov.w	r0, #0
    4030:	ea40 0101 	orr.w	r1, r0, r1
    4034:	7359      	strb	r1, [r3, #13]
    4036:	ea4f 4112 	mov.w	r1, r2, lsr #16
    403a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    403e:	f04f 0000 	mov.w	r0, #0
    4042:	ea40 0101 	orr.w	r1, r0, r1
    4046:	7399      	strb	r1, [r3, #14]
    4048:	ea4f 6212 	mov.w	r2, r2, lsr #24
    404c:	f04f 0100 	mov.w	r1, #0
    4050:	ea41 0202 	orr.w	r2, r1, r2
    4054:	73da      	strb	r2, [r3, #15]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    4056:	f247 1314 	movw	r3, #28948	; 0x7114
    405a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    405e:	681a      	ldr	r2, [r3, #0]
    4060:	697b      	ldr	r3, [r7, #20]
    4062:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4066:	f04f 0000 	mov.w	r0, #0
    406a:	ea40 0101 	orr.w	r1, r0, r1
    406e:	7419      	strb	r1, [r3, #16]
    4070:	ea4f 2112 	mov.w	r1, r2, lsr #8
    4074:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4078:	f04f 0000 	mov.w	r0, #0
    407c:	ea40 0101 	orr.w	r1, r0, r1
    4080:	7459      	strb	r1, [r3, #17]
    4082:	ea4f 4112 	mov.w	r1, r2, lsr #16
    4086:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    408a:	f04f 0000 	mov.w	r0, #0
    408e:	ea40 0101 	orr.w	r1, r0, r1
    4092:	7499      	strb	r1, [r3, #18]
    4094:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4098:	f04f 0100 	mov.w	r1, #0
    409c:	ea41 0202 	orr.w	r2, r1, r2
    40a0:	74da      	strb	r2, [r3, #19]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    40a2:	693b      	ldr	r3, [r7, #16]
    40a4:	f04f 0200 	mov.w	r2, #0
    40a8:	701a      	strb	r2, [r3, #0]
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    40aa:	693b      	ldr	r3, [r7, #16]
    40ac:	789a      	ldrb	r2, [r3, #2]
    40ae:	78db      	ldrb	r3, [r3, #3]
    40b0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    40b4:	ea43 0302 	orr.w	r3, r3, r2
    40b8:	b29a      	uxth	r2, r3
    40ba:	f64f 73f6 	movw	r3, #65526	; 0xfff6
    40be:	429a      	cmp	r2, r3
    40c0:	d91b      	bls.n	40fa <icmp_input+0x2be>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    40c2:	693b      	ldr	r3, [r7, #16]
    40c4:	789a      	ldrb	r2, [r3, #2]
    40c6:	78db      	ldrb	r3, [r3, #3]
    40c8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    40cc:	ea43 0302 	orr.w	r3, r3, r2
    40d0:	b29b      	uxth	r3, r3
    40d2:	f103 0309 	add.w	r3, r3, #9
    40d6:	b29a      	uxth	r2, r3
    40d8:	693b      	ldr	r3, [r7, #16]
    40da:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    40de:	f04f 0000 	mov.w	r0, #0
    40e2:	ea40 0101 	orr.w	r1, r0, r1
    40e6:	7099      	strb	r1, [r3, #2]
    40e8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    40ec:	b292      	uxth	r2, r2
    40ee:	f04f 0100 	mov.w	r1, #0
    40f2:	ea41 0202 	orr.w	r2, r1, r2
    40f6:	70da      	strb	r2, [r3, #3]
    40f8:	e01a      	b.n	4130 <icmp_input+0x2f4>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    40fa:	693b      	ldr	r3, [r7, #16]
    40fc:	789a      	ldrb	r2, [r3, #2]
    40fe:	78db      	ldrb	r3, [r3, #3]
    4100:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4104:	ea43 0302 	orr.w	r3, r3, r2
    4108:	b29b      	uxth	r3, r3
    410a:	f103 0308 	add.w	r3, r3, #8
    410e:	b29a      	uxth	r2, r3
    4110:	693b      	ldr	r3, [r7, #16]
    4112:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4116:	f04f 0000 	mov.w	r0, #0
    411a:	ea40 0101 	orr.w	r1, r0, r1
    411e:	7099      	strb	r1, [r3, #2]
    4120:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4124:	b292      	uxth	r2, r2
    4126:	f04f 0100 	mov.w	r1, #0
    412a:	ea41 0202 	orr.w	r2, r1, r2
    412e:	70da      	strb	r2, [r3, #3]
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    4130:	697b      	ldr	r3, [r7, #20]
    4132:	f04f 32ff 	mov.w	r2, #4294967295
    4136:	721a      	strb	r2, [r3, #8]
    IPH_CHKSUM_SET(iphdr, 0);
    4138:	697b      	ldr	r3, [r7, #20]
    413a:	f04f 0200 	mov.w	r2, #0
    413e:	729a      	strb	r2, [r3, #10]
    4140:	f04f 0200 	mov.w	r2, #0
    4144:	72da      	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    4146:	6978      	ldr	r0, [r7, #20]
    4148:	f04f 0114 	mov.w	r1, #20
    414c:	f000 fa70 	bl	4630 <inet_chksum>
    4150:	4603      	mov	r3, r0
    4152:	461a      	mov	r2, r3
    4154:	697b      	ldr	r3, [r7, #20]
    4156:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    415a:	f04f 0000 	mov.w	r0, #0
    415e:	ea40 0101 	orr.w	r1, r0, r1
    4162:	7299      	strb	r1, [r3, #10]
    4164:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4168:	b292      	uxth	r2, r2
    416a:	f04f 0100 	mov.w	r1, #0
    416e:	ea41 0202 	orr.w	r2, r1, r2
    4172:	72da      	strb	r2, [r3, #11]
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    4174:	f247 0330 	movw	r3, #28720	; 0x7030
    4178:	f2c2 0300 	movt	r3, #8192	; 0x2000
    417c:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    4180:	f103 0301 	add.w	r3, r3, #1
    4184:	b29a      	uxth	r2, r3
    4186:	f247 0330 	movw	r3, #28720	; 0x7030
    418a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    418e:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    4192:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
    4196:	6878      	ldr	r0, [r7, #4]
    4198:	4619      	mov	r1, r3
    419a:	f7fe ff2f 	bl	2ffc <pbuf_header>
    419e:	4603      	mov	r3, r0
    41a0:	2b00      	cmp	r3, #0
    41a2:	d138      	bne.n	4216 <icmp_input+0x3da>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
    41a4:	f04f 0300 	mov.w	r3, #0
    41a8:	9300      	str	r3, [sp, #0]
    41aa:	f04f 0301 	mov.w	r3, #1
    41ae:	9301      	str	r3, [sp, #4]
    41b0:	683b      	ldr	r3, [r7, #0]
    41b2:	9302      	str	r3, [sp, #8]
    41b4:	6878      	ldr	r0, [r7, #4]
    41b6:	f247 111c 	movw	r1, #28956	; 0x711c
    41ba:	f2c2 0100 	movt	r1, #8192	; 0x2000
    41be:	f04f 0200 	mov.w	r2, #0
    41c2:	f04f 03ff 	mov.w	r3, #255	; 0xff
    41c6:	f000 fd15 	bl	4bf4 <ip_output_if>
    41ca:	4603      	mov	r3, r0
    41cc:	b2db      	uxtb	r3, r3
    41ce:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    41d2:	e021      	b.n	4218 <icmp_input+0x3dc>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    41d4:	f247 0330 	movw	r3, #28720	; 0x7030
    41d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41dc:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
    41e0:	f103 0301 	add.w	r3, r3, #1
    41e4:	b29a      	uxth	r2, r3
    41e6:	f247 0330 	movw	r3, #28720	; 0x7030
    41ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41ee:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
    41f2:	f247 0330 	movw	r3, #28720	; 0x7030
    41f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41fa:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    41fe:	f103 0301 	add.w	r3, r3, #1
    4202:	b29a      	uxth	r2, r3
    4204:	f247 0330 	movw	r3, #28720	; 0x7030
    4208:	f2c2 0300 	movt	r3, #8192	; 0x2000
    420c:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    4210:	e002      	b.n	4218 <icmp_input+0x3dc>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
    4212:	bf00      	nop
    4214:	e000      	b.n	4218 <icmp_input+0x3dc>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    4216:	bf00      	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    4218:	6878      	ldr	r0, [r7, #4]
    421a:	f7fe ff6b 	bl	30f4 <pbuf_free>
  return;
    421e:	e02f      	b.n	4280 <icmp_input+0x444>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    4220:	bf00      	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
    4222:	6878      	ldr	r0, [r7, #4]
    4224:	f7fe ff66 	bl	30f4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
    4228:	f247 0330 	movw	r3, #28720	; 0x7030
    422c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4230:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
    4234:	f103 0301 	add.w	r3, r3, #1
    4238:	b29a      	uxth	r2, r3
    423a:	f247 0330 	movw	r3, #28720	; 0x7030
    423e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4242:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  snmp_inc_icmpinerrors();
  return;
    4246:	e01b      	b.n	4280 <icmp_input+0x444>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
    4248:	bf00      	nop
    424a:	e006      	b.n	425a <icmp_input+0x41e>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
    424c:	bf00      	nop
    424e:	e004      	b.n	425a <icmp_input+0x41e>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
    4250:	bf00      	nop
    4252:	e002      	b.n	425a <icmp_input+0x41e>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
    4254:	bf00      	nop
    4256:	e000      	b.n	425a <icmp_input+0x41e>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
    4258:	bf00      	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    425a:	6878      	ldr	r0, [r7, #4]
    425c:	f7fe ff4a 	bl	30f4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
    4260:	f247 0330 	movw	r3, #28720	; 0x7030
    4264:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4268:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
    426c:	f103 0301 	add.w	r3, r3, #1
    4270:	b29a      	uxth	r2, r3
    4272:	f247 0330 	movw	r3, #28720	; 0x7030
    4276:	f2c2 0300 	movt	r3, #8192	; 0x2000
    427a:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
  snmp_inc_icmpinerrors();
  return;
    427e:	bf00      	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    4280:	f107 0728 	add.w	r7, r7, #40	; 0x28
    4284:	46bd      	mov	sp, r7
    4286:	bd80      	pop	{r7, pc}

00004288 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
    4288:	b580      	push	{r7, lr}
    428a:	b082      	sub	sp, #8
    428c:	af00      	add	r7, sp, #0
    428e:	6078      	str	r0, [r7, #4]
    4290:	460b      	mov	r3, r1
    4292:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_DUR, t);
    4294:	78fb      	ldrb	r3, [r7, #3]
    4296:	6878      	ldr	r0, [r7, #4]
    4298:	f04f 0103 	mov.w	r1, #3
    429c:	461a      	mov	r2, r3
    429e:	f000 f817 	bl	42d0 <icmp_send_response>
}
    42a2:	f107 0708 	add.w	r7, r7, #8
    42a6:	46bd      	mov	sp, r7
    42a8:	bd80      	pop	{r7, pc}
    42aa:	bf00      	nop

000042ac <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
    42ac:	b580      	push	{r7, lr}
    42ae:	b082      	sub	sp, #8
    42b0:	af00      	add	r7, sp, #0
    42b2:	6078      	str	r0, [r7, #4]
    42b4:	460b      	mov	r3, r1
    42b6:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_TE, t);
    42b8:	78fb      	ldrb	r3, [r7, #3]
    42ba:	6878      	ldr	r0, [r7, #4]
    42bc:	f04f 010b 	mov.w	r1, #11
    42c0:	461a      	mov	r2, r3
    42c2:	f000 f805 	bl	42d0 <icmp_send_response>
}
    42c6:	f107 0708 	add.w	r7, r7, #8
    42ca:	46bd      	mov	sp, r7
    42cc:	bd80      	pop	{r7, pc}
    42ce:	bf00      	nop

000042d0 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    42d0:	b580      	push	{r7, lr}
    42d2:	b088      	sub	sp, #32
    42d4:	af02      	add	r7, sp, #8
    42d6:	6078      	str	r0, [r7, #4]
    42d8:	4613      	mov	r3, r2
    42da:	460a      	mov	r2, r1
    42dc:	70fa      	strb	r2, [r7, #3]
    42de:	70bb      	strb	r3, [r7, #2]
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    42e0:	f04f 0001 	mov.w	r0, #1
    42e4:	f04f 0124 	mov.w	r1, #36	; 0x24
    42e8:	f04f 0200 	mov.w	r2, #0
    42ec:	f7fe fc84 	bl	2bf8 <pbuf_alloc>
    42f0:	4603      	mov	r3, r0
    42f2:	60fb      	str	r3, [r7, #12]
                 PBUF_RAM);
  if (q == NULL) {
    42f4:	68fb      	ldr	r3, [r7, #12]
    42f6:	2b00      	cmp	r3, #0
    42f8:	d079      	beq.n	43ee <icmp_send_response+0x11e>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
    42fa:	687b      	ldr	r3, [r7, #4]
    42fc:	685b      	ldr	r3, [r3, #4]
    42fe:	613b      	str	r3, [r7, #16]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
    4300:	68fb      	ldr	r3, [r7, #12]
    4302:	685b      	ldr	r3, [r3, #4]
    4304:	617b      	str	r3, [r7, #20]
  icmphdr->type = type;
    4306:	697b      	ldr	r3, [r7, #20]
    4308:	78fa      	ldrb	r2, [r7, #3]
    430a:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
    430c:	697b      	ldr	r3, [r7, #20]
    430e:	78ba      	ldrb	r2, [r7, #2]
    4310:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
    4312:	697b      	ldr	r3, [r7, #20]
    4314:	f04f 0200 	mov.w	r2, #0
    4318:	711a      	strb	r2, [r3, #4]
    431a:	f04f 0200 	mov.w	r2, #0
    431e:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
    4320:	697b      	ldr	r3, [r7, #20]
    4322:	f04f 0200 	mov.w	r2, #0
    4326:	719a      	strb	r2, [r3, #6]
    4328:	f04f 0200 	mov.w	r2, #0
    432c:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    432e:	68fb      	ldr	r3, [r7, #12]
    4330:	685b      	ldr	r3, [r3, #4]
    4332:	f103 0208 	add.w	r2, r3, #8
    4336:	687b      	ldr	r3, [r7, #4]
    4338:	685b      	ldr	r3, [r3, #4]
    433a:	4610      	mov	r0, r2
    433c:	4619      	mov	r1, r3
    433e:	f04f 021c 	mov.w	r2, #28
    4342:	f004 fc6f 	bl	8c24 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    4346:	697b      	ldr	r3, [r7, #20]
    4348:	f04f 0200 	mov.w	r2, #0
    434c:	709a      	strb	r2, [r3, #2]
    434e:	f04f 0200 	mov.w	r2, #0
    4352:	70da      	strb	r2, [r3, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    4354:	68fb      	ldr	r3, [r7, #12]
    4356:	895b      	ldrh	r3, [r3, #10]
    4358:	6978      	ldr	r0, [r7, #20]
    435a:	4619      	mov	r1, r3
    435c:	f000 f968 	bl	4630 <inet_chksum>
    4360:	4603      	mov	r3, r0
    4362:	461a      	mov	r2, r3
    4364:	697b      	ldr	r3, [r7, #20]
    4366:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    436a:	f04f 0000 	mov.w	r0, #0
    436e:	ea40 0101 	orr.w	r1, r0, r1
    4372:	7099      	strb	r1, [r3, #2]
    4374:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4378:	b292      	uxth	r2, r2
    437a:	f04f 0100 	mov.w	r1, #0
    437e:	ea41 0202 	orr.w	r2, r1, r2
    4382:	70da      	strb	r2, [r3, #3]
  ICMP_STATS_INC(icmp.xmit);
    4384:	f247 0330 	movw	r3, #28720	; 0x7030
    4388:	f2c2 0300 	movt	r3, #8192	; 0x2000
    438c:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    4390:	f103 0301 	add.w	r3, r3, #1
    4394:	b29a      	uxth	r2, r3
    4396:	f247 0330 	movw	r3, #28720	; 0x7030
    439a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    439e:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    43a2:	693b      	ldr	r3, [r7, #16]
    43a4:	7b1a      	ldrb	r2, [r3, #12]
    43a6:	7b59      	ldrb	r1, [r3, #13]
    43a8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    43ac:	ea41 0202 	orr.w	r2, r1, r2
    43b0:	7b99      	ldrb	r1, [r3, #14]
    43b2:	ea4f 4101 	mov.w	r1, r1, lsl #16
    43b6:	ea41 0202 	orr.w	r2, r1, r2
    43ba:	7bdb      	ldrb	r3, [r3, #15]
    43bc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    43c0:	ea43 0302 	orr.w	r3, r3, r2
    43c4:	60bb      	str	r3, [r7, #8]
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    43c6:	f107 0308 	add.w	r3, r7, #8
    43ca:	f04f 0200 	mov.w	r2, #0
    43ce:	9200      	str	r2, [sp, #0]
    43d0:	f04f 0201 	mov.w	r2, #1
    43d4:	9201      	str	r2, [sp, #4]
    43d6:	68f8      	ldr	r0, [r7, #12]
    43d8:	f04f 0100 	mov.w	r1, #0
    43dc:	461a      	mov	r2, r3
    43de:	f04f 03ff 	mov.w	r3, #255	; 0xff
    43e2:	f000 fe0f 	bl	5004 <ip_output>
  pbuf_free(q);
    43e6:	68f8      	ldr	r0, [r7, #12]
    43e8:	f7fe fe84 	bl	30f4 <pbuf_free>
    43ec:	e000      	b.n	43f0 <icmp_send_response+0x120>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
    43ee:	bf00      	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
    43f0:	f107 0718 	add.w	r7, r7, #24
    43f4:	46bd      	mov	sp, r7
    43f6:	bd80      	pop	{r7, pc}

000043f8 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
    43f8:	b480      	push	{r7}
    43fa:	b089      	sub	sp, #36	; 0x24
    43fc:	af00      	add	r7, sp, #0
    43fe:	6078      	str	r0, [r7, #4]
    4400:	6039      	str	r1, [r7, #0]
  u8_t *pb = (u8_t *)dataptr;
    4402:	687b      	ldr	r3, [r7, #4]
    4404:	613b      	str	r3, [r7, #16]
  u16_t *ps, t = 0;
    4406:	f04f 0300 	mov.w	r3, #0
    440a:	81fb      	strh	r3, [r7, #14]
  u32_t sum = 0;
    440c:	f04f 0300 	mov.w	r3, #0
    4410:	61bb      	str	r3, [r7, #24]
  int odd = ((mem_ptr_t)pb & 1);
    4412:	693b      	ldr	r3, [r7, #16]
    4414:	f003 0301 	and.w	r3, r3, #1
    4418:	61fb      	str	r3, [r7, #28]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    441a:	69fb      	ldr	r3, [r7, #28]
    441c:	2b00      	cmp	r3, #0
    441e:	d011      	beq.n	4444 <lwip_standard_chksum+0x4c>
    4420:	683b      	ldr	r3, [r7, #0]
    4422:	2b00      	cmp	r3, #0
    4424:	dd0e      	ble.n	4444 <lwip_standard_chksum+0x4c>
    ((u8_t *)&t)[1] = *pb++;
    4426:	f107 030e 	add.w	r3, r7, #14
    442a:	f103 0301 	add.w	r3, r3, #1
    442e:	693a      	ldr	r2, [r7, #16]
    4430:	7812      	ldrb	r2, [r2, #0]
    4432:	701a      	strb	r2, [r3, #0]
    4434:	693b      	ldr	r3, [r7, #16]
    4436:	f103 0301 	add.w	r3, r3, #1
    443a:	613b      	str	r3, [r7, #16]
    len--;
    443c:	683b      	ldr	r3, [r7, #0]
    443e:	f103 33ff 	add.w	r3, r3, #4294967295
    4442:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
    4444:	693b      	ldr	r3, [r7, #16]
    4446:	617b      	str	r3, [r7, #20]
  while (len > 1) {
    4448:	e00c      	b.n	4464 <lwip_standard_chksum+0x6c>
    sum += *ps++;
    444a:	697b      	ldr	r3, [r7, #20]
    444c:	881b      	ldrh	r3, [r3, #0]
    444e:	69ba      	ldr	r2, [r7, #24]
    4450:	4413      	add	r3, r2
    4452:	61bb      	str	r3, [r7, #24]
    4454:	697b      	ldr	r3, [r7, #20]
    4456:	f103 0302 	add.w	r3, r3, #2
    445a:	617b      	str	r3, [r7, #20]
    len -= 2;
    445c:	683b      	ldr	r3, [r7, #0]
    445e:	f1a3 0302 	sub.w	r3, r3, #2
    4462:	603b      	str	r3, [r7, #0]
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    4464:	683b      	ldr	r3, [r7, #0]
    4466:	2b01      	cmp	r3, #1
    4468:	dcef      	bgt.n	444a <lwip_standard_chksum+0x52>
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    446a:	683b      	ldr	r3, [r7, #0]
    446c:	2b00      	cmp	r3, #0
    446e:	dd04      	ble.n	447a <lwip_standard_chksum+0x82>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
    4470:	f107 030e 	add.w	r3, r7, #14
    4474:	697a      	ldr	r2, [r7, #20]
    4476:	7812      	ldrb	r2, [r2, #0]
    4478:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
    447a:	89fb      	ldrh	r3, [r7, #14]
    447c:	69ba      	ldr	r2, [r7, #24]
    447e:	4413      	add	r3, r2
    4480:	61bb      	str	r3, [r7, #24]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
    4482:	69bb      	ldr	r3, [r7, #24]
    4484:	ea4f 4213 	mov.w	r2, r3, lsr #16
    4488:	69bb      	ldr	r3, [r7, #24]
    448a:	ea4f 4303 	mov.w	r3, r3, lsl #16
    448e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4492:	4413      	add	r3, r2
    4494:	61bb      	str	r3, [r7, #24]
  sum = FOLD_U32T(sum);
    4496:	69bb      	ldr	r3, [r7, #24]
    4498:	ea4f 4213 	mov.w	r2, r3, lsr #16
    449c:	69bb      	ldr	r3, [r7, #24]
    449e:	ea4f 4303 	mov.w	r3, r3, lsl #16
    44a2:	ea4f 4313 	mov.w	r3, r3, lsr #16
    44a6:	4413      	add	r3, r2
    44a8:	61bb      	str	r3, [r7, #24]

  /* Swap if alignment was odd */
  if (odd) {
    44aa:	69fb      	ldr	r3, [r7, #28]
    44ac:	2b00      	cmp	r3, #0
    44ae:	d00e      	beq.n	44ce <lwip_standard_chksum+0xd6>
    sum = SWAP_BYTES_IN_WORD(sum);
    44b0:	69bb      	ldr	r3, [r7, #24]
    44b2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    44b6:	ea4f 4303 	mov.w	r3, r3, lsl #16
    44ba:	ea4f 4313 	mov.w	r3, r3, lsr #16
    44be:	69ba      	ldr	r2, [r7, #24]
    44c0:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    44c4:	ea4f 2212 	mov.w	r2, r2, lsr #8
    44c8:	ea43 0302 	orr.w	r3, r3, r2
    44cc:	61bb      	str	r3, [r7, #24]
  }

  return (u16_t)sum;
    44ce:	69bb      	ldr	r3, [r7, #24]
    44d0:	b29b      	uxth	r3, r3
}
    44d2:	4618      	mov	r0, r3
    44d4:	f107 0724 	add.w	r7, r7, #36	; 0x24
    44d8:	46bd      	mov	sp, r7
    44da:	bc80      	pop	{r7}
    44dc:	4770      	bx	lr
    44de:	bf00      	nop

000044e0 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
    44e0:	b580      	push	{r7, lr}
    44e2:	b088      	sub	sp, #32
    44e4:	af00      	add	r7, sp, #0
    44e6:	60f8      	str	r0, [r7, #12]
    44e8:	60b9      	str	r1, [r7, #8]
    44ea:	607a      	str	r2, [r7, #4]
    44ec:	70fb      	strb	r3, [r7, #3]
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    44ee:	f04f 0300 	mov.w	r3, #0
    44f2:	613b      	str	r3, [r7, #16]
  swapped = 0;
    44f4:	f04f 0300 	mov.w	r3, #0
    44f8:	77fb      	strb	r3, [r7, #31]
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    44fa:	68fb      	ldr	r3, [r7, #12]
    44fc:	61bb      	str	r3, [r7, #24]
    44fe:	e032      	b.n	4566 <inet_chksum_pseudo+0x86>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    4500:	69bb      	ldr	r3, [r7, #24]
    4502:	685a      	ldr	r2, [r3, #4]
    4504:	69bb      	ldr	r3, [r7, #24]
    4506:	895b      	ldrh	r3, [r3, #10]
    4508:	4610      	mov	r0, r2
    450a:	4619      	mov	r1, r3
    450c:	f7ff ff74 	bl	43f8 <lwip_standard_chksum>
    4510:	4603      	mov	r3, r0
    4512:	693a      	ldr	r2, [r7, #16]
    4514:	4413      	add	r3, r2
    4516:	613b      	str	r3, [r7, #16]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    4518:	693b      	ldr	r3, [r7, #16]
    451a:	ea4f 4213 	mov.w	r2, r3, lsr #16
    451e:	693b      	ldr	r3, [r7, #16]
    4520:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4524:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4528:	4413      	add	r3, r2
    452a:	613b      	str	r3, [r7, #16]
    if (q->len % 2 != 0) {
    452c:	69bb      	ldr	r3, [r7, #24]
    452e:	895b      	ldrh	r3, [r3, #10]
    4530:	f003 0301 	and.w	r3, r3, #1
    4534:	b2db      	uxtb	r3, r3
    4536:	2b00      	cmp	r3, #0
    4538:	d012      	beq.n	4560 <inet_chksum_pseudo+0x80>
      swapped = 1 - swapped;
    453a:	7ffb      	ldrb	r3, [r7, #31]
    453c:	f1c3 0301 	rsb	r3, r3, #1
    4540:	77fb      	strb	r3, [r7, #31]
      acc = SWAP_BYTES_IN_WORD(acc);
    4542:	693b      	ldr	r3, [r7, #16]
    4544:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4548:	ea4f 4303 	mov.w	r3, r3, lsl #16
    454c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4550:	693a      	ldr	r2, [r7, #16]
    4552:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    4556:	ea4f 2212 	mov.w	r2, r2, lsr #8
    455a:	ea43 0302 	orr.w	r3, r3, r2
    455e:	613b      	str	r3, [r7, #16]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    4560:	69bb      	ldr	r3, [r7, #24]
    4562:	681b      	ldr	r3, [r3, #0]
    4564:	61bb      	str	r3, [r7, #24]
    4566:	69bb      	ldr	r3, [r7, #24]
    4568:	2b00      	cmp	r3, #0
    456a:	d1c9      	bne.n	4500 <inet_chksum_pseudo+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    456c:	7ffb      	ldrb	r3, [r7, #31]
    456e:	2b00      	cmp	r3, #0
    4570:	d00e      	beq.n	4590 <inet_chksum_pseudo+0xb0>
    acc = SWAP_BYTES_IN_WORD(acc);
    4572:	693b      	ldr	r3, [r7, #16]
    4574:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4578:	ea4f 4303 	mov.w	r3, r3, lsl #16
    457c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4580:	693a      	ldr	r2, [r7, #16]
    4582:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    4586:	ea4f 2212 	mov.w	r2, r2, lsr #8
    458a:	ea43 0302 	orr.w	r3, r3, r2
    458e:	613b      	str	r3, [r7, #16]
  }
  addr = ip4_addr_get_u32(src);
    4590:	68bb      	ldr	r3, [r7, #8]
    4592:	681b      	ldr	r3, [r3, #0]
    4594:	617b      	str	r3, [r7, #20]
  acc += (addr & 0xffffUL);
    4596:	697b      	ldr	r3, [r7, #20]
    4598:	ea4f 4303 	mov.w	r3, r3, lsl #16
    459c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    45a0:	693a      	ldr	r2, [r7, #16]
    45a2:	4413      	add	r3, r2
    45a4:	613b      	str	r3, [r7, #16]
  acc += ((addr >> 16) & 0xffffUL);
    45a6:	697b      	ldr	r3, [r7, #20]
    45a8:	ea4f 4313 	mov.w	r3, r3, lsr #16
    45ac:	693a      	ldr	r2, [r7, #16]
    45ae:	4413      	add	r3, r2
    45b0:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
    45b2:	687b      	ldr	r3, [r7, #4]
    45b4:	681b      	ldr	r3, [r3, #0]
    45b6:	617b      	str	r3, [r7, #20]
  acc += (addr & 0xffffUL);
    45b8:	697b      	ldr	r3, [r7, #20]
    45ba:	ea4f 4303 	mov.w	r3, r3, lsl #16
    45be:	ea4f 4313 	mov.w	r3, r3, lsr #16
    45c2:	693a      	ldr	r2, [r7, #16]
    45c4:	4413      	add	r3, r2
    45c6:	613b      	str	r3, [r7, #16]
  acc += ((addr >> 16) & 0xffffUL);
    45c8:	697b      	ldr	r3, [r7, #20]
    45ca:	ea4f 4313 	mov.w	r3, r3, lsr #16
    45ce:	693a      	ldr	r2, [r7, #16]
    45d0:	4413      	add	r3, r2
    45d2:	613b      	str	r3, [r7, #16]
  acc += (u32_t)htons((u16_t)proto);
    45d4:	78fb      	ldrb	r3, [r7, #3]
    45d6:	4618      	mov	r0, r3
    45d8:	f7fd fc88 	bl	1eec <lwip_htons>
    45dc:	4603      	mov	r3, r0
    45de:	693a      	ldr	r2, [r7, #16]
    45e0:	4413      	add	r3, r2
    45e2:	613b      	str	r3, [r7, #16]
  acc += (u32_t)htons(proto_len);
    45e4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    45e6:	4618      	mov	r0, r3
    45e8:	f7fd fc80 	bl	1eec <lwip_htons>
    45ec:	4603      	mov	r3, r0
    45ee:	693a      	ldr	r2, [r7, #16]
    45f0:	4413      	add	r3, r2
    45f2:	613b      	str	r3, [r7, #16]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    45f4:	693b      	ldr	r3, [r7, #16]
    45f6:	ea4f 4213 	mov.w	r2, r3, lsr #16
    45fa:	693b      	ldr	r3, [r7, #16]
    45fc:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4600:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4604:	4413      	add	r3, r2
    4606:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
    4608:	693b      	ldr	r3, [r7, #16]
    460a:	ea4f 4213 	mov.w	r2, r3, lsr #16
    460e:	693b      	ldr	r3, [r7, #16]
    4610:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4614:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4618:	4413      	add	r3, r2
    461a:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
    461c:	693b      	ldr	r3, [r7, #16]
    461e:	b29b      	uxth	r3, r3
    4620:	ea6f 0303 	mvn.w	r3, r3
    4624:	b29b      	uxth	r3, r3
}
    4626:	4618      	mov	r0, r3
    4628:	f107 0720 	add.w	r7, r7, #32
    462c:	46bd      	mov	sp, r7
    462e:	bd80      	pop	{r7, pc}

00004630 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    4630:	b580      	push	{r7, lr}
    4632:	b082      	sub	sp, #8
    4634:	af00      	add	r7, sp, #0
    4636:	6078      	str	r0, [r7, #4]
    4638:	460b      	mov	r3, r1
    463a:	807b      	strh	r3, [r7, #2]
  return ~LWIP_CHKSUM(dataptr, len);
    463c:	887b      	ldrh	r3, [r7, #2]
    463e:	6878      	ldr	r0, [r7, #4]
    4640:	4619      	mov	r1, r3
    4642:	f7ff fed9 	bl	43f8 <lwip_standard_chksum>
    4646:	4603      	mov	r3, r0
    4648:	ea6f 0303 	mvn.w	r3, r3
    464c:	b29b      	uxth	r3, r3
}
    464e:	4618      	mov	r0, r3
    4650:	f107 0708 	add.w	r7, r7, #8
    4654:	46bd      	mov	sp, r7
    4656:	bd80      	pop	{r7, pc}

00004658 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    4658:	b580      	push	{r7, lr}
    465a:	b086      	sub	sp, #24
    465c:	af00      	add	r7, sp, #0
    465e:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    4660:	f04f 0300 	mov.w	r3, #0
    4664:	60fb      	str	r3, [r7, #12]
  swapped = 0;
    4666:	f04f 0300 	mov.w	r3, #0
    466a:	75fb      	strb	r3, [r7, #23]
  for(q = p; q != NULL; q = q->next) {
    466c:	687b      	ldr	r3, [r7, #4]
    466e:	613b      	str	r3, [r7, #16]
    4670:	e032      	b.n	46d8 <inet_chksum_pbuf+0x80>
    acc += LWIP_CHKSUM(q->payload, q->len);
    4672:	693b      	ldr	r3, [r7, #16]
    4674:	685a      	ldr	r2, [r3, #4]
    4676:	693b      	ldr	r3, [r7, #16]
    4678:	895b      	ldrh	r3, [r3, #10]
    467a:	4610      	mov	r0, r2
    467c:	4619      	mov	r1, r3
    467e:	f7ff febb 	bl	43f8 <lwip_standard_chksum>
    4682:	4603      	mov	r3, r0
    4684:	68fa      	ldr	r2, [r7, #12]
    4686:	4413      	add	r3, r2
    4688:	60fb      	str	r3, [r7, #12]
    acc = FOLD_U32T(acc);
    468a:	68fb      	ldr	r3, [r7, #12]
    468c:	ea4f 4213 	mov.w	r2, r3, lsr #16
    4690:	68fb      	ldr	r3, [r7, #12]
    4692:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4696:	ea4f 4313 	mov.w	r3, r3, lsr #16
    469a:	4413      	add	r3, r2
    469c:	60fb      	str	r3, [r7, #12]
    if (q->len % 2 != 0) {
    469e:	693b      	ldr	r3, [r7, #16]
    46a0:	895b      	ldrh	r3, [r3, #10]
    46a2:	f003 0301 	and.w	r3, r3, #1
    46a6:	b2db      	uxtb	r3, r3
    46a8:	2b00      	cmp	r3, #0
    46aa:	d012      	beq.n	46d2 <inet_chksum_pbuf+0x7a>
      swapped = 1 - swapped;
    46ac:	7dfb      	ldrb	r3, [r7, #23]
    46ae:	f1c3 0301 	rsb	r3, r3, #1
    46b2:	75fb      	strb	r3, [r7, #23]
      acc = SWAP_BYTES_IN_WORD(acc);
    46b4:	68fb      	ldr	r3, [r7, #12]
    46b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    46ba:	ea4f 4303 	mov.w	r3, r3, lsl #16
    46be:	ea4f 4313 	mov.w	r3, r3, lsr #16
    46c2:	68fa      	ldr	r2, [r7, #12]
    46c4:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    46c8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    46cc:	ea43 0302 	orr.w	r3, r3, r2
    46d0:	60fb      	str	r3, [r7, #12]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    46d2:	693b      	ldr	r3, [r7, #16]
    46d4:	681b      	ldr	r3, [r3, #0]
    46d6:	613b      	str	r3, [r7, #16]
    46d8:	693b      	ldr	r3, [r7, #16]
    46da:	2b00      	cmp	r3, #0
    46dc:	d1c9      	bne.n	4672 <inet_chksum_pbuf+0x1a>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    46de:	7dfb      	ldrb	r3, [r7, #23]
    46e0:	2b00      	cmp	r3, #0
    46e2:	d00e      	beq.n	4702 <inet_chksum_pbuf+0xaa>
    acc = SWAP_BYTES_IN_WORD(acc);
    46e4:	68fb      	ldr	r3, [r7, #12]
    46e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    46ea:	ea4f 4303 	mov.w	r3, r3, lsl #16
    46ee:	ea4f 4313 	mov.w	r3, r3, lsr #16
    46f2:	68fa      	ldr	r2, [r7, #12]
    46f4:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    46f8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    46fc:	ea43 0302 	orr.w	r3, r3, r2
    4700:	60fb      	str	r3, [r7, #12]
  }
  return (u16_t)~(acc & 0xffffUL);
    4702:	68fb      	ldr	r3, [r7, #12]
    4704:	b29b      	uxth	r3, r3
    4706:	ea6f 0303 	mvn.w	r3, r3
    470a:	b29b      	uxth	r3, r3
}
    470c:	4618      	mov	r0, r3
    470e:	f107 0718 	add.w	r7, r7, #24
    4712:	46bd      	mov	sp, r7
    4714:	bd80      	pop	{r7, pc}
    4716:	bf00      	nop

00004718 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
    4718:	b480      	push	{r7}
    471a:	b085      	sub	sp, #20
    471c:	af00      	add	r7, sp, #0
    471e:	6078      	str	r0, [r7, #4]
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    4720:	f247 0328 	movw	r3, #28712	; 0x7028
    4724:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4728:	681b      	ldr	r3, [r3, #0]
    472a:	60fb      	str	r3, [r7, #12]
    472c:	e018      	b.n	4760 <ip_route+0x48>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    472e:	68fb      	ldr	r3, [r7, #12]
    4730:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    4734:	f003 0301 	and.w	r3, r3, #1
    4738:	b2db      	uxtb	r3, r3
    473a:	2b00      	cmp	r3, #0
    473c:	d00d      	beq.n	475a <ip_route+0x42>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    473e:	687b      	ldr	r3, [r7, #4]
    4740:	681a      	ldr	r2, [r3, #0]
    4742:	68fb      	ldr	r3, [r7, #12]
    4744:	685b      	ldr	r3, [r3, #4]
    4746:	ea82 0203 	eor.w	r2, r2, r3
    474a:	68fb      	ldr	r3, [r7, #12]
    474c:	689b      	ldr	r3, [r3, #8]
    474e:	ea02 0303 	and.w	r3, r2, r3
    4752:	2b00      	cmp	r3, #0
    4754:	d101      	bne.n	475a <ip_route+0x42>
        /* return netif on which to forward IP packet */
        return netif;
    4756:	68fb      	ldr	r3, [r7, #12]
    4758:	e02e      	b.n	47b8 <ip_route+0xa0>
ip_route(ip_addr_t *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
    475a:	68fb      	ldr	r3, [r7, #12]
    475c:	681b      	ldr	r3, [r3, #0]
    475e:	60fb      	str	r3, [r7, #12]
    4760:	68fb      	ldr	r3, [r7, #12]
    4762:	2b00      	cmp	r3, #0
    4764:	d1e3      	bne.n	472e <ip_route+0x16>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    4766:	f247 032c 	movw	r3, #28716	; 0x702c
    476a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    476e:	681b      	ldr	r3, [r3, #0]
    4770:	2b00      	cmp	r3, #0
    4772:	d00a      	beq.n	478a <ip_route+0x72>
    4774:	f247 032c 	movw	r3, #28716	; 0x702c
    4778:	f2c2 0300 	movt	r3, #8192	; 0x2000
    477c:	681b      	ldr	r3, [r3, #0]
    477e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    4782:	f003 0301 	and.w	r3, r3, #1
    4786:	2b00      	cmp	r3, #0
    4788:	d111      	bne.n	47ae <ip_route+0x96>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    478a:	f247 0330 	movw	r3, #28720	; 0x7030
    478e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4792:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
    4796:	f103 0301 	add.w	r3, r3, #1
    479a:	b29a      	uxth	r2, r3
    479c:	f247 0330 	movw	r3, #28720	; 0x7030
    47a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    47a4:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    snmp_inc_ipoutnoroutes();
    return NULL;
    47a8:	f04f 0300 	mov.w	r3, #0
    47ac:	e004      	b.n	47b8 <ip_route+0xa0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
    47ae:	f247 032c 	movw	r3, #28716	; 0x702c
    47b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    47b6:	681b      	ldr	r3, [r3, #0]
}
    47b8:	4618      	mov	r0, r3
    47ba:	f107 0714 	add.w	r7, r7, #20
    47be:	46bd      	mov	sp, r7
    47c0:	bc80      	pop	{r7}
    47c2:	4770      	bx	lr

000047c4 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    47c4:	b580      	push	{r7, lr}
    47c6:	b086      	sub	sp, #24
    47c8:	af00      	add	r7, sp, #0
    47ca:	6078      	str	r0, [r7, #4]
    47cc:	6039      	str	r1, [r7, #0]
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
    47ce:	f247 0330 	movw	r3, #28720	; 0x7030
    47d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    47d6:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
    47da:	f103 0301 	add.w	r3, r3, #1
    47de:	b29a      	uxth	r2, r3
    47e0:	f247 0330 	movw	r3, #28720	; 0x7030
    47e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    47e8:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
    47ec:	687b      	ldr	r3, [r7, #4]
    47ee:	685b      	ldr	r3, [r3, #4]
    47f0:	60bb      	str	r3, [r7, #8]
  if (IPH_V(iphdr) != 4) {
    47f2:	68bb      	ldr	r3, [r7, #8]
    47f4:	781a      	ldrb	r2, [r3, #0]
    47f6:	785b      	ldrb	r3, [r3, #1]
    47f8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    47fc:	ea43 0302 	orr.w	r3, r3, r2
    4800:	b29b      	uxth	r3, r3
    4802:	4618      	mov	r0, r3
    4804:	f7fd fb8a 	bl	1f1c <lwip_ntohs>
    4808:	4603      	mov	r3, r0
    480a:	ea4f 3313 	mov.w	r3, r3, lsr #12
    480e:	b29b      	uxth	r3, r3
    4810:	2b04      	cmp	r3, #4
    4812:	d023      	beq.n	485c <ip_input+0x98>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    4814:	6878      	ldr	r0, [r7, #4]
    4816:	f7fe fc6d 	bl	30f4 <pbuf_free>
    IP_STATS_INC(ip.err);
    481a:	f247 0330 	movw	r3, #28720	; 0x7030
    481e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4822:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
    4826:	f103 0301 	add.w	r3, r3, #1
    482a:	b29a      	uxth	r2, r3
    482c:	f247 0330 	movw	r3, #28720	; 0x7030
    4830:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4834:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
    4838:	f247 0330 	movw	r3, #28720	; 0x7030
    483c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4840:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    4844:	f103 0301 	add.w	r3, r3, #1
    4848:	b29a      	uxth	r2, r3
    484a:	f247 0330 	movw	r3, #28720	; 0x7030
    484e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4852:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    4856:	f04f 0300 	mov.w	r3, #0
    485a:	e1c5      	b.n	4be8 <ip_input+0x424>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    485c:	68bb      	ldr	r3, [r7, #8]
    485e:	781a      	ldrb	r2, [r3, #0]
    4860:	785b      	ldrb	r3, [r3, #1]
    4862:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4866:	ea43 0302 	orr.w	r3, r3, r2
    486a:	b29b      	uxth	r3, r3
    486c:	4618      	mov	r0, r3
    486e:	f7fd fb55 	bl	1f1c <lwip_ntohs>
    4872:	4603      	mov	r3, r0
    4874:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4878:	b29b      	uxth	r3, r3
    487a:	f003 030f 	and.w	r3, r3, #15
    487e:	823b      	strh	r3, [r7, #16]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    4880:	8a3b      	ldrh	r3, [r7, #16]
    4882:	ea4f 0383 	mov.w	r3, r3, lsl #2
    4886:	823b      	strh	r3, [r7, #16]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    4888:	68bb      	ldr	r3, [r7, #8]
    488a:	789a      	ldrb	r2, [r3, #2]
    488c:	78db      	ldrb	r3, [r3, #3]
    488e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4892:	ea43 0302 	orr.w	r3, r3, r2
    4896:	b29b      	uxth	r3, r3
    4898:	4618      	mov	r0, r3
    489a:	f7fd fb3f 	bl	1f1c <lwip_ntohs>
    489e:	4603      	mov	r3, r0
    48a0:	827b      	strh	r3, [r7, #18]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    48a2:	687b      	ldr	r3, [r7, #4]
    48a4:	895b      	ldrh	r3, [r3, #10]
    48a6:	8a3a      	ldrh	r2, [r7, #16]
    48a8:	429a      	cmp	r2, r3
    48aa:	d804      	bhi.n	48b6 <ip_input+0xf2>
    48ac:	687b      	ldr	r3, [r7, #4]
    48ae:	891b      	ldrh	r3, [r3, #8]
    48b0:	8a7a      	ldrh	r2, [r7, #18]
    48b2:	429a      	cmp	r2, r3
    48b4:	d923      	bls.n	48fe <ip_input+0x13a>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    48b6:	6878      	ldr	r0, [r7, #4]
    48b8:	f7fe fc1c 	bl	30f4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    48bc:	f247 0330 	movw	r3, #28720	; 0x7030
    48c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48c4:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
    48c8:	f103 0301 	add.w	r3, r3, #1
    48cc:	b29a      	uxth	r2, r3
    48ce:	f247 0330 	movw	r3, #28720	; 0x7030
    48d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48d6:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    IP_STATS_INC(ip.drop);
    48da:	f247 0330 	movw	r3, #28720	; 0x7030
    48de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48e2:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    48e6:	f103 0301 	add.w	r3, r3, #1
    48ea:	b29a      	uxth	r2, r3
    48ec:	f247 0330 	movw	r3, #28720	; 0x7030
    48f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48f4:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    snmp_inc_ipindiscards();
    return ERR_OK;
    48f8:	f04f 0300 	mov.w	r3, #0
    48fc:	e174      	b.n	4be8 <ip_input+0x424>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    48fe:	8a3b      	ldrh	r3, [r7, #16]
    4900:	68b8      	ldr	r0, [r7, #8]
    4902:	4619      	mov	r1, r3
    4904:	f7ff fe94 	bl	4630 <inet_chksum>
    4908:	4603      	mov	r3, r0
    490a:	2b00      	cmp	r3, #0
    490c:	d023      	beq.n	4956 <ip_input+0x192>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    490e:	6878      	ldr	r0, [r7, #4]
    4910:	f7fe fbf0 	bl	30f4 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    4914:	f247 0330 	movw	r3, #28720	; 0x7030
    4918:	f2c2 0300 	movt	r3, #8192	; 0x2000
    491c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
    4920:	f103 0301 	add.w	r3, r3, #1
    4924:	b29a      	uxth	r2, r3
    4926:	f247 0330 	movw	r3, #28720	; 0x7030
    492a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    492e:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    IP_STATS_INC(ip.drop);
    4932:	f247 0330 	movw	r3, #28720	; 0x7030
    4936:	f2c2 0300 	movt	r3, #8192	; 0x2000
    493a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    493e:	f103 0301 	add.w	r3, r3, #1
    4942:	b29a      	uxth	r2, r3
    4944:	f247 0330 	movw	r3, #28720	; 0x7030
    4948:	f2c2 0300 	movt	r3, #8192	; 0x2000
    494c:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    4950:	f04f 0300 	mov.w	r3, #0
    4954:	e148      	b.n	4be8 <ip_input+0x424>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    4956:	8a7b      	ldrh	r3, [r7, #18]
    4958:	6878      	ldr	r0, [r7, #4]
    495a:	4619      	mov	r1, r3
    495c:	f7fe fae2 	bl	2f24 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4960:	68bb      	ldr	r3, [r7, #8]
    4962:	7c1a      	ldrb	r2, [r3, #16]
    4964:	7c59      	ldrb	r1, [r3, #17]
    4966:	ea4f 2101 	mov.w	r1, r1, lsl #8
    496a:	ea41 0202 	orr.w	r2, r1, r2
    496e:	7c99      	ldrb	r1, [r3, #18]
    4970:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4974:	ea41 0202 	orr.w	r2, r1, r2
    4978:	7cdb      	ldrb	r3, [r3, #19]
    497a:	ea4f 6303 	mov.w	r3, r3, lsl #24
    497e:	ea43 0302 	orr.w	r3, r3, r2
    4982:	461a      	mov	r2, r3
    4984:	f247 131c 	movw	r3, #28956	; 0x711c
    4988:	f2c2 0300 	movt	r3, #8192	; 0x2000
    498c:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
    498e:	68bb      	ldr	r3, [r7, #8]
    4990:	7b1a      	ldrb	r2, [r3, #12]
    4992:	7b59      	ldrb	r1, [r3, #13]
    4994:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4998:	ea41 0202 	orr.w	r2, r1, r2
    499c:	7b99      	ldrb	r1, [r3, #14]
    499e:	ea4f 4101 	mov.w	r1, r1, lsl #16
    49a2:	ea41 0202 	orr.w	r2, r1, r2
    49a6:	7bdb      	ldrb	r3, [r3, #15]
    49a8:	ea4f 6303 	mov.w	r3, r3, lsl #24
    49ac:	ea43 0302 	orr.w	r3, r3, r2
    49b0:	461a      	mov	r2, r3
    49b2:	f247 1314 	movw	r3, #28948	; 0x7114
    49b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49ba:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    49bc:	f04f 0301 	mov.w	r3, #1
    49c0:	617b      	str	r3, [r7, #20]
    netif = inp;
    49c2:	683b      	ldr	r3, [r7, #0]
    49c4:	60fb      	str	r3, [r7, #12]
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    49c6:	68fb      	ldr	r3, [r7, #12]
    49c8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    49cc:	f003 0301 	and.w	r3, r3, #1
    49d0:	b2db      	uxtb	r3, r3
    49d2:	2b00      	cmp	r3, #0
    49d4:	d01d      	beq.n	4a12 <ip_input+0x24e>
    49d6:	68fb      	ldr	r3, [r7, #12]
    49d8:	f103 0304 	add.w	r3, r3, #4
    49dc:	2b00      	cmp	r3, #0
    49de:	d018      	beq.n	4a12 <ip_input+0x24e>
    49e0:	68fb      	ldr	r3, [r7, #12]
    49e2:	685b      	ldr	r3, [r3, #4]
    49e4:	2b00      	cmp	r3, #0
    49e6:	d014      	beq.n	4a12 <ip_input+0x24e>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    49e8:	f247 131c 	movw	r3, #28956	; 0x711c
    49ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49f0:	681a      	ldr	r2, [r3, #0]
    49f2:	68fb      	ldr	r3, [r7, #12]
    49f4:	685b      	ldr	r3, [r3, #4]
    49f6:	429a      	cmp	r2, r3
    49f8:	d025      	beq.n	4a46 <ip_input+0x282>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    49fa:	f247 131c 	movw	r3, #28956	; 0x711c
    49fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a02:	681b      	ldr	r3, [r3, #0]
    4a04:	4618      	mov	r0, r3
    4a06:	68f9      	ldr	r1, [r7, #12]
    4a08:	f000 fb34 	bl	5074 <ip4_addr_isbroadcast>
    4a0c:	4603      	mov	r3, r0
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4a0e:	2b00      	cmp	r3, #0
    4a10:	d119      	bne.n	4a46 <ip_input+0x282>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
    4a12:	697b      	ldr	r3, [r7, #20]
    4a14:	2b00      	cmp	r3, #0
    4a16:	d009      	beq.n	4a2c <ip_input+0x268>
        first = 0;
    4a18:	f04f 0300 	mov.w	r3, #0
    4a1c:	617b      	str	r3, [r7, #20]
        netif = netif_list;
    4a1e:	f247 0328 	movw	r3, #28712	; 0x7028
    4a22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a26:	681b      	ldr	r3, [r3, #0]
    4a28:	60fb      	str	r3, [r7, #12]
    4a2a:	e002      	b.n	4a32 <ip_input+0x26e>
      } else {
        netif = netif->next;
    4a2c:	68fb      	ldr	r3, [r7, #12]
    4a2e:	681b      	ldr	r3, [r3, #0]
    4a30:	60fb      	str	r3, [r7, #12]
      }
      if (netif == inp) {
    4a32:	68fa      	ldr	r2, [r7, #12]
    4a34:	683b      	ldr	r3, [r7, #0]
    4a36:	429a      	cmp	r2, r3
    4a38:	d102      	bne.n	4a40 <ip_input+0x27c>
        netif = netif->next;
    4a3a:	68fb      	ldr	r3, [r7, #12]
    4a3c:	681b      	ldr	r3, [r3, #0]
    4a3e:	60fb      	str	r3, [r7, #12]
      }
    } while(netif != NULL);
    4a40:	68fb      	ldr	r3, [r7, #12]
    4a42:	2b00      	cmp	r3, #0
    4a44:	d1bf      	bne.n	49c6 <ip_input+0x202>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    4a46:	f247 1314 	movw	r3, #28948	; 0x7114
    4a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a4e:	681b      	ldr	r3, [r3, #0]
    4a50:	4618      	mov	r0, r3
    4a52:	6839      	ldr	r1, [r7, #0]
    4a54:	f000 fb0e 	bl	5074 <ip4_addr_isbroadcast>
    4a58:	4603      	mov	r3, r0
    4a5a:	2b00      	cmp	r3, #0
    4a5c:	d108      	bne.n	4a70 <ip_input+0x2ac>
         (ip_addr_ismulticast(&current_iphdr_src))) {
    4a5e:	f247 1314 	movw	r3, #28948	; 0x7114
    4a62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a66:	681b      	ldr	r3, [r3, #0]
    4a68:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    4a6c:	2be0      	cmp	r3, #224	; 0xe0
    4a6e:	d114      	bne.n	4a9a <ip_input+0x2d6>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    4a70:	6878      	ldr	r0, [r7, #4]
    4a72:	f7fe fb3f 	bl	30f4 <pbuf_free>
      IP_STATS_INC(ip.drop);
    4a76:	f247 0330 	movw	r3, #28720	; 0x7030
    4a7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a7e:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    4a82:	f103 0301 	add.w	r3, r3, #1
    4a86:	b29a      	uxth	r2, r3
    4a88:	f247 0330 	movw	r3, #28720	; 0x7030
    4a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a90:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    4a94:	f04f 0300 	mov.w	r3, #0
    4a98:	e0a6      	b.n	4be8 <ip_input+0x424>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    4a9a:	68fb      	ldr	r3, [r7, #12]
    4a9c:	2b00      	cmp	r3, #0
    4a9e:	d105      	bne.n	4aac <ip_input+0x2e8>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    4aa0:	6878      	ldr	r0, [r7, #4]
    4aa2:	f7fe fb27 	bl	30f4 <pbuf_free>
    return ERR_OK;
    4aa6:	f04f 0300 	mov.w	r3, #0
    4aaa:	e09d      	b.n	4be8 <ip_input+0x424>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    4aac:	68bb      	ldr	r3, [r7, #8]
    4aae:	799a      	ldrb	r2, [r3, #6]
    4ab0:	79db      	ldrb	r3, [r3, #7]
    4ab2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4ab6:	ea43 0302 	orr.w	r3, r3, r2
    4aba:	b29b      	uxth	r3, r3
    4abc:	461a      	mov	r2, r3
    4abe:	f64f 733f 	movw	r3, #65343	; 0xff3f
    4ac2:	f2c0 0300 	movt	r3, #0
    4ac6:	ea02 0303 	and.w	r3, r2, r3
    4aca:	2b00      	cmp	r3, #0
    4acc:	d00d      	beq.n	4aea <ip_input+0x326>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    4ace:	6878      	ldr	r0, [r7, #4]
    4ad0:	f000 fed8 	bl	5884 <ip_reass>
    4ad4:	4603      	mov	r3, r0
    4ad6:	607b      	str	r3, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    4ad8:	687b      	ldr	r3, [r7, #4]
    4ada:	2b00      	cmp	r3, #0
    4adc:	d102      	bne.n	4ae4 <ip_input+0x320>
      return ERR_OK;
    4ade:	f04f 0300 	mov.w	r3, #0
    4ae2:	e081      	b.n	4be8 <ip_input+0x424>
    }
    iphdr = (struct ip_hdr *)p->payload;
    4ae4:	687b      	ldr	r3, [r7, #4]
    4ae6:	685b      	ldr	r3, [r3, #4]
    4ae8:	60bb      	str	r3, [r7, #8]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    4aea:	f247 1318 	movw	r3, #28952	; 0x7118
    4aee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4af2:	683a      	ldr	r2, [r7, #0]
    4af4:	601a      	str	r2, [r3, #0]
  current_header = iphdr;
    4af6:	f247 1320 	movw	r3, #28960	; 0x7120
    4afa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4afe:	68ba      	ldr	r2, [r7, #8]
    4b00:	601a      	str	r2, [r3, #0]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    4b02:	6878      	ldr	r0, [r7, #4]
    4b04:	6839      	ldr	r1, [r7, #0]
    4b06:	f7fe fc53 	bl	33b0 <raw_input>
    4b0a:	4603      	mov	r3, r0
    4b0c:	2b00      	cmp	r3, #0
    4b0e:	d14d      	bne.n	4bac <ip_input+0x3e8>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
    4b10:	68bb      	ldr	r3, [r7, #8]
    4b12:	7a5b      	ldrb	r3, [r3, #9]
    4b14:	2b01      	cmp	r3, #1
    4b16:	d006      	beq.n	4b26 <ip_input+0x362>
    4b18:	2b11      	cmp	r3, #17
    4b1a:	d109      	bne.n	4b30 <ip_input+0x36c>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    4b1c:	6878      	ldr	r0, [r7, #4]
    4b1e:	6839      	ldr	r1, [r7, #0]
    4b20:	f7fe fd8e 	bl	3640 <udp_input>
      break;
    4b24:	e042      	b.n	4bac <ip_input+0x3e8>
      break;
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    4b26:	6878      	ldr	r0, [r7, #4]
    4b28:	6839      	ldr	r1, [r7, #0]
    4b2a:	f7ff f987 	bl	3e3c <icmp_input>
      break;
    4b2e:	e03d      	b.n	4bac <ip_input+0x3e8>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    4b30:	f247 131c 	movw	r3, #28956	; 0x711c
    4b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b38:	681b      	ldr	r3, [r3, #0]
    4b3a:	4618      	mov	r0, r3
    4b3c:	6839      	ldr	r1, [r7, #0]
    4b3e:	f000 fa99 	bl	5074 <ip4_addr_isbroadcast>
    4b42:	4603      	mov	r3, r0
    4b44:	2b00      	cmp	r3, #0
    4b46:	d110      	bne.n	4b6a <ip_input+0x3a6>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    4b48:	f247 131c 	movw	r3, #28956	; 0x711c
    4b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b50:	681b      	ldr	r3, [r3, #0]
    4b52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    4b56:	2be0      	cmp	r3, #224	; 0xe0
    4b58:	d007      	beq.n	4b6a <ip_input+0x3a6>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
    4b5a:	687b      	ldr	r3, [r7, #4]
    4b5c:	68ba      	ldr	r2, [r7, #8]
    4b5e:	605a      	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    4b60:	6878      	ldr	r0, [r7, #4]
    4b62:	f04f 0102 	mov.w	r1, #2
    4b66:	f7ff fb8f 	bl	4288 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    4b6a:	6878      	ldr	r0, [r7, #4]
    4b6c:	f7fe fac2 	bl	30f4 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    4b70:	f247 0330 	movw	r3, #28720	; 0x7030
    4b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b78:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
    4b7c:	f103 0301 	add.w	r3, r3, #1
    4b80:	b29a      	uxth	r2, r3
    4b82:	f247 0330 	movw	r3, #28720	; 0x7030
    4b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b8a:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
      IP_STATS_INC(ip.drop);
    4b8e:	f247 0330 	movw	r3, #28720	; 0x7030
    4b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b96:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    4b9a:	f103 0301 	add.w	r3, r3, #1
    4b9e:	b29a      	uxth	r2, r3
    4ba0:	f247 0330 	movw	r3, #28720	; 0x7030
    4ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ba8:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    4bac:	f247 1318 	movw	r3, #28952	; 0x7118
    4bb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bb4:	f04f 0200 	mov.w	r2, #0
    4bb8:	601a      	str	r2, [r3, #0]
  current_header = NULL;
    4bba:	f247 1320 	movw	r3, #28960	; 0x7120
    4bbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bc2:	f04f 0200 	mov.w	r2, #0
    4bc6:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_src);
    4bc8:	f247 1314 	movw	r3, #28948	; 0x7114
    4bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bd0:	f04f 0200 	mov.w	r2, #0
    4bd4:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_dest);
    4bd6:	f247 131c 	movw	r3, #28956	; 0x711c
    4bda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bde:	f04f 0200 	mov.w	r2, #0
    4be2:	601a      	str	r2, [r3, #0]

  return ERR_OK;
    4be4:	f04f 0300 	mov.w	r3, #0
    4be8:	b25b      	sxtb	r3, r3
}
    4bea:	4618      	mov	r0, r3
    4bec:	f107 0718 	add.w	r7, r7, #24
    4bf0:	46bd      	mov	sp, r7
    4bf2:	bd80      	pop	{r7, pc}

00004bf4 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    4bf4:	b580      	push	{r7, lr}
    4bf6:	b088      	sub	sp, #32
    4bf8:	af00      	add	r7, sp, #0
    4bfa:	60f8      	str	r0, [r7, #12]
    4bfc:	60b9      	str	r1, [r7, #8]
    4bfe:	607a      	str	r2, [r7, #4]
    4c00:	70fb      	strb	r3, [r7, #3]
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
    4c02:	f04f 0300 	mov.w	r3, #0
    4c06:	61bb      	str	r3, [r7, #24]
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    4c08:	687b      	ldr	r3, [r7, #4]
    4c0a:	2b00      	cmp	r3, #0
    4c0c:	f000 81b0 	beq.w	4f70 <ip_output_if+0x37c>
    u16_t ip_hlen = IP_HLEN;
    4c10:	f04f 0314 	mov.w	r3, #20
    4c14:	83fb      	strh	r3, [r7, #30]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    4c16:	68f8      	ldr	r0, [r7, #12]
    4c18:	f04f 0114 	mov.w	r1, #20
    4c1c:	f7fe f9ee 	bl	2ffc <pbuf_header>
    4c20:	4603      	mov	r3, r0
    4c22:	2b00      	cmp	r3, #0
    4c24:	d011      	beq.n	4c4a <ip_output_if+0x56>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    4c26:	f247 0330 	movw	r3, #28720	; 0x7030
    4c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c2e:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
    4c32:	f103 0301 	add.w	r3, r3, #1
    4c36:	b29a      	uxth	r2, r3
    4c38:	f247 0330 	movw	r3, #28720	; 0x7030
    4c3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c40:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    4c44:	f04f 03fe 	mov.w	r3, #254	; 0xfe
    4c48:	e1d5      	b.n	4ff6 <ip_output_if+0x402>
    }

    iphdr = (struct ip_hdr *)p->payload;
    4c4a:	68fb      	ldr	r3, [r7, #12]
    4c4c:	685b      	ldr	r3, [r3, #4]
    4c4e:	617b      	str	r3, [r7, #20]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    4c50:	697b      	ldr	r3, [r7, #20]
    4c52:	78fa      	ldrb	r2, [r7, #3]
    4c54:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
    4c56:	697b      	ldr	r3, [r7, #20]
    4c58:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
    4c5c:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    4c5e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    4c62:	ea4f 2203 	mov.w	r2, r3, lsl #8
    4c66:	78fb      	ldrb	r3, [r7, #3]
    4c68:	ea42 0303 	orr.w	r3, r2, r3
    4c6c:	69ba      	ldr	r2, [r7, #24]
    4c6e:	4413      	add	r3, r2
    4c70:	61bb      	str	r3, [r7, #24]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
    4c72:	687b      	ldr	r3, [r7, #4]
    4c74:	681a      	ldr	r2, [r3, #0]
    4c76:	697b      	ldr	r3, [r7, #20]
    4c78:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4c7c:	f04f 0000 	mov.w	r0, #0
    4c80:	ea40 0101 	orr.w	r1, r0, r1
    4c84:	7419      	strb	r1, [r3, #16]
    4c86:	ea4f 2112 	mov.w	r1, r2, lsr #8
    4c8a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4c8e:	f04f 0000 	mov.w	r0, #0
    4c92:	ea40 0101 	orr.w	r1, r0, r1
    4c96:	7459      	strb	r1, [r3, #17]
    4c98:	ea4f 4112 	mov.w	r1, r2, lsr #16
    4c9c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4ca0:	f04f 0000 	mov.w	r0, #0
    4ca4:	ea40 0101 	orr.w	r1, r0, r1
    4ca8:	7499      	strb	r1, [r3, #18]
    4caa:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4cae:	f04f 0100 	mov.w	r1, #0
    4cb2:	ea41 0202 	orr.w	r2, r1, r2
    4cb6:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    4cb8:	697b      	ldr	r3, [r7, #20]
    4cba:	7c1a      	ldrb	r2, [r3, #16]
    4cbc:	7c59      	ldrb	r1, [r3, #17]
    4cbe:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4cc2:	ea41 0202 	orr.w	r2, r1, r2
    4cc6:	7c99      	ldrb	r1, [r3, #18]
    4cc8:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4ccc:	ea41 0202 	orr.w	r2, r1, r2
    4cd0:	7cdb      	ldrb	r3, [r3, #19]
    4cd2:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4cd6:	ea43 0302 	orr.w	r3, r3, r2
    4cda:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4cde:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4ce2:	69ba      	ldr	r2, [r7, #24]
    4ce4:	4413      	add	r3, r2
    4ce6:	61bb      	str	r3, [r7, #24]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    4ce8:	697b      	ldr	r3, [r7, #20]
    4cea:	7c1a      	ldrb	r2, [r3, #16]
    4cec:	7c59      	ldrb	r1, [r3, #17]
    4cee:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4cf2:	ea41 0202 	orr.w	r2, r1, r2
    4cf6:	7c99      	ldrb	r1, [r3, #18]
    4cf8:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4cfc:	ea41 0202 	orr.w	r2, r1, r2
    4d00:	7cdb      	ldrb	r3, [r3, #19]
    4d02:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4d06:	ea43 0302 	orr.w	r3, r3, r2
    4d0a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4d0e:	69ba      	ldr	r2, [r7, #24]
    4d10:	4413      	add	r3, r2
    4d12:	61bb      	str	r3, [r7, #24]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
    4d14:	8bfb      	ldrh	r3, [r7, #30]
    4d16:	ea4f 0393 	mov.w	r3, r3, lsr #2
    4d1a:	b29b      	uxth	r3, r3
    4d1c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4d20:	b29b      	uxth	r3, r3
    4d22:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    4d26:	b29a      	uxth	r2, r3
    4d28:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    4d2c:	ea42 0303 	orr.w	r3, r2, r3
    4d30:	b29b      	uxth	r3, r3
    4d32:	b29b      	uxth	r3, r3
    4d34:	4618      	mov	r0, r3
    4d36:	f7fd f8d9 	bl	1eec <lwip_htons>
    4d3a:	4603      	mov	r3, r0
    4d3c:	461a      	mov	r2, r3
    4d3e:	697b      	ldr	r3, [r7, #20]
    4d40:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4d44:	f04f 0000 	mov.w	r0, #0
    4d48:	ea40 0101 	orr.w	r1, r0, r1
    4d4c:	7019      	strb	r1, [r3, #0]
    4d4e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4d52:	b292      	uxth	r2, r2
    4d54:	f04f 0100 	mov.w	r1, #0
    4d58:	ea41 0202 	orr.w	r2, r1, r2
    4d5c:	705a      	strb	r2, [r3, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_v_hl_tos;
    4d5e:	697b      	ldr	r3, [r7, #20]
    4d60:	781a      	ldrb	r2, [r3, #0]
    4d62:	785b      	ldrb	r3, [r3, #1]
    4d64:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4d68:	ea43 0302 	orr.w	r3, r3, r2
    4d6c:	b29b      	uxth	r3, r3
    4d6e:	69ba      	ldr	r2, [r7, #24]
    4d70:	4413      	add	r3, r2
    4d72:	61bb      	str	r3, [r7, #24]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    4d74:	68fb      	ldr	r3, [r7, #12]
    4d76:	891b      	ldrh	r3, [r3, #8]
    4d78:	4618      	mov	r0, r3
    4d7a:	f7fd f8b7 	bl	1eec <lwip_htons>
    4d7e:	4603      	mov	r3, r0
    4d80:	461a      	mov	r2, r3
    4d82:	697b      	ldr	r3, [r7, #20]
    4d84:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4d88:	f04f 0000 	mov.w	r0, #0
    4d8c:	ea40 0101 	orr.w	r1, r0, r1
    4d90:	7099      	strb	r1, [r3, #2]
    4d92:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4d96:	b292      	uxth	r2, r2
    4d98:	f04f 0100 	mov.w	r1, #0
    4d9c:	ea41 0202 	orr.w	r2, r1, r2
    4da0:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
    4da2:	697b      	ldr	r3, [r7, #20]
    4da4:	789a      	ldrb	r2, [r3, #2]
    4da6:	78db      	ldrb	r3, [r3, #3]
    4da8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4dac:	ea43 0302 	orr.w	r3, r3, r2
    4db0:	b29b      	uxth	r3, r3
    4db2:	69ba      	ldr	r2, [r7, #24]
    4db4:	4413      	add	r3, r2
    4db6:	61bb      	str	r3, [r7, #24]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    4db8:	697b      	ldr	r3, [r7, #20]
    4dba:	f04f 0200 	mov.w	r2, #0
    4dbe:	719a      	strb	r2, [r3, #6]
    4dc0:	f04f 0200 	mov.w	r2, #0
    4dc4:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
    4dc6:	f243 1344 	movw	r3, #12612	; 0x3144
    4dca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dce:	881b      	ldrh	r3, [r3, #0]
    4dd0:	4618      	mov	r0, r3
    4dd2:	f7fd f88b 	bl	1eec <lwip_htons>
    4dd6:	4603      	mov	r3, r0
    4dd8:	461a      	mov	r2, r3
    4dda:	697b      	ldr	r3, [r7, #20]
    4ddc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4de0:	f04f 0000 	mov.w	r0, #0
    4de4:	ea40 0101 	orr.w	r1, r0, r1
    4de8:	7119      	strb	r1, [r3, #4]
    4dea:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4dee:	b292      	uxth	r2, r2
    4df0:	f04f 0100 	mov.w	r1, #0
    4df4:	ea41 0202 	orr.w	r2, r1, r2
    4df8:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
    4dfa:	697b      	ldr	r3, [r7, #20]
    4dfc:	791a      	ldrb	r2, [r3, #4]
    4dfe:	795b      	ldrb	r3, [r3, #5]
    4e00:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4e04:	ea43 0302 	orr.w	r3, r3, r2
    4e08:	b29b      	uxth	r3, r3
    4e0a:	69ba      	ldr	r2, [r7, #24]
    4e0c:	4413      	add	r3, r2
    4e0e:	61bb      	str	r3, [r7, #24]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
    4e10:	f243 1344 	movw	r3, #12612	; 0x3144
    4e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e18:	881b      	ldrh	r3, [r3, #0]
    4e1a:	f103 0301 	add.w	r3, r3, #1
    4e1e:	b29a      	uxth	r2, r3
    4e20:	f243 1344 	movw	r3, #12612	; 0x3144
    4e24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e28:	801a      	strh	r2, [r3, #0]

    if (ip_addr_isany(src)) {
    4e2a:	68bb      	ldr	r3, [r7, #8]
    4e2c:	2b00      	cmp	r3, #0
    4e2e:	d003      	beq.n	4e38 <ip_output_if+0x244>
    4e30:	68bb      	ldr	r3, [r7, #8]
    4e32:	681b      	ldr	r3, [r3, #0]
    4e34:	2b00      	cmp	r3, #0
    4e36:	d123      	bne.n	4e80 <ip_output_if+0x28c>
      ip_addr_copy(iphdr->src, netif->ip_addr);
    4e38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    4e3a:	685a      	ldr	r2, [r3, #4]
    4e3c:	697b      	ldr	r3, [r7, #20]
    4e3e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4e42:	f04f 0000 	mov.w	r0, #0
    4e46:	ea40 0101 	orr.w	r1, r0, r1
    4e4a:	7319      	strb	r1, [r3, #12]
    4e4c:	ea4f 2112 	mov.w	r1, r2, lsr #8
    4e50:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4e54:	f04f 0000 	mov.w	r0, #0
    4e58:	ea40 0101 	orr.w	r1, r0, r1
    4e5c:	7359      	strb	r1, [r3, #13]
    4e5e:	ea4f 4112 	mov.w	r1, r2, lsr #16
    4e62:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4e66:	f04f 0000 	mov.w	r0, #0
    4e6a:	ea40 0101 	orr.w	r1, r0, r1
    4e6e:	7399      	strb	r1, [r3, #14]
    4e70:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4e74:	f04f 0100 	mov.w	r1, #0
    4e78:	ea41 0202 	orr.w	r2, r1, r2
    4e7c:	73da      	strb	r2, [r3, #15]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;

    if (ip_addr_isany(src)) {
    4e7e:	e022      	b.n	4ec6 <ip_output_if+0x2d2>
      ip_addr_copy(iphdr->src, netif->ip_addr);
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    4e80:	68bb      	ldr	r3, [r7, #8]
    4e82:	681a      	ldr	r2, [r3, #0]
    4e84:	697b      	ldr	r3, [r7, #20]
    4e86:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4e8a:	f04f 0000 	mov.w	r0, #0
    4e8e:	ea40 0101 	orr.w	r1, r0, r1
    4e92:	7319      	strb	r1, [r3, #12]
    4e94:	ea4f 2112 	mov.w	r1, r2, lsr #8
    4e98:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4e9c:	f04f 0000 	mov.w	r0, #0
    4ea0:	ea40 0101 	orr.w	r1, r0, r1
    4ea4:	7359      	strb	r1, [r3, #13]
    4ea6:	ea4f 4112 	mov.w	r1, r2, lsr #16
    4eaa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    4eae:	f04f 0000 	mov.w	r0, #0
    4eb2:	ea40 0101 	orr.w	r1, r0, r1
    4eb6:	7399      	strb	r1, [r3, #14]
    4eb8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    4ebc:	f04f 0100 	mov.w	r1, #0
    4ec0:	ea41 0202 	orr.w	r2, r1, r2
    4ec4:	73da      	strb	r2, [r3, #15]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    4ec6:	697b      	ldr	r3, [r7, #20]
    4ec8:	7b1a      	ldrb	r2, [r3, #12]
    4eca:	7b59      	ldrb	r1, [r3, #13]
    4ecc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4ed0:	ea41 0202 	orr.w	r2, r1, r2
    4ed4:	7b99      	ldrb	r1, [r3, #14]
    4ed6:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4eda:	ea41 0202 	orr.w	r2, r1, r2
    4ede:	7bdb      	ldrb	r3, [r3, #15]
    4ee0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4ee4:	ea43 0302 	orr.w	r3, r3, r2
    4ee8:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4eec:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4ef0:	69ba      	ldr	r2, [r7, #24]
    4ef2:	4413      	add	r3, r2
    4ef4:	61bb      	str	r3, [r7, #24]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    4ef6:	697b      	ldr	r3, [r7, #20]
    4ef8:	7b1a      	ldrb	r2, [r3, #12]
    4efa:	7b59      	ldrb	r1, [r3, #13]
    4efc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f00:	ea41 0202 	orr.w	r2, r1, r2
    4f04:	7b99      	ldrb	r1, [r3, #14]
    4f06:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4f0a:	ea41 0202 	orr.w	r2, r1, r2
    4f0e:	7bdb      	ldrb	r3, [r3, #15]
    4f10:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f14:	ea43 0302 	orr.w	r3, r3, r2
    4f18:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4f1c:	69ba      	ldr	r2, [r7, #24]
    4f1e:	4413      	add	r3, r2
    4f20:	61bb      	str	r3, [r7, #24]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    4f22:	69bb      	ldr	r3, [r7, #24]
    4f24:	ea4f 4213 	mov.w	r2, r3, lsr #16
    4f28:	69bb      	ldr	r3, [r7, #24]
    4f2a:	ea4f 4303 	mov.w	r3, r3, lsl #16
    4f2e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4f32:	4413      	add	r3, r2
    4f34:	61bb      	str	r3, [r7, #24]
    chk_sum = (chk_sum >> 16) + chk_sum;
    4f36:	69bb      	ldr	r3, [r7, #24]
    4f38:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4f3c:	69ba      	ldr	r2, [r7, #24]
    4f3e:	4413      	add	r3, r2
    4f40:	61bb      	str	r3, [r7, #24]
    chk_sum = ~chk_sum;
    4f42:	69bb      	ldr	r3, [r7, #24]
    4f44:	ea6f 0303 	mvn.w	r3, r3
    4f48:	61bb      	str	r3, [r7, #24]
    iphdr->_chksum = chk_sum; /* network order */
    4f4a:	69bb      	ldr	r3, [r7, #24]
    4f4c:	b29a      	uxth	r2, r3
    4f4e:	697b      	ldr	r3, [r7, #20]
    4f50:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    4f54:	f04f 0000 	mov.w	r0, #0
    4f58:	ea40 0101 	orr.w	r1, r0, r1
    4f5c:	7299      	strb	r1, [r3, #10]
    4f5e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    4f62:	b292      	uxth	r2, r2
    4f64:	f04f 0100 	mov.w	r1, #0
    4f68:	ea41 0202 	orr.w	r2, r1, r2
    4f6c:	72da      	strb	r2, [r3, #11]
    4f6e:	e017      	b.n	4fa0 <ip_output_if+0x3ac>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    4f70:	68fb      	ldr	r3, [r7, #12]
    4f72:	685b      	ldr	r3, [r3, #4]
    4f74:	617b      	str	r3, [r7, #20]
    ip_addr_copy(dest_addr, iphdr->dest);
    4f76:	697b      	ldr	r3, [r7, #20]
    4f78:	7c1a      	ldrb	r2, [r3, #16]
    4f7a:	7c59      	ldrb	r1, [r3, #17]
    4f7c:	ea4f 2101 	mov.w	r1, r1, lsl #8
    4f80:	ea41 0202 	orr.w	r2, r1, r2
    4f84:	7c99      	ldrb	r1, [r3, #18]
    4f86:	ea4f 4101 	mov.w	r1, r1, lsl #16
    4f8a:	ea41 0202 	orr.w	r2, r1, r2
    4f8e:	7cdb      	ldrb	r3, [r3, #19]
    4f90:	ea4f 6303 	mov.w	r3, r3, lsl #24
    4f94:	ea43 0302 	orr.w	r3, r3, r2
    4f98:	613b      	str	r3, [r7, #16]
    dest = &dest_addr;
    4f9a:	f107 0310 	add.w	r3, r7, #16
    4f9e:	607b      	str	r3, [r7, #4]
  }

  IP_STATS_INC(ip.xmit);
    4fa0:	f247 0330 	movw	r3, #28720	; 0x7030
    4fa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fa8:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
    4fac:	f103 0301 	add.w	r3, r3, #1
    4fb0:	b29a      	uxth	r2, r3
    4fb2:	f247 0330 	movw	r3, #28720	; 0x7030
    4fb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fba:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    4fbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    4fc0:	8c1b      	ldrh	r3, [r3, #32]
    4fc2:	2b00      	cmp	r3, #0
    4fc4:	d00e      	beq.n	4fe4 <ip_output_if+0x3f0>
    4fc6:	68fb      	ldr	r3, [r7, #12]
    4fc8:	891a      	ldrh	r2, [r3, #8]
    4fca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    4fcc:	8c1b      	ldrh	r3, [r3, #32]
    4fce:	429a      	cmp	r2, r3
    4fd0:	d908      	bls.n	4fe4 <ip_output_if+0x3f0>
    return ip_frag(p, netif, dest);
    4fd2:	68f8      	ldr	r0, [r7, #12]
    4fd4:	6b39      	ldr	r1, [r7, #48]	; 0x30
    4fd6:	687a      	ldr	r2, [r7, #4]
    4fd8:	f000 fea2 	bl	5d20 <ip_frag>
    4fdc:	4603      	mov	r3, r0
    4fde:	b2db      	uxtb	r3, r3
    4fe0:	b2db      	uxtb	r3, r3
    4fe2:	e008      	b.n	4ff6 <ip_output_if+0x402>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    4fe4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    4fe6:	695b      	ldr	r3, [r3, #20]
    4fe8:	6b38      	ldr	r0, [r7, #48]	; 0x30
    4fea:	68f9      	ldr	r1, [r7, #12]
    4fec:	687a      	ldr	r2, [r7, #4]
    4fee:	4798      	blx	r3
    4ff0:	4603      	mov	r3, r0
    4ff2:	b2db      	uxtb	r3, r3
    4ff4:	b2db      	uxtb	r3, r3
    4ff6:	b25b      	sxtb	r3, r3
}
    4ff8:	4618      	mov	r0, r3
    4ffa:	f107 0720 	add.w	r7, r7, #32
    4ffe:	46bd      	mov	sp, r7
    5000:	bd80      	pop	{r7, pc}
    5002:	bf00      	nop

00005004 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    5004:	b580      	push	{r7, lr}
    5006:	b08a      	sub	sp, #40	; 0x28
    5008:	af04      	add	r7, sp, #16
    500a:	60f8      	str	r0, [r7, #12]
    500c:	60b9      	str	r1, [r7, #8]
    500e:	607a      	str	r2, [r7, #4]
    5010:	70fb      	strb	r3, [r7, #3]

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
    5012:	6878      	ldr	r0, [r7, #4]
    5014:	f7ff fb80 	bl	4718 <ip_route>
    5018:	4603      	mov	r3, r0
    501a:	617b      	str	r3, [r7, #20]
    501c:	697b      	ldr	r3, [r7, #20]
    501e:	2b00      	cmp	r3, #0
    5020:	d111      	bne.n	5046 <ip_output+0x42>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    5022:	f247 0330 	movw	r3, #28720	; 0x7030
    5026:	f2c2 0300 	movt	r3, #8192	; 0x2000
    502a:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
    502e:	f103 0301 	add.w	r3, r3, #1
    5032:	b29a      	uxth	r2, r3
    5034:	f247 0330 	movw	r3, #28720	; 0x7030
    5038:	f2c2 0300 	movt	r3, #8192	; 0x2000
    503c:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    return ERR_RTE;
    5040:	f04f 03fc 	mov.w	r3, #252	; 0xfc
    5044:	e010      	b.n	5068 <ip_output+0x64>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    5046:	78fb      	ldrb	r3, [r7, #3]
    5048:	f897 2020 	ldrb.w	r2, [r7, #32]
    504c:	9200      	str	r2, [sp, #0]
    504e:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
    5052:	9201      	str	r2, [sp, #4]
    5054:	697a      	ldr	r2, [r7, #20]
    5056:	9202      	str	r2, [sp, #8]
    5058:	68f8      	ldr	r0, [r7, #12]
    505a:	68b9      	ldr	r1, [r7, #8]
    505c:	687a      	ldr	r2, [r7, #4]
    505e:	f7ff fdc9 	bl	4bf4 <ip_output_if>
    5062:	4603      	mov	r3, r0
    5064:	b2db      	uxtb	r3, r3
    5066:	b2db      	uxtb	r3, r3
    5068:	b25b      	sxtb	r3, r3
}
    506a:	4618      	mov	r0, r3
    506c:	f107 0718 	add.w	r7, r7, #24
    5070:	46bd      	mov	sp, r7
    5072:	bd80      	pop	{r7, pc}

00005074 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
    5074:	b480      	push	{r7}
    5076:	b085      	sub	sp, #20
    5078:	af00      	add	r7, sp, #0
    507a:	6078      	str	r0, [r7, #4]
    507c:	6039      	str	r1, [r7, #0]
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
    507e:	687b      	ldr	r3, [r7, #4]
    5080:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
    5082:	687b      	ldr	r3, [r7, #4]
    5084:	f1b3 3fff 	cmp.w	r3, #4294967295
    5088:	d002      	beq.n	5090 <ip4_addr_isbroadcast+0x1c>
    508a:	687b      	ldr	r3, [r7, #4]
    508c:	2b00      	cmp	r3, #0
    508e:	d102      	bne.n	5096 <ip4_addr_isbroadcast+0x22>
      (addr == IPADDR_ANY)) {
    return 1;
    5090:	f04f 0301 	mov.w	r3, #1
    5094:	e02e      	b.n	50f4 <ip4_addr_isbroadcast+0x80>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    5096:	683b      	ldr	r3, [r7, #0]
    5098:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    509c:	f003 0302 	and.w	r3, r3, #2
    50a0:	2b00      	cmp	r3, #0
    50a2:	d102      	bne.n	50aa <ip4_addr_isbroadcast+0x36>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    50a4:	f04f 0300 	mov.w	r3, #0
    50a8:	e024      	b.n	50f4 <ip4_addr_isbroadcast+0x80>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    50aa:	683b      	ldr	r3, [r7, #0]
    50ac:	685a      	ldr	r2, [r3, #4]
    50ae:	687b      	ldr	r3, [r7, #4]
    50b0:	429a      	cmp	r2, r3
    50b2:	d102      	bne.n	50ba <ip4_addr_isbroadcast+0x46>
    return 0;
    50b4:	f04f 0300 	mov.w	r3, #0
    50b8:	e01c      	b.n	50f4 <ip4_addr_isbroadcast+0x80>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    50ba:	68fa      	ldr	r2, [r7, #12]
    50bc:	683b      	ldr	r3, [r7, #0]
    50be:	685b      	ldr	r3, [r3, #4]
    50c0:	ea82 0203 	eor.w	r2, r2, r3
    50c4:	683b      	ldr	r3, [r7, #0]
    50c6:	689b      	ldr	r3, [r3, #8]
    50c8:	ea02 0303 	and.w	r3, r2, r3
    50cc:	2b00      	cmp	r3, #0
    50ce:	d10f      	bne.n	50f0 <ip4_addr_isbroadcast+0x7c>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    50d0:	683b      	ldr	r3, [r7, #0]
    50d2:	689b      	ldr	r3, [r3, #8]
    50d4:	ea6f 0203 	mvn.w	r2, r3
    50d8:	687b      	ldr	r3, [r7, #4]
    50da:	ea02 0203 	and.w	r2, r2, r3
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    50de:	683b      	ldr	r3, [r7, #0]
    50e0:	689b      	ldr	r3, [r3, #8]
    50e2:	ea6f 0303 	mvn.w	r3, r3
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    50e6:	429a      	cmp	r2, r3
    50e8:	d102      	bne.n	50f0 <ip4_addr_isbroadcast+0x7c>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
    50ea:	f04f 0301 	mov.w	r3, #1
    50ee:	e001      	b.n	50f4 <ip4_addr_isbroadcast+0x80>
  } else {
    return 0;
    50f0:	f04f 0300 	mov.w	r3, #0
  }
}
    50f4:	4618      	mov	r0, r3
    50f6:	f107 0714 	add.w	r7, r7, #20
    50fa:	46bd      	mov	sp, r7
    50fc:	bc80      	pop	{r7}
    50fe:	4770      	bx	lr

00005100 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    5100:	b580      	push	{r7, lr}
    5102:	b084      	sub	sp, #16
    5104:	af00      	add	r7, sp, #0
  struct ip_reassdata *r, *prev = NULL;
    5106:	f04f 0300 	mov.w	r3, #0
    510a:	60bb      	str	r3, [r7, #8]

  r = reassdatagrams;
    510c:	f243 1348 	movw	r3, #12616	; 0x3148
    5110:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5114:	681b      	ldr	r3, [r3, #0]
    5116:	607b      	str	r3, [r7, #4]
  while (r != NULL) {
    5118:	e019      	b.n	514e <ip_reass_tmr+0x4e>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    511a:	687b      	ldr	r3, [r7, #4]
    511c:	7fdb      	ldrb	r3, [r3, #31]
    511e:	2b00      	cmp	r3, #0
    5120:	d00c      	beq.n	513c <ip_reass_tmr+0x3c>
      r->timer--;
    5122:	687b      	ldr	r3, [r7, #4]
    5124:	7fdb      	ldrb	r3, [r3, #31]
    5126:	f103 33ff 	add.w	r3, r3, #4294967295
    512a:	b2da      	uxtb	r2, r3
    512c:	687b      	ldr	r3, [r7, #4]
    512e:	77da      	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
    5130:	687b      	ldr	r3, [r7, #4]
    5132:	60bb      	str	r3, [r7, #8]
      r = r->next;
    5134:	687b      	ldr	r3, [r7, #4]
    5136:	681b      	ldr	r3, [r3, #0]
    5138:	607b      	str	r3, [r7, #4]
    513a:	e008      	b.n	514e <ip_reass_tmr+0x4e>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
    513c:	687b      	ldr	r3, [r7, #4]
    513e:	60fb      	str	r3, [r7, #12]
      /* get the next pointer before freeing */
      r = r->next;
    5140:	687b      	ldr	r3, [r7, #4]
    5142:	681b      	ldr	r3, [r3, #0]
    5144:	607b      	str	r3, [r7, #4]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    5146:	68f8      	ldr	r0, [r7, #12]
    5148:	68b9      	ldr	r1, [r7, #8]
    514a:	f000 f807 	bl	515c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    514e:	687b      	ldr	r3, [r7, #4]
    5150:	2b00      	cmp	r3, #0
    5152:	d1e2      	bne.n	511a <ip_reass_tmr+0x1a>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    5154:	f107 0710 	add.w	r7, r7, #16
    5158:	46bd      	mov	sp, r7
    515a:	bd80      	pop	{r7, pc}

0000515c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    515c:	b580      	push	{r7, lr}
    515e:	b086      	sub	sp, #24
    5160:	af00      	add	r7, sp, #0
    5162:	6078      	str	r0, [r7, #4]
    5164:	6039      	str	r1, [r7, #0]
  u16_t pbufs_freed = 0;
    5166:	f04f 0300 	mov.w	r3, #0
    516a:	813b      	strh	r3, [r7, #8]
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  if (prev != NULL) {
    516c:	683b      	ldr	r3, [r7, #0]
    516e:	2b00      	cmp	r3, #0
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    5170:	687b      	ldr	r3, [r7, #4]
    5172:	685b      	ldr	r3, [r3, #4]
    5174:	685b      	ldr	r3, [r3, #4]
    5176:	613b      	str	r3, [r7, #16]
  if (iprh->start == 0) {
    5178:	693b      	ldr	r3, [r7, #16]
    517a:	791a      	ldrb	r2, [r3, #4]
    517c:	795b      	ldrb	r3, [r3, #5]
    517e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5182:	ea43 0302 	orr.w	r3, r3, r2
    5186:	b29b      	uxth	r3, r3
    5188:	2b00      	cmp	r3, #0
    518a:	d132      	bne.n	51f2 <ip_reass_free_complete_datagram+0x96>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    518c:	687b      	ldr	r3, [r7, #4]
    518e:	685b      	ldr	r3, [r3, #4]
    5190:	60fb      	str	r3, [r7, #12]
    ipr->p = iprh->next_pbuf;
    5192:	693b      	ldr	r3, [r7, #16]
    5194:	781a      	ldrb	r2, [r3, #0]
    5196:	7859      	ldrb	r1, [r3, #1]
    5198:	ea4f 2101 	mov.w	r1, r1, lsl #8
    519c:	ea41 0202 	orr.w	r2, r1, r2
    51a0:	7899      	ldrb	r1, [r3, #2]
    51a2:	ea4f 4101 	mov.w	r1, r1, lsl #16
    51a6:	ea41 0202 	orr.w	r2, r1, r2
    51aa:	78db      	ldrb	r3, [r3, #3]
    51ac:	ea4f 6303 	mov.w	r3, r3, lsl #24
    51b0:	ea43 0302 	orr.w	r3, r3, r2
    51b4:	461a      	mov	r2, r3
    51b6:	687b      	ldr	r3, [r7, #4]
    51b8:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    51ba:	68fb      	ldr	r3, [r7, #12]
    51bc:	685a      	ldr	r2, [r3, #4]
    51be:	687b      	ldr	r3, [r7, #4]
    51c0:	f103 0308 	add.w	r3, r3, #8
    51c4:	4610      	mov	r0, r2
    51c6:	4619      	mov	r1, r3
    51c8:	f04f 0214 	mov.w	r2, #20
    51cc:	f003 fd2a 	bl	8c24 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    51d0:	68f8      	ldr	r0, [r7, #12]
    51d2:	f04f 0101 	mov.w	r1, #1
    51d6:	f7ff f869 	bl	42ac <icmp_time_exceeded>
    clen = pbuf_clen(p);
    51da:	68f8      	ldr	r0, [r7, #12]
    51dc:	f7fd ffee 	bl	31bc <pbuf_clen>
    51e0:	4603      	mov	r3, r0
    51e2:	72fb      	strb	r3, [r7, #11]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    51e4:	7afa      	ldrb	r2, [r7, #11]
    51e6:	893b      	ldrh	r3, [r7, #8]
    51e8:	4413      	add	r3, r2
    51ea:	813b      	strh	r3, [r7, #8]
    pbuf_free(p);
    51ec:	68f8      	ldr	r0, [r7, #12]
    51ee:	f7fd ff81 	bl	30f4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
    51f2:	687b      	ldr	r3, [r7, #4]
    51f4:	685b      	ldr	r3, [r3, #4]
    51f6:	60fb      	str	r3, [r7, #12]
  while (p != NULL) {
    51f8:	e022      	b.n	5240 <ip_reass_free_complete_datagram+0xe4>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    51fa:	68fb      	ldr	r3, [r7, #12]
    51fc:	685b      	ldr	r3, [r3, #4]
    51fe:	613b      	str	r3, [r7, #16]
    pcur = p;
    5200:	68fb      	ldr	r3, [r7, #12]
    5202:	617b      	str	r3, [r7, #20]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    5204:	693b      	ldr	r3, [r7, #16]
    5206:	781a      	ldrb	r2, [r3, #0]
    5208:	7859      	ldrb	r1, [r3, #1]
    520a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    520e:	ea41 0202 	orr.w	r2, r1, r2
    5212:	7899      	ldrb	r1, [r3, #2]
    5214:	ea4f 4101 	mov.w	r1, r1, lsl #16
    5218:	ea41 0202 	orr.w	r2, r1, r2
    521c:	78db      	ldrb	r3, [r3, #3]
    521e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5222:	ea43 0302 	orr.w	r3, r3, r2
    5226:	60fb      	str	r3, [r7, #12]
    clen = pbuf_clen(pcur);
    5228:	6978      	ldr	r0, [r7, #20]
    522a:	f7fd ffc7 	bl	31bc <pbuf_clen>
    522e:	4603      	mov	r3, r0
    5230:	72fb      	strb	r3, [r7, #11]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    5232:	7afa      	ldrb	r2, [r7, #11]
    5234:	893b      	ldrh	r3, [r7, #8]
    5236:	4413      	add	r3, r2
    5238:	813b      	strh	r3, [r7, #8]
    pbuf_free(pcur);
    523a:	6978      	ldr	r0, [r7, #20]
    523c:	f7fd ff5a 	bl	30f4 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    5240:	68fb      	ldr	r3, [r7, #12]
    5242:	2b00      	cmp	r3, #0
    5244:	d1d9      	bne.n	51fa <ip_reass_free_complete_datagram+0x9e>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    5246:	6878      	ldr	r0, [r7, #4]
    5248:	6839      	ldr	r1, [r7, #0]
    524a:	f000 f8f1 	bl	5430 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
    524e:	f243 134c 	movw	r3, #12620	; 0x314c
    5252:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5256:	881a      	ldrh	r2, [r3, #0]
    5258:	893b      	ldrh	r3, [r7, #8]
    525a:	ebc3 0302 	rsb	r3, r3, r2
    525e:	b29a      	uxth	r2, r3
    5260:	f243 134c 	movw	r3, #12620	; 0x314c
    5264:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5268:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
    526a:	893b      	ldrh	r3, [r7, #8]
}
    526c:	4618      	mov	r0, r3
    526e:	f107 0718 	add.w	r7, r7, #24
    5272:	46bd      	mov	sp, r7
    5274:	bd80      	pop	{r7, pc}
    5276:	bf00      	nop

00005278 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    5278:	b580      	push	{r7, lr}
    527a:	b088      	sub	sp, #32
    527c:	af00      	add	r7, sp, #0
    527e:	6078      	str	r0, [r7, #4]
    5280:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    5282:	f04f 0300 	mov.w	r3, #0
    5286:	617b      	str	r3, [r7, #20]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    5288:	f04f 0300 	mov.w	r3, #0
    528c:	60fb      	str	r3, [r7, #12]
    prev = NULL;
    528e:	f04f 0300 	mov.w	r3, #0
    5292:	613b      	str	r3, [r7, #16]
    other_datagrams = 0;
    5294:	f04f 0300 	mov.w	r3, #0
    5298:	61fb      	str	r3, [r7, #28]
    r = reassdatagrams;
    529a:	f243 1348 	movw	r3, #12616	; 0x3148
    529e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    52a2:	681b      	ldr	r3, [r3, #0]
    52a4:	60bb      	str	r3, [r7, #8]
    while (r != NULL) {
    52a6:	e050      	b.n	534a <ip_reass_remove_oldest_datagram+0xd2>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    52a8:	68bb      	ldr	r3, [r7, #8]
    52aa:	695a      	ldr	r2, [r3, #20]
    52ac:	687b      	ldr	r3, [r7, #4]
    52ae:	7b19      	ldrb	r1, [r3, #12]
    52b0:	7b58      	ldrb	r0, [r3, #13]
    52b2:	ea4f 2000 	mov.w	r0, r0, lsl #8
    52b6:	ea40 0101 	orr.w	r1, r0, r1
    52ba:	7b98      	ldrb	r0, [r3, #14]
    52bc:	ea4f 4000 	mov.w	r0, r0, lsl #16
    52c0:	ea40 0101 	orr.w	r1, r0, r1
    52c4:	7bdb      	ldrb	r3, [r3, #15]
    52c6:	ea4f 6303 	mov.w	r3, r3, lsl #24
    52ca:	ea43 0301 	orr.w	r3, r3, r1
    52ce:	429a      	cmp	r2, r3
    52d0:	d120      	bne.n	5314 <ip_reass_remove_oldest_datagram+0x9c>
    52d2:	68bb      	ldr	r3, [r7, #8]
    52d4:	699a      	ldr	r2, [r3, #24]
    52d6:	687b      	ldr	r3, [r7, #4]
    52d8:	7c19      	ldrb	r1, [r3, #16]
    52da:	7c58      	ldrb	r0, [r3, #17]
    52dc:	ea4f 2000 	mov.w	r0, r0, lsl #8
    52e0:	ea40 0101 	orr.w	r1, r0, r1
    52e4:	7c98      	ldrb	r0, [r3, #18]
    52e6:	ea4f 4000 	mov.w	r0, r0, lsl #16
    52ea:	ea40 0101 	orr.w	r1, r0, r1
    52ee:	7cdb      	ldrb	r3, [r3, #19]
    52f0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    52f4:	ea43 0301 	orr.w	r3, r3, r1
    52f8:	429a      	cmp	r2, r3
    52fa:	d10b      	bne.n	5314 <ip_reass_remove_oldest_datagram+0x9c>
    52fc:	68bb      	ldr	r3, [r7, #8]
    52fe:	899a      	ldrh	r2, [r3, #12]
    5300:	687b      	ldr	r3, [r7, #4]
    5302:	7919      	ldrb	r1, [r3, #4]
    5304:	795b      	ldrb	r3, [r3, #5]
    5306:	ea4f 2303 	mov.w	r3, r3, lsl #8
    530a:	ea43 0301 	orr.w	r3, r3, r1
    530e:	b29b      	uxth	r3, r3
    5310:	429a      	cmp	r2, r3
    5312:	d011      	beq.n	5338 <ip_reass_remove_oldest_datagram+0xc0>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    5314:	69fb      	ldr	r3, [r7, #28]
    5316:	f103 0301 	add.w	r3, r3, #1
    531a:	61fb      	str	r3, [r7, #28]
        if (oldest == NULL) {
    531c:	68fb      	ldr	r3, [r7, #12]
    531e:	2b00      	cmp	r3, #0
    5320:	d102      	bne.n	5328 <ip_reass_remove_oldest_datagram+0xb0>
          oldest = r;
    5322:	68bb      	ldr	r3, [r7, #8]
    5324:	60fb      	str	r3, [r7, #12]
    5326:	e007      	b.n	5338 <ip_reass_remove_oldest_datagram+0xc0>
        } else if (r->timer <= oldest->timer) {
    5328:	68bb      	ldr	r3, [r7, #8]
    532a:	7fda      	ldrb	r2, [r3, #31]
    532c:	68fb      	ldr	r3, [r7, #12]
    532e:	7fdb      	ldrb	r3, [r3, #31]
    5330:	429a      	cmp	r2, r3
    5332:	d801      	bhi.n	5338 <ip_reass_remove_oldest_datagram+0xc0>
          /* older than the previous oldest */
          oldest = r;
    5334:	68bb      	ldr	r3, [r7, #8]
    5336:	60fb      	str	r3, [r7, #12]
        }
      }
      if (r->next != NULL) {
    5338:	68bb      	ldr	r3, [r7, #8]
    533a:	681b      	ldr	r3, [r3, #0]
    533c:	2b00      	cmp	r3, #0
    533e:	d001      	beq.n	5344 <ip_reass_remove_oldest_datagram+0xcc>
        prev = r;
    5340:	68bb      	ldr	r3, [r7, #8]
    5342:	613b      	str	r3, [r7, #16]
      }
      r = r->next;
    5344:	68bb      	ldr	r3, [r7, #8]
    5346:	681b      	ldr	r3, [r3, #0]
    5348:	60bb      	str	r3, [r7, #8]
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
    534a:	68bb      	ldr	r3, [r7, #8]
    534c:	2b00      	cmp	r3, #0
    534e:	d1ab      	bne.n	52a8 <ip_reass_remove_oldest_datagram+0x30>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    5350:	68fb      	ldr	r3, [r7, #12]
    5352:	2b00      	cmp	r3, #0
    5354:	d009      	beq.n	536a <ip_reass_remove_oldest_datagram+0xf2>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    5356:	68f8      	ldr	r0, [r7, #12]
    5358:	6939      	ldr	r1, [r7, #16]
    535a:	f7ff feff 	bl	515c <ip_reass_free_complete_datagram>
    535e:	4603      	mov	r3, r0
    5360:	61bb      	str	r3, [r7, #24]
      pbufs_freed += pbufs_freed_current;
    5362:	697a      	ldr	r2, [r7, #20]
    5364:	69bb      	ldr	r3, [r7, #24]
    5366:	4413      	add	r3, r2
    5368:	617b      	str	r3, [r7, #20]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    536a:	697a      	ldr	r2, [r7, #20]
    536c:	683b      	ldr	r3, [r7, #0]
    536e:	429a      	cmp	r2, r3
    5370:	da02      	bge.n	5378 <ip_reass_remove_oldest_datagram+0x100>
    5372:	69fb      	ldr	r3, [r7, #28]
    5374:	2b01      	cmp	r3, #1
    5376:	dc87      	bgt.n	5288 <ip_reass_remove_oldest_datagram+0x10>
  return pbufs_freed;
    5378:	697b      	ldr	r3, [r7, #20]
}
    537a:	4618      	mov	r0, r3
    537c:	f107 0720 	add.w	r7, r7, #32
    5380:	46bd      	mov	sp, r7
    5382:	bd80      	pop	{r7, pc}

00005384 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
    5384:	b580      	push	{r7, lr}
    5386:	b084      	sub	sp, #16
    5388:	af00      	add	r7, sp, #0
    538a:	6078      	str	r0, [r7, #4]
    538c:	6039      	str	r1, [r7, #0]
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    538e:	f04f 0002 	mov.w	r0, #2
    5392:	f7fd fa59 	bl	2848 <memp_malloc>
    5396:	4603      	mov	r3, r0
    5398:	60fb      	str	r3, [r7, #12]
  if (ipr == NULL) {
    539a:	68fb      	ldr	r3, [r7, #12]
    539c:	2b00      	cmp	r3, #0
    539e:	d120      	bne.n	53e2 <ip_reass_enqueue_new_datagram+0x5e>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    53a0:	6878      	ldr	r0, [r7, #4]
    53a2:	6839      	ldr	r1, [r7, #0]
    53a4:	f7ff ff68 	bl	5278 <ip_reass_remove_oldest_datagram>
    53a8:	4602      	mov	r2, r0
    53aa:	683b      	ldr	r3, [r7, #0]
    53ac:	429a      	cmp	r2, r3
    53ae:	db05      	blt.n	53bc <ip_reass_enqueue_new_datagram+0x38>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    53b0:	f04f 0002 	mov.w	r0, #2
    53b4:	f7fd fa48 	bl	2848 <memp_malloc>
    53b8:	4603      	mov	r3, r0
    53ba:	60fb      	str	r3, [r7, #12]
    }
    if (ipr == NULL)
    53bc:	68fb      	ldr	r3, [r7, #12]
    53be:	2b00      	cmp	r3, #0
    53c0:	d10f      	bne.n	53e2 <ip_reass_enqueue_new_datagram+0x5e>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
    53c2:	f247 0330 	movw	r3, #28720	; 0x7030
    53c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53ca:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
    53cc:	f103 0301 	add.w	r3, r3, #1
    53d0:	b29a      	uxth	r2, r3
    53d2:	f247 0330 	movw	r3, #28720	; 0x7030
    53d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53da:	879a      	strh	r2, [r3, #60]	; 0x3c
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    53dc:	f04f 0300 	mov.w	r3, #0
    53e0:	e021      	b.n	5426 <ip_reass_enqueue_new_datagram+0xa2>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    53e2:	68f8      	ldr	r0, [r7, #12]
    53e4:	f04f 0100 	mov.w	r1, #0
    53e8:	f04f 0220 	mov.w	r2, #32
    53ec:	f003 fce2 	bl	8db4 <memset>
  ipr->timer = IP_REASS_MAXAGE;
    53f0:	68fb      	ldr	r3, [r7, #12]
    53f2:	f04f 0203 	mov.w	r2, #3
    53f6:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    53f8:	f243 1348 	movw	r3, #12616	; 0x3148
    53fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5400:	681a      	ldr	r2, [r3, #0]
    5402:	68fb      	ldr	r3, [r7, #12]
    5404:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
    5406:	f243 1348 	movw	r3, #12616	; 0x3148
    540a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    540e:	68fa      	ldr	r2, [r7, #12]
    5410:	601a      	str	r2, [r3, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    5412:	68fb      	ldr	r3, [r7, #12]
    5414:	f103 0308 	add.w	r3, r3, #8
    5418:	4618      	mov	r0, r3
    541a:	6879      	ldr	r1, [r7, #4]
    541c:	f04f 0214 	mov.w	r2, #20
    5420:	f003 fc00 	bl	8c24 <memcpy>
  return ipr;
    5424:	68fb      	ldr	r3, [r7, #12]
}
    5426:	4618      	mov	r0, r3
    5428:	f107 0710 	add.w	r7, r7, #16
    542c:	46bd      	mov	sp, r7
    542e:	bd80      	pop	{r7, pc}

00005430 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    5430:	b580      	push	{r7, lr}
    5432:	b082      	sub	sp, #8
    5434:	af00      	add	r7, sp, #0
    5436:	6078      	str	r0, [r7, #4]
    5438:	6039      	str	r1, [r7, #0]
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    543a:	f243 1348 	movw	r3, #12616	; 0x3148
    543e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5442:	681a      	ldr	r2, [r3, #0]
    5444:	687b      	ldr	r3, [r7, #4]
    5446:	429a      	cmp	r2, r3
    5448:	d107      	bne.n	545a <ip_reass_dequeue_datagram+0x2a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    544a:	687b      	ldr	r3, [r7, #4]
    544c:	681a      	ldr	r2, [r3, #0]
    544e:	f243 1348 	movw	r3, #12616	; 0x3148
    5452:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5456:	601a      	str	r2, [r3, #0]
    5458:	e003      	b.n	5462 <ip_reass_dequeue_datagram+0x32>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
    545a:	687b      	ldr	r3, [r7, #4]
    545c:	681a      	ldr	r2, [r3, #0]
    545e:	683b      	ldr	r3, [r7, #0]
    5460:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    5462:	f04f 0002 	mov.w	r0, #2
    5466:	6879      	ldr	r1, [r7, #4]
    5468:	f7fd fa98 	bl	299c <memp_free>
}
    546c:	f107 0708 	add.w	r7, r7, #8
    5470:	46bd      	mov	sp, r7
    5472:	bd80      	pop	{r7, pc}

00005474 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
    5474:	b590      	push	{r4, r7, lr}
    5476:	b08b      	sub	sp, #44	; 0x2c
    5478:	af00      	add	r7, sp, #0
    547a:	6078      	str	r0, [r7, #4]
    547c:	6039      	str	r1, [r7, #0]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
    547e:	f04f 0300 	mov.w	r3, #0
    5482:	617b      	str	r3, [r7, #20]
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
    5484:	f04f 0301 	mov.w	r3, #1
    5488:	627b      	str	r3, [r7, #36]	; 0x24

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    548a:	683b      	ldr	r3, [r7, #0]
    548c:	685b      	ldr	r3, [r3, #4]
    548e:	623b      	str	r3, [r7, #32]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5490:	6a3b      	ldr	r3, [r7, #32]
    5492:	789a      	ldrb	r2, [r3, #2]
    5494:	78db      	ldrb	r3, [r3, #3]
    5496:	ea4f 2303 	mov.w	r3, r3, lsl #8
    549a:	ea43 0302 	orr.w	r3, r3, r2
    549e:	b29b      	uxth	r3, r3
    54a0:	4618      	mov	r0, r3
    54a2:	f7fc fd3b 	bl	1f1c <lwip_ntohs>
    54a6:	4603      	mov	r3, r0
    54a8:	461c      	mov	r4, r3
    54aa:	6a3b      	ldr	r3, [r7, #32]
    54ac:	781a      	ldrb	r2, [r3, #0]
    54ae:	785b      	ldrb	r3, [r3, #1]
    54b0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    54b4:	ea43 0302 	orr.w	r3, r3, r2
    54b8:	b29b      	uxth	r3, r3
    54ba:	4618      	mov	r0, r3
    54bc:	f7fc fd2e 	bl	1f1c <lwip_ntohs>
    54c0:	4603      	mov	r3, r0
    54c2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    54c6:	b29b      	uxth	r3, r3
    54c8:	f003 030f 	and.w	r3, r3, #15
    54cc:	461a      	mov	r2, r3
    54ce:	ea4f 3282 	mov.w	r2, r2, lsl #14
    54d2:	ebc3 0302 	rsb	r3, r3, r2
    54d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    54da:	b29b      	uxth	r3, r3
    54dc:	4423      	add	r3, r4
    54de:	83fb      	strh	r3, [r7, #30]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    54e0:	6a3b      	ldr	r3, [r7, #32]
    54e2:	799a      	ldrb	r2, [r3, #6]
    54e4:	79db      	ldrb	r3, [r3, #7]
    54e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    54ea:	ea43 0302 	orr.w	r3, r3, r2
    54ee:	b29b      	uxth	r3, r3
    54f0:	4618      	mov	r0, r3
    54f2:	f7fc fd13 	bl	1f1c <lwip_ntohs>
    54f6:	4603      	mov	r3, r0
    54f8:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    54fc:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    5500:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5504:	83bb      	strh	r3, [r7, #28]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
    5506:	683b      	ldr	r3, [r7, #0]
    5508:	685b      	ldr	r3, [r3, #4]
    550a:	60fb      	str	r3, [r7, #12]
  iprh->next_pbuf = NULL;
    550c:	68fb      	ldr	r3, [r7, #12]
    550e:	f04f 0200 	mov.w	r2, #0
    5512:	701a      	strb	r2, [r3, #0]
    5514:	f04f 0200 	mov.w	r2, #0
    5518:	705a      	strb	r2, [r3, #1]
    551a:	f04f 0200 	mov.w	r2, #0
    551e:	709a      	strb	r2, [r3, #2]
    5520:	f04f 0200 	mov.w	r2, #0
    5524:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
    5526:	68fb      	ldr	r3, [r7, #12]
    5528:	7f3a      	ldrb	r2, [r7, #28]
    552a:	f04f 0100 	mov.w	r1, #0
    552e:	ea41 0202 	orr.w	r2, r1, r2
    5532:	711a      	strb	r2, [r3, #4]
    5534:	7f7a      	ldrb	r2, [r7, #29]
    5536:	f04f 0100 	mov.w	r1, #0
    553a:	ea41 0202 	orr.w	r2, r1, r2
    553e:	715a      	strb	r2, [r3, #5]
  iprh->end = offset + len;
    5540:	8bba      	ldrh	r2, [r7, #28]
    5542:	8bfb      	ldrh	r3, [r7, #30]
    5544:	4413      	add	r3, r2
    5546:	b29a      	uxth	r2, r3
    5548:	68fb      	ldr	r3, [r7, #12]
    554a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    554e:	f04f 0000 	mov.w	r0, #0
    5552:	ea40 0101 	orr.w	r1, r0, r1
    5556:	7199      	strb	r1, [r3, #6]
    5558:	ea4f 2212 	mov.w	r2, r2, lsr #8
    555c:	b292      	uxth	r2, r2
    555e:	f04f 0100 	mov.w	r1, #0
    5562:	ea41 0202 	orr.w	r2, r1, r2
    5566:	71da      	strb	r2, [r3, #7]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    5568:	687b      	ldr	r3, [r7, #4]
    556a:	685b      	ldr	r3, [r3, #4]
    556c:	61bb      	str	r3, [r7, #24]
    556e:	e0c6      	b.n	56fe <ip_reass_chain_frag_into_datagram_and_validate+0x28a>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    5570:	69bb      	ldr	r3, [r7, #24]
    5572:	685b      	ldr	r3, [r3, #4]
    5574:	613b      	str	r3, [r7, #16]
    if (iprh->start < iprh_tmp->start) {
    5576:	68fb      	ldr	r3, [r7, #12]
    5578:	791a      	ldrb	r2, [r3, #4]
    557a:	795b      	ldrb	r3, [r3, #5]
    557c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5580:	ea43 0302 	orr.w	r3, r3, r2
    5584:	b29a      	uxth	r2, r3
    5586:	693b      	ldr	r3, [r7, #16]
    5588:	7919      	ldrb	r1, [r3, #4]
    558a:	795b      	ldrb	r3, [r3, #5]
    558c:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5590:	ea43 0301 	orr.w	r3, r3, r1
    5594:	b29b      	uxth	r3, r3
    5596:	429a      	cmp	r2, r3
    5598:	d25f      	bcs.n	565a <ip_reass_chain_frag_into_datagram_and_validate+0x1e6>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    559a:	68fb      	ldr	r3, [r7, #12]
    559c:	7e3a      	ldrb	r2, [r7, #24]
    559e:	f04f 0100 	mov.w	r1, #0
    55a2:	ea41 0202 	orr.w	r2, r1, r2
    55a6:	701a      	strb	r2, [r3, #0]
    55a8:	7e7a      	ldrb	r2, [r7, #25]
    55aa:	f04f 0100 	mov.w	r1, #0
    55ae:	ea41 0202 	orr.w	r2, r1, r2
    55b2:	705a      	strb	r2, [r3, #1]
    55b4:	7eba      	ldrb	r2, [r7, #26]
    55b6:	f04f 0100 	mov.w	r1, #0
    55ba:	ea41 0202 	orr.w	r2, r1, r2
    55be:	709a      	strb	r2, [r3, #2]
    55c0:	7efa      	ldrb	r2, [r7, #27]
    55c2:	f04f 0100 	mov.w	r1, #0
    55c6:	ea41 0202 	orr.w	r2, r1, r2
    55ca:	70da      	strb	r2, [r3, #3]
      if (iprh_prev != NULL) {
    55cc:	697b      	ldr	r3, [r7, #20]
    55ce:	2b00      	cmp	r3, #0
    55d0:	d03f      	beq.n	5652 <ip_reass_chain_frag_into_datagram_and_validate+0x1de>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    55d2:	68fb      	ldr	r3, [r7, #12]
    55d4:	791a      	ldrb	r2, [r3, #4]
    55d6:	795b      	ldrb	r3, [r3, #5]
    55d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    55dc:	ea43 0302 	orr.w	r3, r3, r2
    55e0:	b29a      	uxth	r2, r3
    55e2:	697b      	ldr	r3, [r7, #20]
    55e4:	7999      	ldrb	r1, [r3, #6]
    55e6:	79db      	ldrb	r3, [r3, #7]
    55e8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    55ec:	ea43 0301 	orr.w	r3, r3, r1
    55f0:	b29b      	uxth	r3, r3
    55f2:	429a      	cmp	r2, r3
    55f4:	f0c0 812a 	bcc.w	584c <ip_reass_chain_frag_into_datagram_and_validate+0x3d8>
    55f8:	68fb      	ldr	r3, [r7, #12]
    55fa:	799a      	ldrb	r2, [r3, #6]
    55fc:	79db      	ldrb	r3, [r3, #7]
    55fe:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5602:	ea43 0302 	orr.w	r3, r3, r2
    5606:	b29a      	uxth	r2, r3
    5608:	693b      	ldr	r3, [r7, #16]
    560a:	7919      	ldrb	r1, [r3, #4]
    560c:	795b      	ldrb	r3, [r3, #5]
    560e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5612:	ea43 0301 	orr.w	r3, r3, r1
    5616:	b29b      	uxth	r3, r3
    5618:	429a      	cmp	r2, r3
    561a:	f200 8117 	bhi.w	584c <ip_reass_chain_frag_into_datagram_and_validate+0x3d8>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    561e:	697b      	ldr	r3, [r7, #20]
    5620:	783a      	ldrb	r2, [r7, #0]
    5622:	f04f 0100 	mov.w	r1, #0
    5626:	ea41 0202 	orr.w	r2, r1, r2
    562a:	701a      	strb	r2, [r3, #0]
    562c:	787a      	ldrb	r2, [r7, #1]
    562e:	f04f 0100 	mov.w	r1, #0
    5632:	ea41 0202 	orr.w	r2, r1, r2
    5636:	705a      	strb	r2, [r3, #1]
    5638:	78ba      	ldrb	r2, [r7, #2]
    563a:	f04f 0100 	mov.w	r1, #0
    563e:	ea41 0202 	orr.w	r2, r1, r2
    5642:	709a      	strb	r2, [r3, #2]
    5644:	78fa      	ldrb	r2, [r7, #3]
    5646:	f04f 0100 	mov.w	r1, #0
    564a:	ea41 0202 	orr.w	r2, r1, r2
    564e:	70da      	strb	r2, [r3, #3]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    5650:	e059      	b.n	5706 <ip_reass_chain_frag_into_datagram_and_validate+0x292>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    5652:	687b      	ldr	r3, [r7, #4]
    5654:	683a      	ldr	r2, [r7, #0]
    5656:	605a      	str	r2, [r3, #4]
      }
      break;
    5658:	e055      	b.n	5706 <ip_reass_chain_frag_into_datagram_and_validate+0x292>
    } else if(iprh->start == iprh_tmp->start) {
    565a:	68fb      	ldr	r3, [r7, #12]
    565c:	791a      	ldrb	r2, [r3, #4]
    565e:	795b      	ldrb	r3, [r3, #5]
    5660:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5664:	ea43 0302 	orr.w	r3, r3, r2
    5668:	b29a      	uxth	r2, r3
    566a:	693b      	ldr	r3, [r7, #16]
    566c:	7919      	ldrb	r1, [r3, #4]
    566e:	795b      	ldrb	r3, [r3, #5]
    5670:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5674:	ea43 0301 	orr.w	r3, r3, r1
    5678:	b29b      	uxth	r3, r3
    567a:	429a      	cmp	r2, r3
    567c:	f000 80e3 	beq.w	5846 <ip_reass_chain_frag_into_datagram_and_validate+0x3d2>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    5680:	68fb      	ldr	r3, [r7, #12]
    5682:	791a      	ldrb	r2, [r3, #4]
    5684:	795b      	ldrb	r3, [r3, #5]
    5686:	ea4f 2303 	mov.w	r3, r3, lsl #8
    568a:	ea43 0302 	orr.w	r3, r3, r2
    568e:	b29a      	uxth	r2, r3
    5690:	693b      	ldr	r3, [r7, #16]
    5692:	7999      	ldrb	r1, [r3, #6]
    5694:	79db      	ldrb	r3, [r3, #7]
    5696:	ea4f 2303 	mov.w	r3, r3, lsl #8
    569a:	ea43 0301 	orr.w	r3, r3, r1
    569e:	b29b      	uxth	r3, r3
    56a0:	429a      	cmp	r2, r3
    56a2:	f0c0 80d2 	bcc.w	584a <ip_reass_chain_frag_into_datagram_and_validate+0x3d6>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
    56a6:	697b      	ldr	r3, [r7, #20]
    56a8:	2b00      	cmp	r3, #0
    56aa:	d014      	beq.n	56d6 <ip_reass_chain_frag_into_datagram_and_validate+0x262>
        if (iprh_prev->end != iprh_tmp->start) {
    56ac:	697b      	ldr	r3, [r7, #20]
    56ae:	799a      	ldrb	r2, [r3, #6]
    56b0:	79db      	ldrb	r3, [r3, #7]
    56b2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    56b6:	ea43 0302 	orr.w	r3, r3, r2
    56ba:	b29a      	uxth	r2, r3
    56bc:	693b      	ldr	r3, [r7, #16]
    56be:	7919      	ldrb	r1, [r3, #4]
    56c0:	795b      	ldrb	r3, [r3, #5]
    56c2:	ea4f 2303 	mov.w	r3, r3, lsl #8
    56c6:	ea43 0301 	orr.w	r3, r3, r1
    56ca:	b29b      	uxth	r3, r3
    56cc:	429a      	cmp	r2, r3
    56ce:	d002      	beq.n	56d6 <ip_reass_chain_frag_into_datagram_and_validate+0x262>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    56d0:	f04f 0300 	mov.w	r3, #0
    56d4:	627b      	str	r3, [r7, #36]	; 0x24
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    56d6:	693b      	ldr	r3, [r7, #16]
    56d8:	781a      	ldrb	r2, [r3, #0]
    56da:	7859      	ldrb	r1, [r3, #1]
    56dc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    56e0:	ea41 0202 	orr.w	r2, r1, r2
    56e4:	7899      	ldrb	r1, [r3, #2]
    56e6:	ea4f 4101 	mov.w	r1, r1, lsl #16
    56ea:	ea41 0202 	orr.w	r2, r1, r2
    56ee:	78db      	ldrb	r3, [r3, #3]
    56f0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    56f4:	ea43 0302 	orr.w	r3, r3, r2
    56f8:	61bb      	str	r3, [r7, #24]
    iprh_prev = iprh_tmp;
    56fa:	693b      	ldr	r3, [r7, #16]
    56fc:	617b      	str	r3, [r7, #20]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    56fe:	69bb      	ldr	r3, [r7, #24]
    5700:	2b00      	cmp	r3, #0
    5702:	f47f af35 	bne.w	5570 <ip_reass_chain_frag_into_datagram_and_validate+0xfc>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    5706:	69bb      	ldr	r3, [r7, #24]
    5708:	2b00      	cmp	r3, #0
    570a:	d136      	bne.n	577a <ip_reass_chain_frag_into_datagram_and_validate+0x306>
    if (iprh_prev != NULL) {
    570c:	697b      	ldr	r3, [r7, #20]
    570e:	2b00      	cmp	r3, #0
    5710:	d02e      	beq.n	5770 <ip_reass_chain_frag_into_datagram_and_validate+0x2fc>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    5712:	697b      	ldr	r3, [r7, #20]
    5714:	783a      	ldrb	r2, [r7, #0]
    5716:	f04f 0100 	mov.w	r1, #0
    571a:	ea41 0202 	orr.w	r2, r1, r2
    571e:	701a      	strb	r2, [r3, #0]
    5720:	787a      	ldrb	r2, [r7, #1]
    5722:	f04f 0100 	mov.w	r1, #0
    5726:	ea41 0202 	orr.w	r2, r1, r2
    572a:	705a      	strb	r2, [r3, #1]
    572c:	78ba      	ldrb	r2, [r7, #2]
    572e:	f04f 0100 	mov.w	r1, #0
    5732:	ea41 0202 	orr.w	r2, r1, r2
    5736:	709a      	strb	r2, [r3, #2]
    5738:	78fa      	ldrb	r2, [r7, #3]
    573a:	f04f 0100 	mov.w	r1, #0
    573e:	ea41 0202 	orr.w	r2, r1, r2
    5742:	70da      	strb	r2, [r3, #3]
      if (iprh_prev->end != iprh->start) {
    5744:	697b      	ldr	r3, [r7, #20]
    5746:	799a      	ldrb	r2, [r3, #6]
    5748:	79db      	ldrb	r3, [r3, #7]
    574a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    574e:	ea43 0302 	orr.w	r3, r3, r2
    5752:	b29a      	uxth	r2, r3
    5754:	68fb      	ldr	r3, [r7, #12]
    5756:	7919      	ldrb	r1, [r3, #4]
    5758:	795b      	ldrb	r3, [r3, #5]
    575a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    575e:	ea43 0301 	orr.w	r3, r3, r1
    5762:	b29b      	uxth	r3, r3
    5764:	429a      	cmp	r2, r3
    5766:	d007      	beq.n	5778 <ip_reass_chain_frag_into_datagram_and_validate+0x304>
        valid = 0;
    5768:	f04f 0300 	mov.w	r3, #0
    576c:	627b      	str	r3, [r7, #36]	; 0x24
    576e:	e004      	b.n	577a <ip_reass_chain_frag_into_datagram_and_validate+0x306>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    5770:	687b      	ldr	r3, [r7, #4]
    5772:	683a      	ldr	r2, [r7, #0]
    5774:	605a      	str	r2, [r3, #4]
    5776:	e000      	b.n	577a <ip_reass_chain_frag_into_datagram_and_validate+0x306>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
        valid = 0;
    5778:	bf00      	nop
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    577a:	687b      	ldr	r3, [r7, #4]
    577c:	7f9b      	ldrb	r3, [r3, #30]
    577e:	f003 0301 	and.w	r3, r3, #1
    5782:	b2db      	uxtb	r3, r3
    5784:	2b00      	cmp	r3, #0
    5786:	d05b      	beq.n	5840 <ip_reass_chain_frag_into_datagram_and_validate+0x3cc>
    /* and had no wholes so far */
    if (valid) {
    5788:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    578a:	2b00      	cmp	r3, #0
    578c:	d056      	beq.n	583c <ip_reass_chain_frag_into_datagram_and_validate+0x3c8>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    578e:	687b      	ldr	r3, [r7, #4]
    5790:	685b      	ldr	r3, [r3, #4]
    5792:	685b      	ldr	r3, [r3, #4]
    5794:	791a      	ldrb	r2, [r3, #4]
    5796:	795b      	ldrb	r3, [r3, #5]
    5798:	ea4f 2303 	mov.w	r3, r3, lsl #8
    579c:	ea43 0302 	orr.w	r3, r3, r2
    57a0:	b29b      	uxth	r3, r3
    57a2:	2b00      	cmp	r3, #0
    57a4:	d003      	beq.n	57ae <ip_reass_chain_frag_into_datagram_and_validate+0x33a>
        valid = 0;
    57a6:	f04f 0300 	mov.w	r3, #0
    57aa:	627b      	str	r3, [r7, #36]	; 0x24
    57ac:	e046      	b.n	583c <ip_reass_chain_frag_into_datagram_and_validate+0x3c8>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
    57ae:	68fb      	ldr	r3, [r7, #12]
    57b0:	617b      	str	r3, [r7, #20]
        q = iprh->next_pbuf;
    57b2:	68fb      	ldr	r3, [r7, #12]
    57b4:	781a      	ldrb	r2, [r3, #0]
    57b6:	7859      	ldrb	r1, [r3, #1]
    57b8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    57bc:	ea41 0202 	orr.w	r2, r1, r2
    57c0:	7899      	ldrb	r1, [r3, #2]
    57c2:	ea4f 4101 	mov.w	r1, r1, lsl #16
    57c6:	ea41 0202 	orr.w	r2, r1, r2
    57ca:	78db      	ldrb	r3, [r3, #3]
    57cc:	ea4f 6303 	mov.w	r3, r3, lsl #24
    57d0:	ea43 0302 	orr.w	r3, r3, r2
    57d4:	61bb      	str	r3, [r7, #24]
        while (q != NULL) {
    57d6:	e02c      	b.n	5832 <ip_reass_chain_frag_into_datagram_and_validate+0x3be>
          iprh = (struct ip_reass_helper*)q->payload;
    57d8:	69bb      	ldr	r3, [r7, #24]
    57da:	685b      	ldr	r3, [r3, #4]
    57dc:	60fb      	str	r3, [r7, #12]
          if (iprh_prev->end != iprh->start) {
    57de:	697b      	ldr	r3, [r7, #20]
    57e0:	799a      	ldrb	r2, [r3, #6]
    57e2:	79db      	ldrb	r3, [r3, #7]
    57e4:	ea4f 2303 	mov.w	r3, r3, lsl #8
    57e8:	ea43 0302 	orr.w	r3, r3, r2
    57ec:	b29a      	uxth	r2, r3
    57ee:	68fb      	ldr	r3, [r7, #12]
    57f0:	7919      	ldrb	r1, [r3, #4]
    57f2:	795b      	ldrb	r3, [r3, #5]
    57f4:	ea4f 2303 	mov.w	r3, r3, lsl #8
    57f8:	ea43 0301 	orr.w	r3, r3, r1
    57fc:	b29b      	uxth	r3, r3
    57fe:	429a      	cmp	r2, r3
    5800:	d003      	beq.n	580a <ip_reass_chain_frag_into_datagram_and_validate+0x396>
            valid = 0;
    5802:	f04f 0300 	mov.w	r3, #0
    5806:	627b      	str	r3, [r7, #36]	; 0x24
            break;
    5808:	e016      	b.n	5838 <ip_reass_chain_frag_into_datagram_and_validate+0x3c4>
          }
          iprh_prev = iprh;
    580a:	68fb      	ldr	r3, [r7, #12]
    580c:	617b      	str	r3, [r7, #20]
          q = iprh->next_pbuf;
    580e:	68fb      	ldr	r3, [r7, #12]
    5810:	781a      	ldrb	r2, [r3, #0]
    5812:	7859      	ldrb	r1, [r3, #1]
    5814:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5818:	ea41 0202 	orr.w	r2, r1, r2
    581c:	7899      	ldrb	r1, [r3, #2]
    581e:	ea4f 4101 	mov.w	r1, r1, lsl #16
    5822:	ea41 0202 	orr.w	r2, r1, r2
    5826:	78db      	ldrb	r3, [r3, #3]
    5828:	ea4f 6303 	mov.w	r3, r3, lsl #24
    582c:	ea43 0302 	orr.w	r3, r3, r2
    5830:	61bb      	str	r3, [r7, #24]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    5832:	69bb      	ldr	r3, [r7, #24]
    5834:	2b00      	cmp	r3, #0
    5836:	d1cf      	bne.n	57d8 <ip_reass_chain_frag_into_datagram_and_validate+0x364>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
    5838:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    583a:	2b00      	cmp	r3, #0
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
    583c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    583e:	e01b      	b.n	5878 <ip_reass_chain_frag_into_datagram_and_validate+0x404>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
    5840:	f04f 0300 	mov.w	r3, #0
    5844:	e018      	b.n	5878 <ip_reass_chain_frag_into_datagram_and_validate+0x404>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
    5846:	bf00      	nop
    5848:	e000      	b.n	584c <ip_reass_chain_frag_into_datagram_and_validate+0x3d8>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
    584a:	bf00      	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    584c:	f243 134c 	movw	r3, #12620	; 0x314c
    5850:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5854:	881c      	ldrh	r4, [r3, #0]
    5856:	6838      	ldr	r0, [r7, #0]
    5858:	f7fd fcb0 	bl	31bc <pbuf_clen>
    585c:	4603      	mov	r3, r0
    585e:	ebc3 0304 	rsb	r3, r3, r4
    5862:	b29a      	uxth	r2, r3
    5864:	f243 134c 	movw	r3, #12620	; 0x314c
    5868:	f2c2 0300 	movt	r3, #8192	; 0x2000
    586c:	801a      	strh	r2, [r3, #0]
  pbuf_free(new_p);
    586e:	6838      	ldr	r0, [r7, #0]
    5870:	f7fd fc40 	bl	30f4 <pbuf_free>
  return 0;
    5874:	f04f 0300 	mov.w	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
    5878:	4618      	mov	r0, r3
    587a:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    587e:	46bd      	mov	sp, r7
    5880:	bd90      	pop	{r4, r7, pc}
    5882:	bf00      	nop

00005884 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    5884:	b590      	push	{r4, r7, lr}
    5886:	b08b      	sub	sp, #44	; 0x2c
    5888:	af00      	add	r7, sp, #0
    588a:	6078      	str	r0, [r7, #4]
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    588c:	f04f 0300 	mov.w	r3, #0
    5890:	627b      	str	r3, [r7, #36]	; 0x24

  IPFRAG_STATS_INC(ip_frag.recv);
    5892:	f247 0330 	movw	r3, #28720	; 0x7030
    5896:	f2c2 0300 	movt	r3, #8192	; 0x2000
    589a:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
    589c:	f103 0301 	add.w	r3, r3, #1
    58a0:	b29a      	uxth	r2, r3
    58a2:	f247 0330 	movw	r3, #28720	; 0x7030
    58a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58aa:	865a      	strh	r2, [r3, #50]	; 0x32
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    58ac:	687b      	ldr	r3, [r7, #4]
    58ae:	685b      	ldr	r3, [r3, #4]
    58b0:	613b      	str	r3, [r7, #16]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    58b2:	693b      	ldr	r3, [r7, #16]
    58b4:	781a      	ldrb	r2, [r3, #0]
    58b6:	785b      	ldrb	r3, [r3, #1]
    58b8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    58bc:	ea43 0302 	orr.w	r3, r3, r2
    58c0:	b29b      	uxth	r3, r3
    58c2:	4618      	mov	r0, r3
    58c4:	f7fc fb2a 	bl	1f1c <lwip_ntohs>
    58c8:	4603      	mov	r3, r0
    58ca:	ea4f 2313 	mov.w	r3, r3, lsr #8
    58ce:	b29b      	uxth	r3, r3
    58d0:	f003 030f 	and.w	r3, r3, #15
    58d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    58d8:	2b14      	cmp	r3, #20
    58da:	d00f      	beq.n	58fc <ip_reass+0x78>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    58dc:	f247 0330 	movw	r3, #28720	; 0x7030
    58e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58e4:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    58e8:	f103 0301 	add.w	r3, r3, #1
    58ec:	b29a      	uxth	r2, r3
    58ee:	f247 0330 	movw	r3, #28720	; 0x7030
    58f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    58f6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    goto nullreturn;
    58fa:	e1cc      	b.n	5c96 <ip_reass+0x412>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    58fc:	693b      	ldr	r3, [r7, #16]
    58fe:	799a      	ldrb	r2, [r3, #6]
    5900:	79db      	ldrb	r3, [r3, #7]
    5902:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5906:	ea43 0302 	orr.w	r3, r3, r2
    590a:	b29b      	uxth	r3, r3
    590c:	4618      	mov	r0, r3
    590e:	f7fc fb05 	bl	1f1c <lwip_ntohs>
    5912:	4603      	mov	r3, r0
    5914:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    5918:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    591c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5920:	83fb      	strh	r3, [r7, #30]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5922:	693b      	ldr	r3, [r7, #16]
    5924:	789a      	ldrb	r2, [r3, #2]
    5926:	78db      	ldrb	r3, [r3, #3]
    5928:	ea4f 2303 	mov.w	r3, r3, lsl #8
    592c:	ea43 0302 	orr.w	r3, r3, r2
    5930:	b29b      	uxth	r3, r3
    5932:	4618      	mov	r0, r3
    5934:	f7fc faf2 	bl	1f1c <lwip_ntohs>
    5938:	4603      	mov	r3, r0
    593a:	461c      	mov	r4, r3
    593c:	693b      	ldr	r3, [r7, #16]
    593e:	781a      	ldrb	r2, [r3, #0]
    5940:	785b      	ldrb	r3, [r3, #1]
    5942:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5946:	ea43 0302 	orr.w	r3, r3, r2
    594a:	b29b      	uxth	r3, r3
    594c:	4618      	mov	r0, r3
    594e:	f7fc fae5 	bl	1f1c <lwip_ntohs>
    5952:	4603      	mov	r3, r0
    5954:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5958:	b29b      	uxth	r3, r3
    595a:	f003 030f 	and.w	r3, r3, #15
    595e:	461a      	mov	r2, r3
    5960:	ea4f 3282 	mov.w	r2, r2, lsl #14
    5964:	ebc3 0302 	rsb	r3, r3, r2
    5968:	ea4f 0383 	mov.w	r3, r3, lsl #2
    596c:	b29b      	uxth	r3, r3
    596e:	4423      	add	r3, r4
    5970:	843b      	strh	r3, [r7, #32]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    5972:	6878      	ldr	r0, [r7, #4]
    5974:	f7fd fc22 	bl	31bc <pbuf_clen>
    5978:	4603      	mov	r3, r0
    597a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    597e:	f243 134c 	movw	r3, #12620	; 0x314c
    5982:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5986:	881b      	ldrh	r3, [r3, #0]
    5988:	461a      	mov	r2, r3
    598a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    598e:	4413      	add	r3, r2
    5990:	2b0a      	cmp	r3, #10
    5992:	dd21      	ble.n	59d8 <ip_reass+0x154>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    5994:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5998:	6938      	ldr	r0, [r7, #16]
    599a:	4619      	mov	r1, r3
    599c:	f7ff fc6c 	bl	5278 <ip_reass_remove_oldest_datagram>
    59a0:	4603      	mov	r3, r0
    59a2:	2b00      	cmp	r3, #0
    59a4:	d00a      	beq.n	59bc <ip_reass+0x138>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    59a6:	f243 134c 	movw	r3, #12620	; 0x314c
    59aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59ae:	881b      	ldrh	r3, [r3, #0]
    59b0:	461a      	mov	r2, r3
    59b2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    59b6:	4413      	add	r3, r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    59b8:	2b0a      	cmp	r3, #10
    59ba:	dd0d      	ble.n	59d8 <ip_reass+0x154>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
    59bc:	f247 0330 	movw	r3, #28720	; 0x7030
    59c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59c4:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
    59c6:	f103 0301 	add.w	r3, r3, #1
    59ca:	b29a      	uxth	r2, r3
    59cc:	f247 0330 	movw	r3, #28720	; 0x7030
    59d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59d4:	879a      	strh	r2, [r3, #60]	; 0x3c
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
    59d6:	e15e      	b.n	5c96 <ip_reass+0x412>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    59d8:	f243 1348 	movw	r3, #12616	; 0x3148
    59dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59e0:	681b      	ldr	r3, [r3, #0]
    59e2:	617b      	str	r3, [r7, #20]
    59e4:	e04a      	b.n	5a7c <ip_reass+0x1f8>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    59e6:	697b      	ldr	r3, [r7, #20]
    59e8:	695a      	ldr	r2, [r3, #20]
    59ea:	693b      	ldr	r3, [r7, #16]
    59ec:	7b19      	ldrb	r1, [r3, #12]
    59ee:	7b58      	ldrb	r0, [r3, #13]
    59f0:	ea4f 2000 	mov.w	r0, r0, lsl #8
    59f4:	ea40 0101 	orr.w	r1, r0, r1
    59f8:	7b98      	ldrb	r0, [r3, #14]
    59fa:	ea4f 4000 	mov.w	r0, r0, lsl #16
    59fe:	ea40 0101 	orr.w	r1, r0, r1
    5a02:	7bdb      	ldrb	r3, [r3, #15]
    5a04:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a08:	ea43 0301 	orr.w	r3, r3, r1
    5a0c:	429a      	cmp	r2, r3
    5a0e:	d130      	bne.n	5a72 <ip_reass+0x1ee>
    5a10:	697b      	ldr	r3, [r7, #20]
    5a12:	699a      	ldr	r2, [r3, #24]
    5a14:	693b      	ldr	r3, [r7, #16]
    5a16:	7c19      	ldrb	r1, [r3, #16]
    5a18:	7c58      	ldrb	r0, [r3, #17]
    5a1a:	ea4f 2000 	mov.w	r0, r0, lsl #8
    5a1e:	ea40 0101 	orr.w	r1, r0, r1
    5a22:	7c98      	ldrb	r0, [r3, #18]
    5a24:	ea4f 4000 	mov.w	r0, r0, lsl #16
    5a28:	ea40 0101 	orr.w	r1, r0, r1
    5a2c:	7cdb      	ldrb	r3, [r3, #19]
    5a2e:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5a32:	ea43 0301 	orr.w	r3, r3, r1
    5a36:	429a      	cmp	r2, r3
    5a38:	d11b      	bne.n	5a72 <ip_reass+0x1ee>
    5a3a:	697b      	ldr	r3, [r7, #20]
    5a3c:	899a      	ldrh	r2, [r3, #12]
    5a3e:	693b      	ldr	r3, [r7, #16]
    5a40:	7919      	ldrb	r1, [r3, #4]
    5a42:	795b      	ldrb	r3, [r3, #5]
    5a44:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5a48:	ea43 0301 	orr.w	r3, r3, r1
    5a4c:	b29b      	uxth	r3, r3
    5a4e:	429a      	cmp	r2, r3
    5a50:	d10f      	bne.n	5a72 <ip_reass+0x1ee>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    5a52:	f247 0330 	movw	r3, #28720	; 0x7030
    5a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a5a:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
    5a5e:	f103 0301 	add.w	r3, r3, #1
    5a62:	b29a      	uxth	r2, r3
    5a64:	f247 0330 	movw	r3, #28720	; 0x7030
    5a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a6c:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
      break;
    5a70:	e007      	b.n	5a82 <ip_reass+0x1fe>
    }
    ipr_prev = ipr;
    5a72:	697b      	ldr	r3, [r7, #20]
    5a74:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    5a76:	697b      	ldr	r3, [r7, #20]
    5a78:	681b      	ldr	r3, [r3, #0]
    5a7a:	617b      	str	r3, [r7, #20]
    5a7c:	697b      	ldr	r3, [r7, #20]
    5a7e:	2b00      	cmp	r3, #0
    5a80:	d1b1      	bne.n	59e6 <ip_reass+0x162>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
    5a82:	697b      	ldr	r3, [r7, #20]
    5a84:	2b00      	cmp	r3, #0
    5a86:	d10b      	bne.n	5aa0 <ip_reass+0x21c>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    5a88:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5a8c:	6938      	ldr	r0, [r7, #16]
    5a8e:	4619      	mov	r1, r3
    5a90:	f7ff fc78 	bl	5384 <ip_reass_enqueue_new_datagram>
    5a94:	4603      	mov	r3, r0
    5a96:	617b      	str	r3, [r7, #20]
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
    5a98:	697b      	ldr	r3, [r7, #20]
    5a9a:	2b00      	cmp	r3, #0
    5a9c:	d128      	bne.n	5af0 <ip_reass+0x26c>
      goto nullreturn;
    5a9e:	e0fa      	b.n	5c96 <ip_reass+0x412>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5aa0:	693b      	ldr	r3, [r7, #16]
    5aa2:	799a      	ldrb	r2, [r3, #6]
    5aa4:	79db      	ldrb	r3, [r3, #7]
    5aa6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5aaa:	ea43 0302 	orr.w	r3, r3, r2
    5aae:	b29b      	uxth	r3, r3
    5ab0:	4618      	mov	r0, r3
    5ab2:	f7fc fa33 	bl	1f1c <lwip_ntohs>
    5ab6:	4603      	mov	r3, r0
    5ab8:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    5abc:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    5ac0:	2b00      	cmp	r3, #0
    5ac2:	d116      	bne.n	5af2 <ip_reass+0x26e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    5ac4:	697b      	ldr	r3, [r7, #20]
    5ac6:	89db      	ldrh	r3, [r3, #14]
    5ac8:	4618      	mov	r0, r3
    5aca:	f7fc fa27 	bl	1f1c <lwip_ntohs>
    5ace:	4603      	mov	r3, r0
    5ad0:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    5ad4:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5ad8:	2b00      	cmp	r3, #0
    5ada:	d00a      	beq.n	5af2 <ip_reass+0x26e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    5adc:	697b      	ldr	r3, [r7, #20]
    5ade:	f103 0308 	add.w	r3, r3, #8
    5ae2:	4618      	mov	r0, r3
    5ae4:	6939      	ldr	r1, [r7, #16]
    5ae6:	f04f 0214 	mov.w	r2, #20
    5aea:	f003 f89b 	bl	8c24 <memcpy>
    5aee:	e000      	b.n	5af2 <ip_reass+0x26e>
  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    5af0:	bf00      	nop
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    5af2:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    5af6:	f243 134c 	movw	r3, #12620	; 0x314c
    5afa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5afe:	881b      	ldrh	r3, [r3, #0]
    5b00:	4413      	add	r3, r2
    5b02:	b29a      	uxth	r2, r3
    5b04:	f243 134c 	movw	r3, #12620	; 0x314c
    5b08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b0c:	801a      	strh	r2, [r3, #0]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    5b0e:	693b      	ldr	r3, [r7, #16]
    5b10:	799a      	ldrb	r2, [r3, #6]
    5b12:	79db      	ldrb	r3, [r3, #7]
    5b14:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5b18:	ea43 0302 	orr.w	r3, r3, r2
    5b1c:	b29b      	uxth	r3, r3
    5b1e:	f003 0320 	and.w	r3, r3, #32
    5b22:	2b00      	cmp	r3, #0
    5b24:	d10c      	bne.n	5b40 <ip_reass+0x2bc>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    5b26:	697b      	ldr	r3, [r7, #20]
    5b28:	7f9b      	ldrb	r3, [r3, #30]
    5b2a:	f043 0301 	orr.w	r3, r3, #1
    5b2e:	b2da      	uxtb	r2, r3
    5b30:	697b      	ldr	r3, [r7, #20]
    5b32:	779a      	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
    5b34:	8bfa      	ldrh	r2, [r7, #30]
    5b36:	8c3b      	ldrh	r3, [r7, #32]
    5b38:	4413      	add	r3, r2
    5b3a:	b29a      	uxth	r2, r3
    5b3c:	697b      	ldr	r3, [r7, #20]
    5b3e:	839a      	strh	r2, [r3, #28]
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    5b40:	6978      	ldr	r0, [r7, #20]
    5b42:	6879      	ldr	r1, [r7, #4]
    5b44:	f7ff fc96 	bl	5474 <ip_reass_chain_frag_into_datagram_and_validate>
    5b48:	4603      	mov	r3, r0
    5b4a:	2b00      	cmp	r3, #0
    5b4c:	f000 80a0 	beq.w	5c90 <ip_reass+0x40c>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    5b50:	697b      	ldr	r3, [r7, #20]
    5b52:	8b9b      	ldrh	r3, [r3, #28]
    5b54:	f103 0314 	add.w	r3, r3, #20
    5b58:	b29a      	uxth	r2, r3
    5b5a:	697b      	ldr	r3, [r7, #20]
    5b5c:	839a      	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    5b5e:	697b      	ldr	r3, [r7, #20]
    5b60:	685b      	ldr	r3, [r3, #4]
    5b62:	685b      	ldr	r3, [r3, #4]
    5b64:	781a      	ldrb	r2, [r3, #0]
    5b66:	7859      	ldrb	r1, [r3, #1]
    5b68:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5b6c:	ea41 0202 	orr.w	r2, r1, r2
    5b70:	7899      	ldrb	r1, [r3, #2]
    5b72:	ea4f 4101 	mov.w	r1, r1, lsl #16
    5b76:	ea41 0202 	orr.w	r2, r1, r2
    5b7a:	78db      	ldrb	r3, [r3, #3]
    5b7c:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5b80:	ea43 0302 	orr.w	r3, r3, r2
    5b84:	60fb      	str	r3, [r7, #12]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    5b86:	697b      	ldr	r3, [r7, #20]
    5b88:	685b      	ldr	r3, [r3, #4]
    5b8a:	685b      	ldr	r3, [r3, #4]
    5b8c:	613b      	str	r3, [r7, #16]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    5b8e:	697b      	ldr	r3, [r7, #20]
    5b90:	f103 0308 	add.w	r3, r3, #8
    5b94:	6938      	ldr	r0, [r7, #16]
    5b96:	4619      	mov	r1, r3
    5b98:	f04f 0214 	mov.w	r2, #20
    5b9c:	f003 f842 	bl	8c24 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    5ba0:	697b      	ldr	r3, [r7, #20]
    5ba2:	8b9b      	ldrh	r3, [r3, #28]
    5ba4:	4618      	mov	r0, r3
    5ba6:	f7fc f9a1 	bl	1eec <lwip_htons>
    5baa:	4603      	mov	r3, r0
    5bac:	461a      	mov	r2, r3
    5bae:	693b      	ldr	r3, [r7, #16]
    5bb0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5bb4:	f04f 0000 	mov.w	r0, #0
    5bb8:	ea40 0101 	orr.w	r1, r0, r1
    5bbc:	7099      	strb	r1, [r3, #2]
    5bbe:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5bc2:	b292      	uxth	r2, r2
    5bc4:	f04f 0100 	mov.w	r1, #0
    5bc8:	ea41 0202 	orr.w	r2, r1, r2
    5bcc:	70da      	strb	r2, [r3, #3]
    IPH_OFFSET_SET(fraghdr, 0);
    5bce:	693b      	ldr	r3, [r7, #16]
    5bd0:	f04f 0200 	mov.w	r2, #0
    5bd4:	719a      	strb	r2, [r3, #6]
    5bd6:	f04f 0200 	mov.w	r2, #0
    5bda:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
    5bdc:	693b      	ldr	r3, [r7, #16]
    5bde:	f04f 0200 	mov.w	r2, #0
    5be2:	729a      	strb	r2, [r3, #10]
    5be4:	f04f 0200 	mov.w	r2, #0
    5be8:	72da      	strb	r2, [r3, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    5bea:	6938      	ldr	r0, [r7, #16]
    5bec:	f04f 0114 	mov.w	r1, #20
    5bf0:	f7fe fd1e 	bl	4630 <inet_chksum>
    5bf4:	4603      	mov	r3, r0
    5bf6:	461a      	mov	r2, r3
    5bf8:	693b      	ldr	r3, [r7, #16]
    5bfa:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5bfe:	f04f 0000 	mov.w	r0, #0
    5c02:	ea40 0101 	orr.w	r1, r0, r1
    5c06:	7299      	strb	r1, [r3, #10]
    5c08:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5c0c:	b292      	uxth	r2, r2
    5c0e:	f04f 0100 	mov.w	r1, #0
    5c12:	ea41 0202 	orr.w	r2, r1, r2
    5c16:	72da      	strb	r2, [r3, #11]

    p = ipr->p;
    5c18:	697b      	ldr	r3, [r7, #20]
    5c1a:	685b      	ldr	r3, [r3, #4]
    5c1c:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    5c1e:	e01d      	b.n	5c5c <ip_reass+0x3d8>
      iprh = (struct ip_reass_helper*)r->payload;
    5c20:	68fb      	ldr	r3, [r7, #12]
    5c22:	685b      	ldr	r3, [r3, #4]
    5c24:	61bb      	str	r3, [r7, #24]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    5c26:	68f8      	ldr	r0, [r7, #12]
    5c28:	f06f 0113 	mvn.w	r1, #19
    5c2c:	f7fd f9e6 	bl	2ffc <pbuf_header>
      pbuf_cat(p, r);
    5c30:	6878      	ldr	r0, [r7, #4]
    5c32:	68f9      	ldr	r1, [r7, #12]
    5c34:	f7fd faf0 	bl	3218 <pbuf_cat>
      r = iprh->next_pbuf;
    5c38:	69bb      	ldr	r3, [r7, #24]
    5c3a:	781a      	ldrb	r2, [r3, #0]
    5c3c:	7859      	ldrb	r1, [r3, #1]
    5c3e:	ea4f 2101 	mov.w	r1, r1, lsl #8
    5c42:	ea41 0202 	orr.w	r2, r1, r2
    5c46:	7899      	ldrb	r1, [r3, #2]
    5c48:	ea4f 4101 	mov.w	r1, r1, lsl #16
    5c4c:	ea41 0202 	orr.w	r2, r1, r2
    5c50:	78db      	ldrb	r3, [r3, #3]
    5c52:	ea4f 6303 	mov.w	r3, r3, lsl #24
    5c56:	ea43 0302 	orr.w	r3, r3, r2
    5c5a:	60fb      	str	r3, [r7, #12]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    5c5c:	68fb      	ldr	r3, [r7, #12]
    5c5e:	2b00      	cmp	r3, #0
    5c60:	d1de      	bne.n	5c20 <ip_reass+0x39c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    5c62:	6978      	ldr	r0, [r7, #20]
    5c64:	6a79      	ldr	r1, [r7, #36]	; 0x24
    5c66:	f7ff fbe3 	bl	5430 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    5c6a:	f243 134c 	movw	r3, #12620	; 0x314c
    5c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c72:	881c      	ldrh	r4, [r3, #0]
    5c74:	6878      	ldr	r0, [r7, #4]
    5c76:	f7fd faa1 	bl	31bc <pbuf_clen>
    5c7a:	4603      	mov	r3, r0
    5c7c:	ebc3 0304 	rsb	r3, r3, r4
    5c80:	b29a      	uxth	r2, r3
    5c82:	f243 134c 	movw	r3, #12620	; 0x314c
    5c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c8a:	801a      	strh	r2, [r3, #0]

    /* Return the pbuf chain */
    return p;
    5c8c:	687b      	ldr	r3, [r7, #4]
    5c8e:	e014      	b.n	5cba <ip_reass+0x436>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    5c90:	f04f 0300 	mov.w	r3, #0
    5c94:	e011      	b.n	5cba <ip_reass+0x436>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    5c96:	f247 0330 	movw	r3, #28720	; 0x7030
    5c9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c9e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    5ca0:	f103 0301 	add.w	r3, r3, #1
    5ca4:	b29a      	uxth	r2, r3
    5ca6:	f247 0330 	movw	r3, #28720	; 0x7030
    5caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5cae:	86da      	strh	r2, [r3, #54]	; 0x36
  pbuf_free(p);
    5cb0:	6878      	ldr	r0, [r7, #4]
    5cb2:	f7fd fa1f 	bl	30f4 <pbuf_free>
  return NULL;
    5cb6:	f04f 0300 	mov.w	r3, #0
}
    5cba:	4618      	mov	r0, r3
    5cbc:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    5cc0:	46bd      	mov	sp, r7
    5cc2:	bd90      	pop	{r4, r7, pc}

00005cc4 <ip_frag_alloc_pbuf_custom_ref>:

#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
    5cc4:	b580      	push	{r7, lr}
    5cc6:	af00      	add	r7, sp, #0
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
    5cc8:	f04f 0003 	mov.w	r0, #3
    5ccc:	f7fc fdbc 	bl	2848 <memp_malloc>
    5cd0:	4603      	mov	r3, r0
}
    5cd2:	4618      	mov	r0, r3
    5cd4:	bd80      	pop	{r7, pc}
    5cd6:	bf00      	nop

00005cd8 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
    5cd8:	b580      	push	{r7, lr}
    5cda:	b082      	sub	sp, #8
    5cdc:	af00      	add	r7, sp, #0
    5cde:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
    5ce0:	f04f 0003 	mov.w	r0, #3
    5ce4:	6879      	ldr	r1, [r7, #4]
    5ce6:	f7fc fe59 	bl	299c <memp_free>
}
    5cea:	f107 0708 	add.w	r7, r7, #8
    5cee:	46bd      	mov	sp, r7
    5cf0:	bd80      	pop	{r7, pc}
    5cf2:	bf00      	nop

00005cf4 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
    5cf4:	b580      	push	{r7, lr}
    5cf6:	b084      	sub	sp, #16
    5cf8:	af00      	add	r7, sp, #0
    5cfa:	6078      	str	r0, [r7, #4]
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
    5cfc:	687b      	ldr	r3, [r7, #4]
    5cfe:	60fb      	str	r3, [r7, #12]
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
    5d00:	68fb      	ldr	r3, [r7, #12]
    5d02:	695b      	ldr	r3, [r3, #20]
    5d04:	2b00      	cmp	r3, #0
    5d06:	d004      	beq.n	5d12 <ipfrag_free_pbuf_custom+0x1e>
    pbuf_free(pcr->original);
    5d08:	68fb      	ldr	r3, [r7, #12]
    5d0a:	695b      	ldr	r3, [r3, #20]
    5d0c:	4618      	mov	r0, r3
    5d0e:	f7fd f9f1 	bl	30f4 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
    5d12:	68f8      	ldr	r0, [r7, #12]
    5d14:	f7ff ffe0 	bl	5cd8 <ip_frag_free_pbuf_custom_ref>
}
    5d18:	f107 0710 	add.w	r7, r7, #16
    5d1c:	46bd      	mov	sp, r7
    5d1e:	bd80      	pop	{r7, pc}

00005d20 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    5d20:	b580      	push	{r7, lr}
    5d22:	b092      	sub	sp, #72	; 0x48
    5d24:	af02      	add	r7, sp, #8
    5d26:	60f8      	str	r0, [r7, #12]
    5d28:	60b9      	str	r1, [r7, #8]
    5d2a:	607a      	str	r2, [r7, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    5d2c:	68bb      	ldr	r3, [r7, #8]
    5d2e:	8c1b      	ldrh	r3, [r3, #32]
    5d30:	85bb      	strh	r3, [r7, #44]	; 0x2c
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    5d32:	f04f 0314 	mov.w	r3, #20
    5d36:	86bb      	strh	r3, [r7, #52]	; 0x34
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
  u16_t newpbuflen = 0;
    5d38:	f04f 0300 	mov.w	r3, #0
    5d3c:	873b      	strh	r3, [r7, #56]	; 0x38

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
    5d3e:	68fb      	ldr	r3, [r7, #12]
    5d40:	685b      	ldr	r3, [r3, #4]
    5d42:	61fb      	str	r3, [r7, #28]
  iphdr = original_iphdr;
    5d44:	69fb      	ldr	r3, [r7, #28]
    5d46:	623b      	str	r3, [r7, #32]
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    5d48:	6a3b      	ldr	r3, [r7, #32]
    5d4a:	799a      	ldrb	r2, [r3, #6]
    5d4c:	79db      	ldrb	r3, [r3, #7]
    5d4e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5d52:	ea43 0302 	orr.w	r3, r3, r2
    5d56:	b29b      	uxth	r3, r3
    5d58:	4618      	mov	r0, r3
    5d5a:	f7fc f8df 	bl	1f1c <lwip_ntohs>
    5d5e:	4603      	mov	r3, r0
    5d60:	86fb      	strh	r3, [r7, #54]	; 0x36
  ofo = tmp & IP_OFFMASK;
    5d62:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    5d64:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    5d68:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    5d6c:	85fb      	strh	r3, [r7, #46]	; 0x2e
  omf = tmp & IP_MF;
    5d6e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    5d70:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    5d74:	863b      	strh	r3, [r7, #48]	; 0x30

  left = p->tot_len - IP_HLEN;
    5d76:	68fb      	ldr	r3, [r7, #12]
    5d78:	891b      	ldrh	r3, [r3, #8]
    5d7a:	f1a3 0314 	sub.w	r3, r3, #20
    5d7e:	853b      	strh	r3, [r7, #40]	; 0x28

  nfb = (mtu - IP_HLEN) / 8;
    5d80:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    5d82:	f1a3 0314 	sub.w	r3, r3, #20
    5d86:	f103 0207 	add.w	r2, r3, #7
    5d8a:	2b00      	cmp	r3, #0
    5d8c:	bfb8      	it	lt
    5d8e:	4613      	movlt	r3, r2
    5d90:	ea4f 03e3 	mov.w	r3, r3, asr #3
    5d94:	84fb      	strh	r3, [r7, #38]	; 0x26

  while (left) {
    5d96:	e111      	b.n	5fbc <ip_frag+0x29c>
    last = (left <= mtu - IP_HLEN);
    5d98:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
    5d9a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    5d9c:	f1a3 0314 	sub.w	r3, r3, #20
    5da0:	429a      	cmp	r2, r3
    5da2:	bfcc      	ite	gt
    5da4:	2300      	movgt	r3, #0
    5da6:	2301      	movle	r3, #1
    5da8:	867b      	strh	r3, [r7, #50]	; 0x32

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    5daa:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
    5dac:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    5db0:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    5db4:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
    5db6:	ea43 0302 	orr.w	r3, r3, r2
    5dba:	86fb      	strh	r3, [r7, #54]	; 0x36
    if (!last) {
    5dbc:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    5dbe:	2b00      	cmp	r3, #0
    5dc0:	d103      	bne.n	5dca <ip_frag+0xaa>
      tmp = tmp | IP_MF;
    5dc2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    5dc4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    5dc8:	86fb      	strh	r3, [r7, #54]	; 0x36
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    5dca:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    5dcc:	2b00      	cmp	r3, #0
    5dce:	d104      	bne.n	5dda <ip_frag+0xba>
    5dd0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    5dd2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5dd6:	b29b      	uxth	r3, r3
    5dd8:	e000      	b.n	5ddc <ip_frag+0xbc>
    5dda:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    5ddc:	857b      	strh	r3, [r7, #42]	; 0x2a
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    5dde:	f04f 0002 	mov.w	r0, #2
    5de2:	f04f 0114 	mov.w	r1, #20
    5de6:	f04f 0200 	mov.w	r2, #0
    5dea:	f7fc ff05 	bl	2bf8 <pbuf_alloc>
    5dee:	4603      	mov	r3, r0
    5df0:	617b      	str	r3, [r7, #20]
    if (rambuf == NULL) {
    5df2:	697b      	ldr	r3, [r7, #20]
    5df4:	2b00      	cmp	r3, #0
    5df6:	d102      	bne.n	5dfe <ip_frag+0xde>
      return ERR_MEM;
    5df8:	f04f 03ff 	mov.w	r3, #255	; 0xff
    5dfc:	e0e4      	b.n	5fc8 <ip_frag+0x2a8>
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    5dfe:	697b      	ldr	r3, [r7, #20]
    5e00:	685b      	ldr	r3, [r3, #4]
    5e02:	4618      	mov	r0, r3
    5e04:	69f9      	ldr	r1, [r7, #28]
    5e06:	f04f 0214 	mov.w	r2, #20
    5e0a:	f002 ff0b 	bl	8c24 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
    5e0e:	697b      	ldr	r3, [r7, #20]
    5e10:	685b      	ldr	r3, [r3, #4]
    5e12:	623b      	str	r3, [r7, #32]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    5e14:	68fb      	ldr	r3, [r7, #12]
    5e16:	685a      	ldr	r2, [r3, #4]
    5e18:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    5e1a:	441a      	add	r2, r3
    5e1c:	68fb      	ldr	r3, [r7, #12]
    5e1e:	605a      	str	r2, [r3, #4]
    p->len -= poff;
    5e20:	68fb      	ldr	r3, [r7, #12]
    5e22:	895a      	ldrh	r2, [r3, #10]
    5e24:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    5e26:	ebc3 0302 	rsb	r3, r3, r2
    5e2a:	b29a      	uxth	r2, r3
    5e2c:	68fb      	ldr	r3, [r7, #12]
    5e2e:	815a      	strh	r2, [r3, #10]

    left_to_copy = cop;
    5e30:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
    5e32:	877b      	strh	r3, [r7, #58]	; 0x3a
    while (left_to_copy) {
    5e34:	e051      	b.n	5eda <ip_frag+0x1ba>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    5e36:	68fb      	ldr	r3, [r7, #12]
    5e38:	895a      	ldrh	r2, [r3, #10]
    5e3a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
    5e3c:	429a      	cmp	r2, r3
    5e3e:	bf38      	it	cc
    5e40:	4613      	movcc	r3, r2
    5e42:	873b      	strh	r3, [r7, #56]	; 0x38
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
    5e44:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
    5e46:	2b00      	cmp	r3, #0
    5e48:	d103      	bne.n	5e52 <ip_frag+0x132>
        p = p->next;
    5e4a:	68fb      	ldr	r3, [r7, #12]
    5e4c:	681b      	ldr	r3, [r3, #0]
    5e4e:	60fb      	str	r3, [r7, #12]
        continue;
    5e50:	e043      	b.n	5eda <ip_frag+0x1ba>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
    5e52:	f7ff ff37 	bl	5cc4 <ip_frag_alloc_pbuf_custom_ref>
    5e56:	4603      	mov	r3, r0
    5e58:	63fb      	str	r3, [r7, #60]	; 0x3c
      if (pcr == NULL) {
    5e5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    5e5c:	2b00      	cmp	r3, #0
    5e5e:	d105      	bne.n	5e6c <ip_frag+0x14c>
        pbuf_free(rambuf);
    5e60:	6978      	ldr	r0, [r7, #20]
    5e62:	f7fd f947 	bl	30f4 <pbuf_free>
        return ERR_MEM;
    5e66:	f04f 03ff 	mov.w	r3, #255	; 0xff
    5e6a:	e0ad      	b.n	5fc8 <ip_frag+0x2a8>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    5e6c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    5e6e:	68fa      	ldr	r2, [r7, #12]
    5e70:	6851      	ldr	r1, [r2, #4]
    5e72:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
    5e74:	9100      	str	r1, [sp, #0]
    5e76:	8f39      	ldrh	r1, [r7, #56]	; 0x38
    5e78:	9101      	str	r1, [sp, #4]
    5e7a:	f04f 0003 	mov.w	r0, #3
    5e7e:	4611      	mov	r1, r2
    5e80:	f04f 0202 	mov.w	r2, #2
    5e84:	f7fc ffe4 	bl	2e50 <pbuf_alloced_custom>
    5e88:	4603      	mov	r3, r0
    5e8a:	61bb      	str	r3, [r7, #24]
      if (newpbuf == NULL) {
    5e8c:	69bb      	ldr	r3, [r7, #24]
    5e8e:	2b00      	cmp	r3, #0
    5e90:	d108      	bne.n	5ea4 <ip_frag+0x184>
        ip_frag_free_pbuf_custom_ref(pcr);
    5e92:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    5e94:	f7ff ff20 	bl	5cd8 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
    5e98:	6978      	ldr	r0, [r7, #20]
    5e9a:	f7fd f92b 	bl	30f4 <pbuf_free>
        return ERR_MEM;
    5e9e:	f04f 03ff 	mov.w	r3, #255	; 0xff
    5ea2:	e091      	b.n	5fc8 <ip_frag+0x2a8>
      }
      pbuf_ref(p);
    5ea4:	68f8      	ldr	r0, [r7, #12]
    5ea6:	f7fd f9a3 	bl	31f0 <pbuf_ref>
      pcr->original = p;
    5eaa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    5eac:	68fa      	ldr	r2, [r7, #12]
    5eae:	615a      	str	r2, [r3, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    5eb0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    5eb2:	f645 43f5 	movw	r3, #23797	; 0x5cf5
    5eb6:	f2c0 0300 	movt	r3, #0
    5eba:	6113      	str	r3, [r2, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
    5ebc:	6978      	ldr	r0, [r7, #20]
    5ebe:	69b9      	ldr	r1, [r7, #24]
    5ec0:	f7fd f9aa 	bl	3218 <pbuf_cat>
      left_to_copy -= newpbuflen;
    5ec4:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
    5ec6:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
    5ec8:	ebc3 0302 	rsb	r3, r3, r2
    5ecc:	877b      	strh	r3, [r7, #58]	; 0x3a
      if (left_to_copy) {
    5ece:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
    5ed0:	2b00      	cmp	r3, #0
    5ed2:	d002      	beq.n	5eda <ip_frag+0x1ba>
        p = p->next;
    5ed4:	68fb      	ldr	r3, [r7, #12]
    5ed6:	681b      	ldr	r3, [r3, #0]
    5ed8:	60fb      	str	r3, [r7, #12]
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
    5eda:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
    5edc:	2b00      	cmp	r3, #0
    5ede:	d1aa      	bne.n	5e36 <ip_frag+0x116>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
    5ee0:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
    5ee2:	86bb      	strh	r3, [r7, #52]	; 0x34
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    5ee4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    5ee6:	4618      	mov	r0, r3
    5ee8:	f7fc f800 	bl	1eec <lwip_htons>
    5eec:	4603      	mov	r3, r0
    5eee:	461a      	mov	r2, r3
    5ef0:	6a3b      	ldr	r3, [r7, #32]
    5ef2:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5ef6:	f04f 0000 	mov.w	r0, #0
    5efa:	ea40 0101 	orr.w	r1, r0, r1
    5efe:	7199      	strb	r1, [r3, #6]
    5f00:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5f04:	b292      	uxth	r2, r2
    5f06:	f04f 0100 	mov.w	r1, #0
    5f0a:	ea41 0202 	orr.w	r2, r1, r2
    5f0e:	71da      	strb	r2, [r3, #7]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    5f10:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
    5f12:	f103 0314 	add.w	r3, r3, #20
    5f16:	b29b      	uxth	r3, r3
    5f18:	4618      	mov	r0, r3
    5f1a:	f7fb ffe7 	bl	1eec <lwip_htons>
    5f1e:	4603      	mov	r3, r0
    5f20:	461a      	mov	r2, r3
    5f22:	6a3b      	ldr	r3, [r7, #32]
    5f24:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5f28:	f04f 0000 	mov.w	r0, #0
    5f2c:	ea40 0101 	orr.w	r1, r0, r1
    5f30:	7099      	strb	r1, [r3, #2]
    5f32:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5f36:	b292      	uxth	r2, r2
    5f38:	f04f 0100 	mov.w	r1, #0
    5f3c:	ea41 0202 	orr.w	r2, r1, r2
    5f40:	70da      	strb	r2, [r3, #3]
    IPH_CHKSUM_SET(iphdr, 0);
    5f42:	6a3b      	ldr	r3, [r7, #32]
    5f44:	f04f 0200 	mov.w	r2, #0
    5f48:	729a      	strb	r2, [r3, #10]
    5f4a:	f04f 0200 	mov.w	r2, #0
    5f4e:	72da      	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    5f50:	6a38      	ldr	r0, [r7, #32]
    5f52:	f04f 0114 	mov.w	r1, #20
    5f56:	f7fe fb6b 	bl	4630 <inet_chksum>
    5f5a:	4603      	mov	r3, r0
    5f5c:	461a      	mov	r2, r3
    5f5e:	6a3b      	ldr	r3, [r7, #32]
    5f60:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5f64:	f04f 0000 	mov.w	r0, #0
    5f68:	ea40 0101 	orr.w	r1, r0, r1
    5f6c:	7299      	strb	r1, [r3, #10]
    5f6e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    5f72:	b292      	uxth	r2, r2
    5f74:	f04f 0100 	mov.w	r1, #0
    5f78:	ea41 0202 	orr.w	r2, r1, r2
    5f7c:	72da      	strb	r2, [r3, #11]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
    5f7e:	68bb      	ldr	r3, [r7, #8]
    5f80:	695b      	ldr	r3, [r3, #20]
    5f82:	68b8      	ldr	r0, [r7, #8]
    5f84:	6979      	ldr	r1, [r7, #20]
    5f86:	687a      	ldr	r2, [r7, #4]
    5f88:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
    5f8a:	f247 0330 	movw	r3, #28720	; 0x7030
    5f8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f92:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
    5f94:	f103 0301 	add.w	r3, r3, #1
    5f98:	b29a      	uxth	r2, r3
    5f9a:	f247 0330 	movw	r3, #28720	; 0x7030
    5f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5fa2:	861a      	strh	r2, [r3, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
    5fa4:	6978      	ldr	r0, [r7, #20]
    5fa6:	f7fd f8a5 	bl	30f4 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    5faa:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
    5fac:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
    5fae:	ebc3 0302 	rsb	r3, r3, r2
    5fb2:	853b      	strh	r3, [r7, #40]	; 0x28
    ofo += nfb;
    5fb4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
    5fb6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    5fb8:	4413      	add	r3, r2
    5fba:	85fb      	strh	r3, [r7, #46]	; 0x2e

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    5fbc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    5fbe:	2b00      	cmp	r3, #0
    5fc0:	f47f aeea 	bne.w	5d98 <ip_frag+0x78>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    5fc4:	f04f 0300 	mov.w	r3, #0
    5fc8:	b25b      	sxtb	r3, r3
}
    5fca:	4618      	mov	r0, r3
    5fcc:	f107 0740 	add.w	r7, r7, #64	; 0x40
    5fd0:	46bd      	mov	sp, r7
    5fd2:	bd80      	pop	{r7, pc}

00005fd4 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    5fd4:	b480      	push	{r7}
    5fd6:	b083      	sub	sp, #12
    5fd8:	af00      	add	r7, sp, #0
    5fda:	4603      	mov	r3, r0
    5fdc:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    5fde:	f24e 1300 	movw	r3, #57600	; 0xe100
    5fe2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    5fe6:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    5fea:	ea4f 1252 	mov.w	r2, r2, lsr #5
    5fee:	88f9      	ldrh	r1, [r7, #6]
    5ff0:	f001 011f 	and.w	r1, r1, #31
    5ff4:	f04f 0001 	mov.w	r0, #1
    5ff8:	fa00 f101 	lsl.w	r1, r0, r1
    5ffc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6000:	f107 070c 	add.w	r7, r7, #12
    6004:	46bd      	mov	sp, r7
    6006:	bc80      	pop	{r7}
    6008:	4770      	bx	lr
    600a:	bf00      	nop

0000600c <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    600c:	b480      	push	{r7}
    600e:	b083      	sub	sp, #12
    6010:	af00      	add	r7, sp, #0
    6012:	4603      	mov	r3, r0
    6014:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    6016:	f24e 1300 	movw	r3, #57600	; 0xe100
    601a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    601e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    6022:	ea4f 1252 	mov.w	r2, r2, lsr #5
    6026:	88f9      	ldrh	r1, [r7, #6]
    6028:	f001 011f 	and.w	r1, r1, #31
    602c:	f04f 0001 	mov.w	r0, #1
    6030:	fa00 f101 	lsl.w	r1, r0, r1
    6034:	f102 0260 	add.w	r2, r2, #96	; 0x60
    6038:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    603c:	f107 070c 	add.w	r7, r7, #12
    6040:	46bd      	mov	sp, r7
    6042:	bc80      	pop	{r7}
    6044:	4770      	bx	lr
    6046:	bf00      	nop

00006048 <PDMA_init>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_init( void )
{
    6048:	b580      	push	{r7, lr}
    604a:	b082      	sub	sp, #8
    604c:	af00      	add	r7, sp, #0
    int32_t i;
    
    /* Enable PDMA master access to comms matrix. */
    SYSREG->AHB_MATRIX_CR |= PDMA_MASTER_ENABLE;
    604e:	f242 0300 	movw	r3, #8192	; 0x2000
    6052:	f2ce 0304 	movt	r3, #57348	; 0xe004
    6056:	f242 0200 	movw	r2, #8192	; 0x2000
    605a:	f2ce 0204 	movt	r2, #57348	; 0xe004
    605e:	6992      	ldr	r2, [r2, #24]
    6060:	f042 0204 	orr.w	r2, r2, #4
    6064:	619a      	str	r2, [r3, #24]
    
    /* Reset PDMA block. */
    SYSREG->SOFT_RST_CR |= PDMA_SOFT_RESET;
    6066:	f242 0300 	movw	r3, #8192	; 0x2000
    606a:	f2ce 0304 	movt	r3, #57348	; 0xe004
    606e:	f242 0200 	movw	r2, #8192	; 0x2000
    6072:	f2ce 0204 	movt	r2, #57348	; 0xe004
    6076:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6078:	f042 0220 	orr.w	r2, r2, #32
    607c:	631a      	str	r2, [r3, #48]	; 0x30
    
    /* Clear any previously pended MSS PDMA interrupt */
    NVIC_ClearPendingIRQ( DMA_IRQn );
    607e:	f04f 0009 	mov.w	r0, #9
    6082:	f7ff ffc3 	bl	600c <NVIC_ClearPendingIRQ>
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
    6086:	f242 0300 	movw	r3, #8192	; 0x2000
    608a:	f2ce 0304 	movt	r3, #57348	; 0xe004
    608e:	f242 0200 	movw	r2, #8192	; 0x2000
    6092:	f2ce 0204 	movt	r2, #57348	; 0xe004
    6096:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6098:	f022 0220 	bic.w	r2, r2, #32
    609c:	631a      	str	r2, [r3, #48]	; 0x30
    
    /* Initialize channels state information. */
    for ( i = 0; i < NB_OF_PDMA_CHANNELS; ++i )
    609e:	f04f 0300 	mov.w	r3, #0
    60a2:	607b      	str	r3, [r7, #4]
    60a4:	e024      	b.n	60f0 <PDMA_init+0xa8>
    {
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
    60a6:	687a      	ldr	r2, [r7, #4]
    60a8:	f243 1350 	movw	r3, #12624	; 0x3150
    60ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60b0:	f04f 0100 	mov.w	r1, #0
    60b4:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[i] = CHANNEL_STOPPED;
    60b6:	687a      	ldr	r2, [r7, #4]
    60b8:	f243 1358 	movw	r3, #12632	; 0x3158
    60bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60c0:	f04f 0100 	mov.w	r1, #0
    60c4:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[i] = CHANNEL_STOPPED;
    60c6:	687a      	ldr	r2, [r7, #4]
    60c8:	f243 1360 	movw	r3, #12640	; 0x3160
    60cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60d0:	f04f 0100 	mov.w	r1, #0
    60d4:	5499      	strb	r1, [r3, r2]
        g_pdma_isr_table[i] = 0;
    60d6:	687a      	ldr	r2, [r7, #4]
    60d8:	f243 1368 	movw	r3, #12648	; 0x3168
    60dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    60e0:	f04f 0100 	mov.w	r1, #0
    60e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
    
    /* Initialize channels state information. */
    for ( i = 0; i < NB_OF_PDMA_CHANNELS; ++i )
    60e8:	687b      	ldr	r3, [r7, #4]
    60ea:	f103 0301 	add.w	r3, r3, #1
    60ee:	607b      	str	r3, [r7, #4]
    60f0:	687b      	ldr	r3, [r7, #4]
    60f2:	2b07      	cmp	r3, #7
    60f4:	ddd7      	ble.n	60a6 <PDMA_init+0x5e>
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
        g_pdma_started_a[i] = CHANNEL_STOPPED;
        g_pdma_started_b[i] = CHANNEL_STOPPED;
        g_pdma_isr_table[i] = 0;
    }
}
    60f6:	f107 0708 	add.w	r7, r7, #8
    60fa:	46bd      	mov	sp, r7
    60fc:	bd80      	pop	{r7, pc}
    60fe:	bf00      	nop

00006100 <PDMA_configure>:
    pdma_channel_id_t channel_id,
    pdma_src_dest_t src_dest,
    uint32_t channel_cfg,
    uint8_t write_adjust
)
{
    6100:	b480      	push	{r7}
    6102:	b085      	sub	sp, #20
    6104:	af00      	add	r7, sp, #0
    6106:	60ba      	str	r2, [r7, #8]
    6108:	4602      	mov	r2, r0
    610a:	73fa      	strb	r2, [r7, #15]
    610c:	460a      	mov	r2, r1
    610e:	73ba      	strb	r2, [r7, #14]
    6110:	71fb      	strb	r3, [r7, #7]
    /* Reset the channel. */
    PDMA->CHANNEL[channel_id].CRTL |= CHANNEL_RESET_MASK;
    6112:	f244 0300 	movw	r3, #16384	; 0x4000
    6116:	f2c4 0300 	movt	r3, #16384	; 0x4000
    611a:	7bf9      	ldrb	r1, [r7, #15]
    611c:	f244 0200 	movw	r2, #16384	; 0x4000
    6120:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6124:	7bf8      	ldrb	r0, [r7, #15]
    6126:	f100 0001 	add.w	r0, r0, #1
    612a:	ea4f 1040 	mov.w	r0, r0, lsl #5
    612e:	4402      	add	r2, r0
    6130:	6812      	ldr	r2, [r2, #0]
    6132:	f042 0220 	orr.w	r2, r2, #32
    6136:	f101 0101 	add.w	r1, r1, #1
    613a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    613e:	440b      	add	r3, r1
    6140:	601a      	str	r2, [r3, #0]
    PDMA->CHANNEL[channel_id].CRTL &= ~CHANNEL_RESET_MASK;
    6142:	f244 0300 	movw	r3, #16384	; 0x4000
    6146:	f2c4 0300 	movt	r3, #16384	; 0x4000
    614a:	7bf9      	ldrb	r1, [r7, #15]
    614c:	f244 0200 	movw	r2, #16384	; 0x4000
    6150:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6154:	7bf8      	ldrb	r0, [r7, #15]
    6156:	f100 0001 	add.w	r0, r0, #1
    615a:	ea4f 1040 	mov.w	r0, r0, lsl #5
    615e:	4402      	add	r2, r0
    6160:	6812      	ldr	r2, [r2, #0]
    6162:	f022 0220 	bic.w	r2, r2, #32
    6166:	f101 0101 	add.w	r1, r1, #1
    616a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    616e:	440b      	add	r3, r1
    6170:	601a      	str	r2, [r3, #0]

    /* Configure PDMA channel's data source and destination. */
    if ( src_dest != PDMA_MEM_TO_MEM )
    6172:	7bbb      	ldrb	r3, [r7, #14]
    6174:	2b0e      	cmp	r3, #14
    6176:	d01f      	beq.n	61b8 <PDMA_configure+0xb8>
    {
        PDMA->CHANNEL[channel_id].CRTL |= src_dest_to_ctrl_reg_lut[src_dest];
    6178:	f244 0300 	movw	r3, #16384	; 0x4000
    617c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6180:	7bf9      	ldrb	r1, [r7, #15]
    6182:	f244 0200 	movw	r2, #16384	; 0x4000
    6186:	f2c4 0200 	movt	r2, #16384	; 0x4000
    618a:	7bf8      	ldrb	r0, [r7, #15]
    618c:	f100 0001 	add.w	r0, r0, #1
    6190:	ea4f 1040 	mov.w	r0, r0, lsl #5
    6194:	4402      	add	r2, r0
    6196:	6810      	ldr	r0, [r2, #0]
    6198:	f897 c00e 	ldrb.w	ip, [r7, #14]
    619c:	f648 62bc 	movw	r2, #36540	; 0x8ebc
    61a0:	f2c0 0200 	movt	r2, #0
    61a4:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
    61a8:	ea40 0202 	orr.w	r2, r0, r2
    61ac:	f101 0101 	add.w	r1, r1, #1
    61b0:	ea4f 1141 	mov.w	r1, r1, lsl #5
    61b4:	440b      	add	r3, r1
    61b6:	601a      	str	r2, [r3, #0]
    }
    
    /* Configure PDMA channel trnasfer size, priority, source and destination address increment. */
    PDMA->CHANNEL[channel_id].CRTL |= channel_cfg;
    61b8:	f244 0300 	movw	r3, #16384	; 0x4000
    61bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    61c0:	7bf9      	ldrb	r1, [r7, #15]
    61c2:	f244 0200 	movw	r2, #16384	; 0x4000
    61c6:	f2c4 0200 	movt	r2, #16384	; 0x4000
    61ca:	7bf8      	ldrb	r0, [r7, #15]
    61cc:	f100 0001 	add.w	r0, r0, #1
    61d0:	ea4f 1040 	mov.w	r0, r0, lsl #5
    61d4:	4402      	add	r2, r0
    61d6:	6810      	ldr	r0, [r2, #0]
    61d8:	68ba      	ldr	r2, [r7, #8]
    61da:	ea40 0202 	orr.w	r2, r0, r2
    61de:	f101 0101 	add.w	r1, r1, #1
    61e2:	ea4f 1141 	mov.w	r1, r1, lsl #5
    61e6:	440b      	add	r3, r1
    61e8:	601a      	str	r2, [r3, #0]

    /* Posted write adjust. */
    PDMA->CHANNEL[channel_id].CRTL |= ((uint32_t)write_adjust << CHANNEL_N_POSTED_WRITE_ADJUST_SHIFT);
    61ea:	f244 0300 	movw	r3, #16384	; 0x4000
    61ee:	f2c4 0300 	movt	r3, #16384	; 0x4000
    61f2:	7bf9      	ldrb	r1, [r7, #15]
    61f4:	f244 0200 	movw	r2, #16384	; 0x4000
    61f8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    61fc:	7bf8      	ldrb	r0, [r7, #15]
    61fe:	f100 0001 	add.w	r0, r0, #1
    6202:	ea4f 1040 	mov.w	r0, r0, lsl #5
    6206:	4402      	add	r2, r0
    6208:	6810      	ldr	r0, [r2, #0]
    620a:	79fa      	ldrb	r2, [r7, #7]
    620c:	ea4f 3282 	mov.w	r2, r2, lsl #14
    6210:	ea40 0202 	orr.w	r2, r0, r2
    6214:	f101 0101 	add.w	r1, r1, #1
    6218:	ea4f 1141 	mov.w	r1, r1, lsl #5
    621c:	440b      	add	r3, r1
    621e:	601a      	str	r2, [r3, #0]
}
    6220:	f107 0714 	add.w	r7, r7, #20
    6224:	46bd      	mov	sp, r7
    6226:	bc80      	pop	{r7}
    6228:	4770      	bx	lr
    622a:	bf00      	nop

0000622c <PDMA_start>:
    pdma_channel_id_t channel_id,
    uint32_t src_addr,
    uint32_t dest_addr,
    uint16_t transfer_count
)
{
    622c:	b480      	push	{r7}
    622e:	b085      	sub	sp, #20
    6230:	af00      	add	r7, sp, #0
    6232:	60b9      	str	r1, [r7, #8]
    6234:	607a      	str	r2, [r7, #4]
    6236:	4602      	mov	r2, r0
    6238:	73fa      	strb	r2, [r7, #15]
    623a:	807b      	strh	r3, [r7, #2]
    /* Pause transfer. */
    PDMA->CHANNEL[channel_id].CRTL |= PAUSE_MASK;
    623c:	f244 0300 	movw	r3, #16384	; 0x4000
    6240:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6244:	7bf9      	ldrb	r1, [r7, #15]
    6246:	f244 0200 	movw	r2, #16384	; 0x4000
    624a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    624e:	7bf8      	ldrb	r0, [r7, #15]
    6250:	f100 0001 	add.w	r0, r0, #1
    6254:	ea4f 1040 	mov.w	r0, r0, lsl #5
    6258:	4402      	add	r2, r0
    625a:	6812      	ldr	r2, [r2, #0]
    625c:	f042 0210 	orr.w	r2, r2, #16
    6260:	f101 0101 	add.w	r1, r1, #1
    6264:	ea4f 1141 	mov.w	r1, r1, lsl #5
    6268:	440b      	add	r3, r1
    626a:	601a      	str	r2, [r3, #0]
    
    /* Clear complete transfers. */
    if ( PDMA->CHANNEL[channel_id].STATUS & PORT_A_COMPLETE_MASK )
    626c:	f244 0300 	movw	r3, #16384	; 0x4000
    6270:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6274:	7bfa      	ldrb	r2, [r7, #15]
    6276:	f102 0201 	add.w	r2, r2, #1
    627a:	ea4f 1242 	mov.w	r2, r2, lsl #5
    627e:	4413      	add	r3, r2
    6280:	f103 0304 	add.w	r3, r3, #4
    6284:	681b      	ldr	r3, [r3, #0]
    6286:	f003 0301 	and.w	r3, r3, #1
    628a:	b2db      	uxtb	r3, r3
    628c:	2b00      	cmp	r3, #0
    628e:	d01f      	beq.n	62d0 <PDMA_start+0xa4>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
    6290:	f244 0300 	movw	r3, #16384	; 0x4000
    6294:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6298:	7bf9      	ldrb	r1, [r7, #15]
    629a:	f244 0200 	movw	r2, #16384	; 0x4000
    629e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    62a2:	7bf8      	ldrb	r0, [r7, #15]
    62a4:	f100 0001 	add.w	r0, r0, #1
    62a8:	ea4f 1040 	mov.w	r0, r0, lsl #5
    62ac:	4402      	add	r2, r0
    62ae:	6812      	ldr	r2, [r2, #0]
    62b0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    62b4:	f101 0101 	add.w	r1, r1, #1
    62b8:	ea4f 1141 	mov.w	r1, r1, lsl #5
    62bc:	440b      	add	r3, r1
    62be:	601a      	str	r2, [r3, #0]
        g_pdma_started_a[channel_id] = CHANNEL_STOPPED;
    62c0:	7bfa      	ldrb	r2, [r7, #15]
    62c2:	f243 1358 	movw	r3, #12632	; 0x3158
    62c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    62ca:	f04f 0100 	mov.w	r1, #0
    62ce:	5499      	strb	r1, [r3, r2]
    }
    if ( PDMA->CHANNEL[channel_id].STATUS & PORT_B_COMPLETE_MASK )
    62d0:	f244 0300 	movw	r3, #16384	; 0x4000
    62d4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    62d8:	7bfa      	ldrb	r2, [r7, #15]
    62da:	f102 0201 	add.w	r2, r2, #1
    62de:	ea4f 1242 	mov.w	r2, r2, lsl #5
    62e2:	4413      	add	r3, r2
    62e4:	f103 0304 	add.w	r3, r3, #4
    62e8:	681b      	ldr	r3, [r3, #0]
    62ea:	f003 0302 	and.w	r3, r3, #2
    62ee:	2b00      	cmp	r3, #0
    62f0:	d01f      	beq.n	6332 <PDMA_start+0x106>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
    62f2:	f244 0300 	movw	r3, #16384	; 0x4000
    62f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    62fa:	7bf9      	ldrb	r1, [r7, #15]
    62fc:	f244 0200 	movw	r2, #16384	; 0x4000
    6300:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6304:	7bf8      	ldrb	r0, [r7, #15]
    6306:	f100 0001 	add.w	r0, r0, #1
    630a:	ea4f 1040 	mov.w	r0, r0, lsl #5
    630e:	4402      	add	r2, r0
    6310:	6812      	ldr	r2, [r2, #0]
    6312:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    6316:	f101 0101 	add.w	r1, r1, #1
    631a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    631e:	440b      	add	r3, r1
    6320:	601a      	str	r2, [r3, #0]
        g_pdma_started_b[channel_id] = CHANNEL_STOPPED;
    6322:	7bfa      	ldrb	r2, [r7, #15]
    6324:	f243 1360 	movw	r3, #12640	; 0x3160
    6328:	f2c2 0300 	movt	r3, #8192	; 0x2000
    632c:	f04f 0100 	mov.w	r1, #0
    6330:	5499      	strb	r1, [r3, r2]
    }
    
    /* Load source, destination and transfer count. */
    if ( PDMA->CHANNEL[channel_id].STATUS & BUFFER_B_SELECT_MASK )
    6332:	f244 0300 	movw	r3, #16384	; 0x4000
    6336:	f2c4 0300 	movt	r3, #16384	; 0x4000
    633a:	7bfa      	ldrb	r2, [r7, #15]
    633c:	f102 0201 	add.w	r2, r2, #1
    6340:	ea4f 1242 	mov.w	r2, r2, lsl #5
    6344:	4413      	add	r3, r2
    6346:	f103 0304 	add.w	r3, r3, #4
    634a:	681b      	ldr	r3, [r3, #0]
    634c:	f003 0304 	and.w	r3, r3, #4
    6350:	2b00      	cmp	r3, #0
    6352:	d034      	beq.n	63be <PDMA_start+0x192>
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_A;
    6354:	7bfa      	ldrb	r2, [r7, #15]
    6356:	f243 1350 	movw	r3, #12624	; 0x3150
    635a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    635e:	f04f 0100 	mov.w	r1, #0
    6362:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[channel_id] = CHANNEL_STARTED;
    6364:	7bfa      	ldrb	r2, [r7, #15]
    6366:	f243 1360 	movw	r3, #12640	; 0x3160
    636a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    636e:	f04f 0101 	mov.w	r1, #1
    6372:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_B_SRC_ADDR = src_addr;
    6374:	f244 0300 	movw	r3, #16384	; 0x4000
    6378:	f2c4 0300 	movt	r3, #16384	; 0x4000
    637c:	7bfa      	ldrb	r2, [r7, #15]
    637e:	ea4f 1242 	mov.w	r2, r2, lsl #5
    6382:	4413      	add	r3, r2
    6384:	f103 0334 	add.w	r3, r3, #52	; 0x34
    6388:	68ba      	ldr	r2, [r7, #8]
    638a:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_DEST_ADDR = dest_addr;
    638c:	f244 0300 	movw	r3, #16384	; 0x4000
    6390:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6394:	7bfa      	ldrb	r2, [r7, #15]
    6396:	ea4f 1242 	mov.w	r2, r2, lsl #5
    639a:	4413      	add	r3, r2
    639c:	f103 0338 	add.w	r3, r3, #56	; 0x38
    63a0:	687a      	ldr	r2, [r7, #4]
    63a2:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_TRANSFER_COUNT = transfer_count;
    63a4:	f244 0300 	movw	r3, #16384	; 0x4000
    63a8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    63ac:	7bf9      	ldrb	r1, [r7, #15]
    63ae:	887a      	ldrh	r2, [r7, #2]
    63b0:	ea4f 1141 	mov.w	r1, r1, lsl #5
    63b4:	440b      	add	r3, r1
    63b6:	f103 033c 	add.w	r3, r3, #60	; 0x3c
    63ba:	601a      	str	r2, [r3, #0]
    63bc:	e033      	b.n	6426 <PDMA_start+0x1fa>
    }
    else
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_B;
    63be:	7bfa      	ldrb	r2, [r7, #15]
    63c0:	f243 1350 	movw	r3, #12624	; 0x3150
    63c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63c8:	f04f 0101 	mov.w	r1, #1
    63cc:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[channel_id] = CHANNEL_STARTED;
    63ce:	7bfa      	ldrb	r2, [r7, #15]
    63d0:	f243 1358 	movw	r3, #12632	; 0x3158
    63d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    63d8:	f04f 0101 	mov.w	r1, #1
    63dc:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_A_SRC_ADDR = src_addr;
    63de:	f244 0300 	movw	r3, #16384	; 0x4000
    63e2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    63e6:	7bfa      	ldrb	r2, [r7, #15]
    63e8:	ea4f 1242 	mov.w	r2, r2, lsl #5
    63ec:	4413      	add	r3, r2
    63ee:	f103 0328 	add.w	r3, r3, #40	; 0x28
    63f2:	68ba      	ldr	r2, [r7, #8]
    63f4:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_DEST_ADDR = dest_addr;
    63f6:	f244 0300 	movw	r3, #16384	; 0x4000
    63fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
    63fe:	7bfa      	ldrb	r2, [r7, #15]
    6400:	ea4f 1242 	mov.w	r2, r2, lsl #5
    6404:	4413      	add	r3, r2
    6406:	f103 032c 	add.w	r3, r3, #44	; 0x2c
    640a:	687a      	ldr	r2, [r7, #4]
    640c:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_TRANSFER_COUNT = transfer_count;
    640e:	f244 0300 	movw	r3, #16384	; 0x4000
    6412:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6416:	7bf9      	ldrb	r1, [r7, #15]
    6418:	887a      	ldrh	r2, [r7, #2]
    641a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    641e:	440b      	add	r3, r1
    6420:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6424:	601a      	str	r2, [r3, #0]
    }
    
    /* Start transfer */
    PDMA->CHANNEL[channel_id].CRTL &= ~PAUSE_MASK;
    6426:	f244 0300 	movw	r3, #16384	; 0x4000
    642a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    642e:	7bf9      	ldrb	r1, [r7, #15]
    6430:	f244 0200 	movw	r2, #16384	; 0x4000
    6434:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6438:	7bf8      	ldrb	r0, [r7, #15]
    643a:	f100 0001 	add.w	r0, r0, #1
    643e:	ea4f 1040 	mov.w	r0, r0, lsl #5
    6442:	4402      	add	r2, r0
    6444:	6812      	ldr	r2, [r2, #0]
    6446:	f022 0210 	bic.w	r2, r2, #16
    644a:	f101 0101 	add.w	r1, r1, #1
    644e:	ea4f 1141 	mov.w	r1, r1, lsl #5
    6452:	440b      	add	r3, r1
    6454:	601a      	str	r2, [r3, #0]
}
    6456:	f107 0714 	add.w	r7, r7, #20
    645a:	46bd      	mov	sp, r7
    645c:	bc80      	pop	{r7}
    645e:	4770      	bx	lr

00006460 <PDMA_load_next_buffer>:
    pdma_channel_id_t channel_id,
    uint32_t src_addr,
    uint32_t dest_addr,
    uint16_t transfer_count
)
{
    6460:	b480      	push	{r7}
    6462:	b089      	sub	sp, #36	; 0x24
    6464:	af00      	add	r7, sp, #0
    6466:	60b9      	str	r1, [r7, #8]
    6468:	607a      	str	r2, [r7, #4]
    646a:	4602      	mov	r2, r0
    646c:	73fa      	strb	r2, [r7, #15]
    646e:	807b      	strh	r3, [r7, #2]
    if ( NEXT_CHANNEL_A == g_pdma_next_channel[channel_id] )
    6470:	7bfa      	ldrb	r2, [r7, #15]
    6472:	f243 1350 	movw	r3, #12624	; 0x3150
    6476:	f2c2 0300 	movt	r3, #8192	; 0x2000
    647a:	5c9b      	ldrb	r3, [r3, r2]
    647c:	2b00      	cmp	r3, #0
    647e:	d168      	bne.n	6552 <PDMA_load_next_buffer+0xf2>
    {
        /* Wait for channel A current transfer completion. */
        if ( CHANNEL_STARTED == g_pdma_started_a[channel_id] )
    6480:	7bfa      	ldrb	r2, [r7, #15]
    6482:	f243 1358 	movw	r3, #12632	; 0x3158
    6486:	f2c2 0300 	movt	r3, #8192	; 0x2000
    648a:	5c9b      	ldrb	r3, [r3, r2]
    648c:	2b01      	cmp	r3, #1
    648e:	d12b      	bne.n	64e8 <PDMA_load_next_buffer+0x88>
        {
            uint32_t completed;
            uint32_t channel_mask;
            channel_mask = (uint32_t)1 << ((uint32_t)channel_id * 2U);
    6490:	7bfb      	ldrb	r3, [r7, #15]
    6492:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6496:	f04f 0201 	mov.w	r2, #1
    649a:	fa02 f303 	lsl.w	r3, r2, r3
    649e:	617b      	str	r3, [r7, #20]
            do {
                completed = PDMA->BUFFER_STATUS & channel_mask;
    64a0:	f244 0300 	movw	r3, #16384	; 0x4000
    64a4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    64a8:	685a      	ldr	r2, [r3, #4]
    64aa:	697b      	ldr	r3, [r7, #20]
    64ac:	ea02 0303 	and.w	r3, r2, r3
    64b0:	613b      	str	r3, [r7, #16]
            } while( !completed );
    64b2:	693b      	ldr	r3, [r7, #16]
    64b4:	2b00      	cmp	r3, #0
    64b6:	d0f3      	beq.n	64a0 <PDMA_load_next_buffer+0x40>
            PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
    64b8:	f244 0300 	movw	r3, #16384	; 0x4000
    64bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    64c0:	7bf9      	ldrb	r1, [r7, #15]
    64c2:	f244 0200 	movw	r2, #16384	; 0x4000
    64c6:	f2c4 0200 	movt	r2, #16384	; 0x4000
    64ca:	7bf8      	ldrb	r0, [r7, #15]
    64cc:	f100 0001 	add.w	r0, r0, #1
    64d0:	ea4f 1040 	mov.w	r0, r0, lsl #5
    64d4:	4402      	add	r2, r0
    64d6:	6812      	ldr	r2, [r2, #0]
    64d8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    64dc:	f101 0101 	add.w	r1, r1, #1
    64e0:	ea4f 1141 	mov.w	r1, r1, lsl #5
    64e4:	440b      	add	r3, r1
    64e6:	601a      	str	r2, [r3, #0]
        }
        /* Load source, destination and transfer count. */
        PDMA->CHANNEL[channel_id].BUFFER_A_SRC_ADDR = src_addr;
    64e8:	f244 0300 	movw	r3, #16384	; 0x4000
    64ec:	f2c4 0300 	movt	r3, #16384	; 0x4000
    64f0:	7bfa      	ldrb	r2, [r7, #15]
    64f2:	ea4f 1242 	mov.w	r2, r2, lsl #5
    64f6:	4413      	add	r3, r2
    64f8:	f103 0328 	add.w	r3, r3, #40	; 0x28
    64fc:	68ba      	ldr	r2, [r7, #8]
    64fe:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_DEST_ADDR = dest_addr;
    6500:	f244 0300 	movw	r3, #16384	; 0x4000
    6504:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6508:	7bfa      	ldrb	r2, [r7, #15]
    650a:	ea4f 1242 	mov.w	r2, r2, lsl #5
    650e:	4413      	add	r3, r2
    6510:	f103 032c 	add.w	r3, r3, #44	; 0x2c
    6514:	687a      	ldr	r2, [r7, #4]
    6516:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_TRANSFER_COUNT = transfer_count;
    6518:	f244 0300 	movw	r3, #16384	; 0x4000
    651c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6520:	7bf9      	ldrb	r1, [r7, #15]
    6522:	887a      	ldrh	r2, [r7, #2]
    6524:	ea4f 1141 	mov.w	r1, r1, lsl #5
    6528:	440b      	add	r3, r1
    652a:	f103 0330 	add.w	r3, r3, #48	; 0x30
    652e:	601a      	str	r2, [r3, #0]
        
        /* Update channel state information. */
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_B;
    6530:	7bfa      	ldrb	r2, [r7, #15]
    6532:	f243 1350 	movw	r3, #12624	; 0x3150
    6536:	f2c2 0300 	movt	r3, #8192	; 0x2000
    653a:	f04f 0101 	mov.w	r1, #1
    653e:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[channel_id] = CHANNEL_STARTED;
    6540:	7bfa      	ldrb	r2, [r7, #15]
    6542:	f243 1358 	movw	r3, #12632	; 0x3158
    6546:	f2c2 0300 	movt	r3, #8192	; 0x2000
    654a:	f04f 0101 	mov.w	r1, #1
    654e:	5499      	strb	r1, [r3, r2]
    6550:	e069      	b.n	6626 <PDMA_load_next_buffer+0x1c6>
    }
    else
    {
        /* Wait for channel B current transfer completion. */
        if ( CHANNEL_STARTED == g_pdma_started_b[channel_id] )
    6552:	7bfa      	ldrb	r2, [r7, #15]
    6554:	f243 1360 	movw	r3, #12640	; 0x3160
    6558:	f2c2 0300 	movt	r3, #8192	; 0x2000
    655c:	5c9b      	ldrb	r3, [r3, r2]
    655e:	2b01      	cmp	r3, #1
    6560:	d12d      	bne.n	65be <PDMA_load_next_buffer+0x15e>
        {
            uint32_t completed;
            uint32_t channel_mask;
            channel_mask = (uint32_t)1 << (((uint32_t)channel_id * 2U) + 1U);
    6562:	7bfb      	ldrb	r3, [r7, #15]
    6564:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6568:	f103 0301 	add.w	r3, r3, #1
    656c:	f04f 0201 	mov.w	r2, #1
    6570:	fa02 f303 	lsl.w	r3, r2, r3
    6574:	61fb      	str	r3, [r7, #28]
            do {
                completed = PDMA->BUFFER_STATUS & channel_mask;
    6576:	f244 0300 	movw	r3, #16384	; 0x4000
    657a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    657e:	685a      	ldr	r2, [r3, #4]
    6580:	69fb      	ldr	r3, [r7, #28]
    6582:	ea02 0303 	and.w	r3, r2, r3
    6586:	61bb      	str	r3, [r7, #24]
            } while( !completed );
    6588:	69bb      	ldr	r3, [r7, #24]
    658a:	2b00      	cmp	r3, #0
    658c:	d0f3      	beq.n	6576 <PDMA_load_next_buffer+0x116>
            PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
    658e:	f244 0300 	movw	r3, #16384	; 0x4000
    6592:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6596:	7bf9      	ldrb	r1, [r7, #15]
    6598:	f244 0200 	movw	r2, #16384	; 0x4000
    659c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    65a0:	7bf8      	ldrb	r0, [r7, #15]
    65a2:	f100 0001 	add.w	r0, r0, #1
    65a6:	ea4f 1040 	mov.w	r0, r0, lsl #5
    65aa:	4402      	add	r2, r0
    65ac:	6812      	ldr	r2, [r2, #0]
    65ae:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    65b2:	f101 0101 	add.w	r1, r1, #1
    65b6:	ea4f 1141 	mov.w	r1, r1, lsl #5
    65ba:	440b      	add	r3, r1
    65bc:	601a      	str	r2, [r3, #0]
        }            
        /* Load source, destination and transfer count. */
        PDMA->CHANNEL[channel_id].BUFFER_B_SRC_ADDR = src_addr;
    65be:	f244 0300 	movw	r3, #16384	; 0x4000
    65c2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    65c6:	7bfa      	ldrb	r2, [r7, #15]
    65c8:	ea4f 1242 	mov.w	r2, r2, lsl #5
    65cc:	4413      	add	r3, r2
    65ce:	f103 0334 	add.w	r3, r3, #52	; 0x34
    65d2:	68ba      	ldr	r2, [r7, #8]
    65d4:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_DEST_ADDR = dest_addr;
    65d6:	f244 0300 	movw	r3, #16384	; 0x4000
    65da:	f2c4 0300 	movt	r3, #16384	; 0x4000
    65de:	7bfa      	ldrb	r2, [r7, #15]
    65e0:	ea4f 1242 	mov.w	r2, r2, lsl #5
    65e4:	4413      	add	r3, r2
    65e6:	f103 0338 	add.w	r3, r3, #56	; 0x38
    65ea:	687a      	ldr	r2, [r7, #4]
    65ec:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_TRANSFER_COUNT = transfer_count;
    65ee:	f244 0300 	movw	r3, #16384	; 0x4000
    65f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    65f6:	7bf9      	ldrb	r1, [r7, #15]
    65f8:	887a      	ldrh	r2, [r7, #2]
    65fa:	ea4f 1141 	mov.w	r1, r1, lsl #5
    65fe:	440b      	add	r3, r1
    6600:	f103 033c 	add.w	r3, r3, #60	; 0x3c
    6604:	601a      	str	r2, [r3, #0]
        
        /* Update channel state information. */
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_A;
    6606:	7bfa      	ldrb	r2, [r7, #15]
    6608:	f243 1350 	movw	r3, #12624	; 0x3150
    660c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6610:	f04f 0100 	mov.w	r1, #0
    6614:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[channel_id] = CHANNEL_STARTED;
    6616:	7bfa      	ldrb	r2, [r7, #15]
    6618:	f243 1360 	movw	r3, #12640	; 0x3160
    661c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6620:	f04f 0101 	mov.w	r1, #1
    6624:	5499      	strb	r1, [r3, r2]
    }
}
    6626:	f107 0724 	add.w	r7, r7, #36	; 0x24
    662a:	46bd      	mov	sp, r7
    662c:	bc80      	pop	{r7}
    662e:	4770      	bx	lr

00006630 <get_channel_id_from_status>:

static pdma_channel_id_t get_channel_id_from_status
(
    uint16_t status
)
{
    6630:	b480      	push	{r7}
    6632:	b085      	sub	sp, #20
    6634:	af00      	add	r7, sp, #0
    6636:	4603      	mov	r3, r0
    6638:	80fb      	strh	r3, [r7, #6]
    pdma_channel_id_t channel_id = PDMA_CHANNEL_0;
    663a:	f04f 0300 	mov.w	r3, #0
    663e:	73fb      	strb	r3, [r7, #15]
    
    if ( status & CHANNEL_0_STATUS_BITS_MASK )
    6640:	88fb      	ldrh	r3, [r7, #6]
    6642:	f003 0303 	and.w	r3, r3, #3
    6646:	2b00      	cmp	r3, #0
    6648:	d003      	beq.n	6652 <get_channel_id_from_status+0x22>
    {
        channel_id = PDMA_CHANNEL_0;
    664a:	f04f 0300 	mov.w	r3, #0
    664e:	73fb      	strb	r3, [r7, #15]
    6650:	e03f      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_1_STATUS_BITS_MASK )
    6652:	88fb      	ldrh	r3, [r7, #6]
    6654:	f003 030c 	and.w	r3, r3, #12
    6658:	2b00      	cmp	r3, #0
    665a:	d003      	beq.n	6664 <get_channel_id_from_status+0x34>
    {
        channel_id = PDMA_CHANNEL_1;
    665c:	f04f 0301 	mov.w	r3, #1
    6660:	73fb      	strb	r3, [r7, #15]
    6662:	e036      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_2_STATUS_BITS_MASK )
    6664:	88fb      	ldrh	r3, [r7, #6]
    6666:	f003 0330 	and.w	r3, r3, #48	; 0x30
    666a:	2b00      	cmp	r3, #0
    666c:	d003      	beq.n	6676 <get_channel_id_from_status+0x46>
    {
        channel_id = PDMA_CHANNEL_2;
    666e:	f04f 0302 	mov.w	r3, #2
    6672:	73fb      	strb	r3, [r7, #15]
    6674:	e02d      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_3_STATUS_BITS_MASK )
    6676:	88fb      	ldrh	r3, [r7, #6]
    6678:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    667c:	2b00      	cmp	r3, #0
    667e:	d003      	beq.n	6688 <get_channel_id_from_status+0x58>
    {
        channel_id = PDMA_CHANNEL_3;
    6680:	f04f 0303 	mov.w	r3, #3
    6684:	73fb      	strb	r3, [r7, #15]
    6686:	e024      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_4_STATUS_BITS_MASK )
    6688:	88fb      	ldrh	r3, [r7, #6]
    668a:	f403 7340 	and.w	r3, r3, #768	; 0x300
    668e:	2b00      	cmp	r3, #0
    6690:	d003      	beq.n	669a <get_channel_id_from_status+0x6a>
    {
        channel_id = PDMA_CHANNEL_4;
    6692:	f04f 0304 	mov.w	r3, #4
    6696:	73fb      	strb	r3, [r7, #15]
    6698:	e01b      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_5_STATUS_BITS_MASK )
    669a:	88fb      	ldrh	r3, [r7, #6]
    669c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
    66a0:	2b00      	cmp	r3, #0
    66a2:	d003      	beq.n	66ac <get_channel_id_from_status+0x7c>
    {
        channel_id = PDMA_CHANNEL_5;
    66a4:	f04f 0305 	mov.w	r3, #5
    66a8:	73fb      	strb	r3, [r7, #15]
    66aa:	e012      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_6_STATUS_BITS_MASK )
    66ac:	88fb      	ldrh	r3, [r7, #6]
    66ae:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
    66b2:	2b00      	cmp	r3, #0
    66b4:	d003      	beq.n	66be <get_channel_id_from_status+0x8e>
    {
        channel_id = PDMA_CHANNEL_6;
    66b6:	f04f 0306 	mov.w	r3, #6
    66ba:	73fb      	strb	r3, [r7, #15]
    66bc:	e009      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else if ( status & CHANNEL_7_STATUS_BITS_MASK )
    66be:	88fb      	ldrh	r3, [r7, #6]
    66c0:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    66c4:	2b00      	cmp	r3, #0
    66c6:	d003      	beq.n	66d0 <get_channel_id_from_status+0xa0>
    {
        channel_id = PDMA_CHANNEL_7;
    66c8:	f04f 0307 	mov.w	r3, #7
    66cc:	73fb      	strb	r3, [r7, #15]
    66ce:	e000      	b.n	66d2 <get_channel_id_from_status+0xa2>
    }
    else
    {
        ASSERT(0);
    66d0:	be00      	bkpt	0x0000
    }
    return channel_id;
    66d2:	7bfb      	ldrb	r3, [r7, #15]
}
    66d4:	4618      	mov	r0, r3
    66d6:	f107 0714 	add.w	r7, r7, #20
    66da:	46bd      	mov	sp, r7
    66dc:	bc80      	pop	{r7}
    66de:	4770      	bx	lr

000066e0 <DMA_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void DMA_IRQHandler( void )
#else
void DMA_IRQHandler( void )
#endif
{
    66e0:	4668      	mov	r0, sp
    66e2:	f020 0107 	bic.w	r1, r0, #7
    66e6:	468d      	mov	sp, r1
    66e8:	b581      	push	{r0, r7, lr}
    66ea:	b083      	sub	sp, #12
    66ec:	af00      	add	r7, sp, #0
    uint16_t status;
    pdma_channel_id_t channel_id;
    
    status = (uint16_t)PDMA->BUFFER_STATUS;
    66ee:	f244 0300 	movw	r3, #16384	; 0x4000
    66f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    66f6:	685b      	ldr	r3, [r3, #4]
    66f8:	80bb      	strh	r3, [r7, #4]
    
    do {
        channel_id = get_channel_id_from_status( status );
    66fa:	88bb      	ldrh	r3, [r7, #4]
    66fc:	4618      	mov	r0, r3
    66fe:	f7ff ff97 	bl	6630 <get_channel_id_from_status>
    6702:	4603      	mov	r3, r0
    6704:	71fb      	strb	r3, [r7, #7]
        status &= (uint16_t)~g_pdma_status_mask[channel_id];
    6706:	79fa      	ldrb	r2, [r7, #7]
    6708:	f648 63f4 	movw	r3, #36596	; 0x8ef4
    670c:	f2c0 0300 	movt	r3, #0
    6710:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    6714:	ea6f 0303 	mvn.w	r3, r3
    6718:	b29a      	uxth	r2, r3
    671a:	88bb      	ldrh	r3, [r7, #4]
    671c:	ea02 0303 	and.w	r3, r2, r3
    6720:	80bb      	strh	r3, [r7, #4]
        if ( 0 != g_pdma_isr_table[channel_id])
    6722:	79fa      	ldrb	r2, [r7, #7]
    6724:	f243 1368 	movw	r3, #12648	; 0x3168
    6728:	f2c2 0300 	movt	r3, #8192	; 0x2000
    672c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6730:	2b00      	cmp	r3, #0
    6732:	d007      	beq.n	6744 <DMA_IRQHandler+0x64>
        {
            g_pdma_isr_table[channel_id]();
    6734:	79fa      	ldrb	r2, [r7, #7]
    6736:	f243 1368 	movw	r3, #12648	; 0x3168
    673a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    673e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6742:	4798      	blx	r3
        }
    } while ( 0U != status );
    6744:	88bb      	ldrh	r3, [r7, #4]
    6746:	2b00      	cmp	r3, #0
    6748:	d1d7      	bne.n	66fa <DMA_IRQHandler+0x1a>
      
    NVIC_ClearPendingIRQ( DMA_IRQn );
    674a:	f04f 0009 	mov.w	r0, #9
    674e:	f7ff fc5d 	bl	600c <NVIC_ClearPendingIRQ>
}
    6752:	f107 070c 	add.w	r7, r7, #12
    6756:	46bd      	mov	sp, r7
    6758:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
    675c:	4685      	mov	sp, r0
    675e:	4770      	bx	lr

00006760 <PDMA_set_irq_handler>:
void PDMA_set_irq_handler
(
    pdma_channel_id_t channel_id,
    pdma_channel_isr_t handler
)
{
    6760:	b580      	push	{r7, lr}
    6762:	b082      	sub	sp, #8
    6764:	af00      	add	r7, sp, #0
    6766:	4603      	mov	r3, r0
    6768:	6039      	str	r1, [r7, #0]
    676a:	71fb      	strb	r3, [r7, #7]
    /* Save address of handler function in PDMA driver ISR lookup table. */
    g_pdma_isr_table[channel_id] = handler;
    676c:	79fa      	ldrb	r2, [r7, #7]
    676e:	f243 1368 	movw	r3, #12648	; 0x3168
    6772:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6776:	6839      	ldr	r1, [r7, #0]
    6778:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    
    /* Enable PDMA channel's interrupt. */
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
    677c:	f244 0300 	movw	r3, #16384	; 0x4000
    6780:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6784:	79f9      	ldrb	r1, [r7, #7]
    6786:	f244 0200 	movw	r2, #16384	; 0x4000
    678a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    678e:	79f8      	ldrb	r0, [r7, #7]
    6790:	f100 0001 	add.w	r0, r0, #1
    6794:	ea4f 1040 	mov.w	r0, r0, lsl #5
    6798:	4402      	add	r2, r0
    679a:	6812      	ldr	r2, [r2, #0]
    679c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    67a0:	f101 0101 	add.w	r1, r1, #1
    67a4:	ea4f 1141 	mov.w	r1, r1, lsl #5
    67a8:	440b      	add	r3, r1
    67aa:	601a      	str	r2, [r3, #0]
    
    /* Enable PDMA interrupt in Cortex-M3 NVIC. */
    NVIC_EnableIRQ( DMA_IRQn );
    67ac:	f04f 0009 	mov.w	r0, #9
    67b0:	f7ff fc10 	bl	5fd4 <NVIC_EnableIRQ>
}
    67b4:	f107 0708 	add.w	r7, r7, #8
    67b8:	46bd      	mov	sp, r7
    67ba:	bd80      	pop	{r7, pc}

000067bc <PDMA_enable_irq>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_enable_irq( pdma_channel_id_t channel_id )
{
    67bc:	b580      	push	{r7, lr}
    67be:	b082      	sub	sp, #8
    67c0:	af00      	add	r7, sp, #0
    67c2:	4603      	mov	r3, r0
    67c4:	71fb      	strb	r3, [r7, #7]
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
    67c6:	f244 0300 	movw	r3, #16384	; 0x4000
    67ca:	f2c4 0300 	movt	r3, #16384	; 0x4000
    67ce:	79f9      	ldrb	r1, [r7, #7]
    67d0:	f244 0200 	movw	r2, #16384	; 0x4000
    67d4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    67d8:	79f8      	ldrb	r0, [r7, #7]
    67da:	f100 0001 	add.w	r0, r0, #1
    67de:	ea4f 1040 	mov.w	r0, r0, lsl #5
    67e2:	4402      	add	r2, r0
    67e4:	6812      	ldr	r2, [r2, #0]
    67e6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    67ea:	f101 0101 	add.w	r1, r1, #1
    67ee:	ea4f 1141 	mov.w	r1, r1, lsl #5
    67f2:	440b      	add	r3, r1
    67f4:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ( DMA_IRQn );
    67f6:	f04f 0009 	mov.w	r0, #9
    67fa:	f7ff fbeb 	bl	5fd4 <NVIC_EnableIRQ>
}
    67fe:	f107 0708 	add.w	r7, r7, #8
    6802:	46bd      	mov	sp, r7
    6804:	bd80      	pop	{r7, pc}
    6806:	bf00      	nop

00006808 <MSS_MAC_init>:
void
MSS_MAC_init
(
	uint8_t phy_address
)
{
    6808:	b580      	push	{r7, lr}
    680a:	b086      	sub	sp, #24
    680c:	af00      	add	r7, sp, #0
    680e:	4603      	mov	r3, r0
    6810:	71fb      	strb	r3, [r7, #7]
    const uint8_t mac_address[6] = { DEFAULT_MAC_ADDRESS };
    6812:	f648 7204 	movw	r2, #36612	; 0x8f04
    6816:	f2c0 0200 	movt	r2, #0
    681a:	f107 030c 	add.w	r3, r7, #12
    681e:	e892 0003 	ldmia.w	r2, {r0, r1}
    6822:	6018      	str	r0, [r3, #0]
    6824:	f103 0304 	add.w	r3, r3, #4
    6828:	8019      	strh	r1, [r3, #0]

    int32_t a;

    /* Try to reset chip */
    MAC_BITBAND->CSR0_SWR = 1u;
    682a:	f240 0300 	movw	r3, #0
    682e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6832:	f04f 0201 	mov.w	r2, #1
    6836:	601a      	str	r2, [r3, #0]
    
    while ( 1u == MAC_BITBAND->CSR0_SWR )
    6838:	f240 0300 	movw	r3, #0
    683c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6840:	681b      	ldr	r3, [r3, #0]
    6842:	2b01      	cmp	r3, #1
    6844:	d0f8      	beq.n	6838 <MSS_MAC_init+0x30>
        ;
    }

    /* Check reset values of some registers to constrol
     * base address validity */
    ASSERT( MAC->CSR0 == 0xFE000000uL );
    6846:	f243 0300 	movw	r3, #12288	; 0x3000
    684a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    684e:	681b      	ldr	r3, [r3, #0]
    6850:	f1b3 4f7e 	cmp.w	r3, #4261412864	; 0xfe000000
    6854:	d000      	beq.n	6858 <MSS_MAC_init+0x50>
    6856:	be00      	bkpt	0x0000
    ASSERT( MAC->CSR5 == 0xF0000000uL );
    6858:	f243 0300 	movw	r3, #12288	; 0x3000
    685c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6860:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6862:	f1b3 4f70 	cmp.w	r3, #4026531840	; 0xf0000000
    6866:	d000      	beq.n	686a <MSS_MAC_init+0x62>
    6868:	be00      	bkpt	0x0000
    ASSERT( MAC->CSR6 == 0x32000040uL );
    686a:	f243 0300 	movw	r3, #12288	; 0x3000
    686e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6872:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    6874:	f240 0340 	movw	r3, #64	; 0x40
    6878:	f2c3 2300 	movt	r3, #12800	; 0x3200
    687c:	429a      	cmp	r2, r3
    687e:	d000      	beq.n	6882 <MSS_MAC_init+0x7a>
    6880:	be00      	bkpt	0x0000

    /* Instance setup */
    MAC_memset_All( &g_mss_mac, 0u );
    6882:	f247 1024 	movw	r0, #28964	; 0x7124
    6886:	f2c2 0000 	movt	r0, #8192	; 0x2000
    688a:	f04f 0100 	mov.w	r1, #0
    688e:	f001 fc75 	bl	817c <MAC_memset_All>

    g_mss_mac.base_address = MAC_BASE;
    6892:	f247 1324 	movw	r3, #28964	; 0x7124
    6896:	f2c2 0300 	movt	r3, #8192	; 0x2000
    689a:	f243 0200 	movw	r2, #12288	; 0x3000
    689e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    68a2:	601a      	str	r2, [r3, #0]
    g_mss_mac.phy_address = phy_address;
    68a4:	f247 1324 	movw	r3, #28964	; 0x7124
    68a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68ac:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    68b0:	79fa      	ldrb	r2, [r7, #7]
    68b2:	701a      	strb	r2, [r3, #0]

    for( a=0; a<RX_RING_SIZE; a++ )
    68b4:	f04f 0300 	mov.w	r3, #0
    68b8:	617b      	str	r3, [r7, #20]
    68ba:	e034      	b.n	6926 <MSS_MAC_init+0x11e>
    {
        /* Give the ownership to the MAC */
        g_mss_mac.rx_descriptors[a].descriptor_0 = RDES0_OWN;
    68bc:	697a      	ldr	r2, [r7, #20]
    68be:	f247 1324 	movw	r3, #28964	; 0x7124
    68c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68c6:	f502 7211 	add.w	r2, r2, #580	; 0x244
    68ca:	ea4f 1202 	mov.w	r2, r2, lsl #4
    68ce:	4413      	add	r3, r2
    68d0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    68d4:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
    68d6:	697a      	ldr	r2, [r7, #20]
    68d8:	f247 1324 	movw	r3, #28964	; 0x7124
    68dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68e0:	f502 7211 	add.w	r2, r2, #580	; 0x244
    68e4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    68e8:	4413      	add	r3, r2
    68ea:	f103 0304 	add.w	r3, r3, #4
    68ee:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    68f2:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].buffer_1 = (uint32_t)g_mss_mac.rx_buffers[a];
    68f4:	6979      	ldr	r1, [r7, #20]
    68f6:	4a85      	ldr	r2, [pc, #532]	; (6b0c <MSS_MAC_init+0x304>)
    68f8:	697b      	ldr	r3, [r7, #20]
    68fa:	f240 50f4 	movw	r0, #1524	; 0x5f4
    68fe:	fb00 f303 	mul.w	r3, r0, r3
    6902:	4413      	add	r3, r2
    6904:	461a      	mov	r2, r3
    6906:	f247 1324 	movw	r3, #28964	; 0x7124
    690a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    690e:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6912:	440b      	add	r3, r1
    6914:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    6918:	f103 0348 	add.w	r3, r3, #72	; 0x48
    691c:	601a      	str	r2, [r3, #0]
    MAC_memset_All( &g_mss_mac, 0u );

    g_mss_mac.base_address = MAC_BASE;
    g_mss_mac.phy_address = phy_address;

    for( a=0; a<RX_RING_SIZE; a++ )
    691e:	697b      	ldr	r3, [r7, #20]
    6920:	f103 0301 	add.w	r3, r3, #1
    6924:	617b      	str	r3, [r7, #20]
    6926:	697b      	ldr	r3, [r7, #20]
    6928:	2b03      	cmp	r3, #3
    692a:	ddc7      	ble.n	68bc <MSS_MAC_init+0xb4>
        /* Give the ownership to the MAC */
        g_mss_mac.rx_descriptors[a].descriptor_0 = RDES0_OWN;
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
        g_mss_mac.rx_descriptors[a].buffer_1 = (uint32_t)g_mss_mac.rx_buffers[a];
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;
    692c:	f247 1324 	movw	r3, #28964	; 0x7124
    6930:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6934:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    6938:	f103 0374 	add.w	r3, r3, #116	; 0x74
    693c:	681b      	ldr	r3, [r3, #0]
    693e:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    6942:	f247 1324 	movw	r3, #28964	; 0x7124
    6946:	f2c2 0300 	movt	r3, #8192	; 0x2000
    694a:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    694e:	f103 0374 	add.w	r3, r3, #116	; 0x74
    6952:	601a      	str	r2, [r3, #0]

    for( a = 0; a < TX_RING_SIZE; a++ )
    6954:	f04f 0300 	mov.w	r3, #0
    6958:	617b      	str	r3, [r7, #20]
    695a:	e018      	b.n	698e <MSS_MAC_init+0x186>
    {
        g_mss_mac.tx_descriptors[a].buffer_1 = (uint32_t)g_mss_mac.tx_buffers[a];
    695c:	6979      	ldr	r1, [r7, #20]
    695e:	4a6c      	ldr	r2, [pc, #432]	; (6b10 <MSS_MAC_init+0x308>)
    6960:	697b      	ldr	r3, [r7, #20]
    6962:	f240 50ec 	movw	r0, #1516	; 0x5ec
    6966:	fb00 f303 	mul.w	r3, r0, r3
    696a:	4413      	add	r3, r2
    696c:	461a      	mov	r2, r3
    696e:	f247 1324 	movw	r3, #28964	; 0x7124
    6972:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6976:	f101 01c5 	add.w	r1, r1, #197	; 0xc5
    697a:	ea4f 1101 	mov.w	r1, r1, lsl #4
    697e:	440b      	add	r3, r1
    6980:	f103 0304 	add.w	r3, r3, #4
    6984:	601a      	str	r2, [r3, #0]
        g_mss_mac.rx_descriptors[a].descriptor_1 = (MSS_RX_BUFF_SIZE << RDES1_RBS1_OFFSET);
        g_mss_mac.rx_descriptors[a].buffer_1 = (uint32_t)g_mss_mac.rx_buffers[a];
    }
    g_mss_mac.rx_descriptors[RX_RING_SIZE-1].descriptor_1 |= RDES1_RER;

    for( a = 0; a < TX_RING_SIZE; a++ )
    6986:	697b      	ldr	r3, [r7, #20]
    6988:	f103 0301 	add.w	r3, r3, #1
    698c:	617b      	str	r3, [r7, #20]
    698e:	697b      	ldr	r3, [r7, #20]
    6990:	2b01      	cmp	r3, #1
    6992:	dde3      	ble.n	695c <MSS_MAC_init+0x154>
    {
        g_mss_mac.tx_descriptors[a].buffer_1 = (uint32_t)g_mss_mac.tx_buffers[a];
    }
    g_mss_mac.tx_descriptors[TX_RING_SIZE - 1].descriptor_1 |= TDES1_TER;
    6994:	f247 1324 	movw	r3, #28964	; 0x7124
    6998:	f2c2 0300 	movt	r3, #8192	; 0x2000
    699c:	f8d3 3c60 	ldr.w	r3, [r3, #3168]	; 0xc60
    69a0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    69a4:	f247 1324 	movw	r3, #28964	; 0x7124
    69a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    69ac:	f8c3 2c60 	str.w	r2, [r3, #3168]	; 0xc60

    /* Configurable settings */
    MAC_BITBAND->CSR0_DBO = DESCRIPTOR_BYTE_ORDERING_MODE;
    69b0:	f240 0300 	movw	r3, #0
    69b4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    69b8:	f04f 0200 	mov.w	r2, #0
    69bc:	651a      	str	r2, [r3, #80]	; 0x50
    MAC->CSR0 = (MAC->CSR0 & ~CSR0_PBL_MASK) | ((uint32_t)PROGRAMMABLE_BURST_LENGTH << CSR0_PBL_SHIFT);
    69be:	f243 0300 	movw	r3, #12288	; 0x3000
    69c2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    69c6:	f243 0200 	movw	r2, #12288	; 0x3000
    69ca:	f2c4 0200 	movt	r2, #16384	; 0x4000
    69ce:	6812      	ldr	r2, [r2, #0]
    69d0:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    69d4:	601a      	str	r2, [r3, #0]
    MAC_BITBAND->CSR0_BLE = BUFFER_BYTE_ORDERING_MODE;
    69d6:	f240 0300 	movw	r3, #0
    69da:	f2c4 2306 	movt	r3, #16902	; 0x4206
    69de:	f04f 0200 	mov.w	r2, #0
    69e2:	61da      	str	r2, [r3, #28]
    MAC_BITBAND->CSR0_BAR = (uint32_t)BUS_ARBITRATION_SCHEME;
    69e4:	f240 0300 	movw	r3, #0
    69e8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    69ec:	f04f 0200 	mov.w	r2, #0
    69f0:	605a      	str	r2, [r3, #4]

    /* Fixed settings */
    /* No automatic polling */
    MAC->CSR0 = MAC->CSR0 &~ CSR0_TAP_MASK;
    69f2:	f243 0300 	movw	r3, #12288	; 0x3000
    69f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    69fa:	f243 0200 	movw	r2, #12288	; 0x3000
    69fe:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6a02:	6812      	ldr	r2, [r2, #0]
    6a04:	f422 2260 	bic.w	r2, r2, #917504	; 0xe0000
    6a08:	601a      	str	r2, [r3, #0]
    /* No space between descriptors */
    MAC->CSR0 = MAC->CSR0 &~ CSR0_DSL_MASK;
    6a0a:	f243 0300 	movw	r3, #12288	; 0x3000
    6a0e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6a12:	f243 0200 	movw	r2, #12288	; 0x3000
    6a16:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6a1a:	6812      	ldr	r2, [r2, #0]
    6a1c:	f022 027c 	bic.w	r2, r2, #124	; 0x7c
    6a20:	601a      	str	r2, [r3, #0]
    /* General-purpose timer works in continuous mode */
    MAC_BITBAND->CSR11_CON = 1u;
    6a22:	f240 0300 	movw	r3, #0
    6a26:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6a2a:	f04f 0201 	mov.w	r2, #1
    6a2e:	f8c3 2b40 	str.w	r2, [r3, #2880]	; 0xb40
    /* Start general-purpose */
    MAC->CSR11 =  (MAC->CSR11 & ~CSR11_TIM_MASK) | (0x0000FFFFuL << CSR11_TIM_SHIFT);
    6a32:	f243 0300 	movw	r3, #12288	; 0x3000
    6a36:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6a3a:	f243 0200 	movw	r2, #12288	; 0x3000
    6a3e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6a42:	6d92      	ldr	r2, [r2, #88]	; 0x58
    6a44:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    6a48:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    6a4c:	659a      	str	r2, [r3, #88]	; 0x58

    /* Disable promiscuous mode */
    MAC_BITBAND->CSR6_PR = 0u;
    6a4e:	f240 0300 	movw	r3, #0
    6a52:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6a56:	f04f 0200 	mov.w	r2, #0
    6a5a:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618

    /* Enable store and forward */
    MAC_BITBAND->CSR6_SF = 1u;
    6a5e:	f240 0300 	movw	r3, #0
    6a62:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6a66:	f04f 0201 	mov.w	r2, #1
    6a6a:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654

    /* Set descriptors */
    MAC->CSR3 = (uint32_t)&(g_mss_mac.rx_descriptors[0].descriptor_0);
    6a6e:	f243 0300 	movw	r3, #12288	; 0x3000
    6a72:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6a76:	4a27      	ldr	r2, [pc, #156]	; (6b14 <MSS_MAC_init+0x30c>)
    6a78:	619a      	str	r2, [r3, #24]
    MAC->CSR4 = (uint32_t)&(g_mss_mac.tx_descriptors[0].descriptor_0);
    6a7a:	f243 0300 	movw	r3, #12288	; 0x3000
    6a7e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6a82:	4a25      	ldr	r2, [pc, #148]	; (6b18 <MSS_MAC_init+0x310>)
    6a84:	621a      	str	r2, [r3, #32]
    
	/* enable normal interrupts */
    MAC_BITBAND->CSR7_NIE = 1u;
    6a86:	f240 0300 	movw	r3, #0
    6a8a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6a8e:	f04f 0201 	mov.w	r2, #1
    6a92:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740

    /* Detect PHY */
    if( g_mss_mac.phy_address > MSS_PHY_ADDRESS_MAX )
    6a96:	f247 1324 	movw	r3, #28964	; 0x7124
    6a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6a9e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    6aa2:	781b      	ldrb	r3, [r3, #0]
    6aa4:	2b1f      	cmp	r3, #31
    6aa6:	d90b      	bls.n	6ac0 <MSS_MAC_init+0x2b8>
    {
    	PHY_probe();
    6aa8:	f001 fdfc 	bl	86a4 <PHY_probe>
    	ASSERT( g_mss_mac.phy_address <= MSS_PHY_ADDRESS_MAX );
    6aac:	f247 1324 	movw	r3, #28964	; 0x7124
    6ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ab4:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    6ab8:	781b      	ldrb	r3, [r3, #0]
    6aba:	2b1f      	cmp	r3, #31
    6abc:	d900      	bls.n	6ac0 <MSS_MAC_init+0x2b8>
    6abe:	be00      	bkpt	0x0000
    }

    /* Reset PHY */
    PHY_reset();
    6ac0:	f001 fe36 	bl	8730 <PHY_reset>

	/* Set flags */
    g_mss_mac.flags = FLAG_MAC_INIT_DONE | FLAG_PERFECT_FILTERING;
    6ac4:	f247 1324 	movw	r3, #28964	; 0x7124
    6ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6acc:	f04f 0203 	mov.w	r2, #3
    6ad0:	711a      	strb	r2, [r3, #4]

	/* Configure chip according to PHY status */
    MSS_MAC_auto_setup_link();
    6ad2:	f000 fcc5 	bl	7460 <MSS_MAC_auto_setup_link>

    /* Set default MAC address and reset mac filters */
   	MAC_memcpy( g_mss_mac.mac_address, mac_address, 6u );
    6ad6:	f107 030c 	add.w	r3, r7, #12
    6ada:	4810      	ldr	r0, [pc, #64]	; (6b1c <MSS_MAC_init+0x314>)
    6adc:	4619      	mov	r1, r3
    6ade:	f04f 0206 	mov.w	r2, #6
    6ae2:	f001 fcb1 	bl	8448 <MAC_memcpy>
   	MSS_MAC_set_mac_filters( 0u, NULL_buffer );
    6ae6:	f243 138c 	movw	r3, #12684	; 0x318c
    6aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6aee:	681b      	ldr	r3, [r3, #0]
    6af0:	f04f 0000 	mov.w	r0, #0
    6af4:	4619      	mov	r1, r3
    6af6:	f000 fd5d 	bl	75b4 <MSS_MAC_set_mac_filters>


    /* Start receiving and transmission */
    MAC_start_receiving();
    6afa:	f001 fa21 	bl	7f40 <MAC_start_receiving>
    MAC_start_transmission();
    6afe:	f001 f9e1 	bl	7ec4 <MAC_start_transmission>
}
    6b02:	f107 0718 	add.w	r7, r7, #24
    6b06:	46bd      	mov	sp, r7
    6b08:	bd80      	pop	{r7, pc}
    6b0a:	bf00      	nop
    6b0c:	20007d94 	.word	0x20007d94
    6b10:	20007198 	.word	0x20007198
    6b14:	20009564 	.word	0x20009564
    6b18:	20007d70 	.word	0x20007d70
    6b1c:	2000712a 	.word	0x2000712a

00006b20 <MSS_MAC_configure>:
void
MSS_MAC_configure
(
    uint32_t configuration
)
{
    6b20:	b580      	push	{r7, lr}
    6b22:	b084      	sub	sp, #16
    6b24:	af00      	add	r7, sp, #0
    6b26:	6078      	str	r0, [r7, #4]
    int32_t ret;

    ASSERT( MAC_test_instance() == MAC_OK );
    6b28:	f000 fe88 	bl	783c <MAC_test_instance>
    6b2c:	4603      	mov	r3, r0
    6b2e:	2b00      	cmp	r3, #0
    6b30:	d000      	beq.n	6b34 <MSS_MAC_configure+0x14>
    6b32:	be00      	bkpt	0x0000

    ret = MAC_stop_transmission();
    6b34:	f001 f996 	bl	7e64 <MAC_stop_transmission>
    6b38:	4603      	mov	r3, r0
    6b3a:	60fb      	str	r3, [r7, #12]
    ASSERT( ret == MAC_OK );
    6b3c:	68fb      	ldr	r3, [r7, #12]
    6b3e:	2b00      	cmp	r3, #0
    6b40:	d000      	beq.n	6b44 <MSS_MAC_configure+0x24>
    6b42:	be00      	bkpt	0x0000

    ret = MAC_stop_receiving();
    6b44:	f001 f9cc 	bl	7ee0 <MAC_stop_receiving>
    6b48:	4603      	mov	r3, r0
    6b4a:	60fb      	str	r3, [r7, #12]
    ASSERT( ret == MAC_OK );
    6b4c:	68fb      	ldr	r3, [r7, #12]
    6b4e:	2b00      	cmp	r3, #0
    6b50:	d000      	beq.n	6b54 <MSS_MAC_configure+0x34>
    6b52:	be00      	bkpt	0x0000

    MAC_BITBAND->CSR6_RA = (uint32_t)(((configuration & MSS_MAC_CFG_RECEIVE_ALL) != 0u) ? 1u : 0u );
    6b54:	f240 0300 	movw	r3, #0
    6b58:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6b5c:	687a      	ldr	r2, [r7, #4]
    6b5e:	f002 0201 	and.w	r2, r2, #1
    6b62:	b2d2      	uxtb	r2, r2
    6b64:	2a00      	cmp	r2, #0
    6b66:	d002      	beq.n	6b6e <MSS_MAC_configure+0x4e>
    6b68:	f04f 0201 	mov.w	r2, #1
    6b6c:	e001      	b.n	6b72 <MSS_MAC_configure+0x52>
    6b6e:	f04f 0200 	mov.w	r2, #0
    6b72:	f8c3 2678 	str.w	r2, [r3, #1656]	; 0x678
    MAC_BITBAND->CSR6_TTM = (((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? 1u : 0u );
    6b76:	f240 0300 	movw	r3, #0
    6b7a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6b7e:	687a      	ldr	r2, [r7, #4]
    6b80:	f002 0202 	and.w	r2, r2, #2
    6b84:	2a00      	cmp	r2, #0
    6b86:	d002      	beq.n	6b8e <MSS_MAC_configure+0x6e>
    6b88:	f04f 0201 	mov.w	r2, #1
    6b8c:	e001      	b.n	6b92 <MSS_MAC_configure+0x72>
    6b8e:	f04f 0200 	mov.w	r2, #0
    6b92:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
    MAC_BITBAND->CSR6_SF = (uint32_t)(((configuration & MSS_MAC_CFG_STORE_AND_FORWARD) != 0u) ? 1u : 0u );
    6b96:	f240 0300 	movw	r3, #0
    6b9a:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6b9e:	687a      	ldr	r2, [r7, #4]
    6ba0:	f002 0204 	and.w	r2, r2, #4
    6ba4:	2a00      	cmp	r2, #0
    6ba6:	d002      	beq.n	6bae <MSS_MAC_configure+0x8e>
    6ba8:	f04f 0201 	mov.w	r2, #1
    6bac:	e001      	b.n	6bb2 <MSS_MAC_configure+0x92>
    6bae:	f04f 0200 	mov.w	r2, #0
    6bb2:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654
    
    switch( configuration & MSS_MAC_CFG_THRESHOLD_CONTROL_11 ) {
    6bb6:	687b      	ldr	r3, [r7, #4]
    6bb8:	f003 0318 	and.w	r3, r3, #24
    6bbc:	2b18      	cmp	r3, #24
    6bbe:	d86c      	bhi.n	6c9a <MSS_MAC_configure+0x17a>
    6bc0:	a201      	add	r2, pc, #4	; (adr r2, 6bc8 <MSS_MAC_configure+0xa8>)
    6bc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6bc6:	bf00      	nop
    6bc8:	00006c2d 	.word	0x00006c2d
    6bcc:	00006c9b 	.word	0x00006c9b
    6bd0:	00006c9b 	.word	0x00006c9b
    6bd4:	00006c9b 	.word	0x00006c9b
    6bd8:	00006c9b 	.word	0x00006c9b
    6bdc:	00006c9b 	.word	0x00006c9b
    6be0:	00006c9b 	.word	0x00006c9b
    6be4:	00006c9b 	.word	0x00006c9b
    6be8:	00006c47 	.word	0x00006c47
    6bec:	00006c9b 	.word	0x00006c9b
    6bf0:	00006c9b 	.word	0x00006c9b
    6bf4:	00006c9b 	.word	0x00006c9b
    6bf8:	00006c9b 	.word	0x00006c9b
    6bfc:	00006c9b 	.word	0x00006c9b
    6c00:	00006c9b 	.word	0x00006c9b
    6c04:	00006c9b 	.word	0x00006c9b
    6c08:	00006c65 	.word	0x00006c65
    6c0c:	00006c9b 	.word	0x00006c9b
    6c10:	00006c9b 	.word	0x00006c9b
    6c14:	00006c9b 	.word	0x00006c9b
    6c18:	00006c9b 	.word	0x00006c9b
    6c1c:	00006c9b 	.word	0x00006c9b
    6c20:	00006c9b 	.word	0x00006c9b
    6c24:	00006c9b 	.word	0x00006c9b
    6c28:	00006c83 	.word	0x00006c83
    case MSS_MAC_CFG_THRESHOLD_CONTROL_00:
        MAC->CSR6 = MAC->CSR6 & ~CSR6_TR_MASK;
    6c2c:	f243 0300 	movw	r3, #12288	; 0x3000
    6c30:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6c34:	f243 0200 	movw	r2, #12288	; 0x3000
    6c38:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6c3c:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6c3e:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    6c42:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    6c44:	e029      	b.n	6c9a <MSS_MAC_configure+0x17a>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_01:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)1 << CSR6_TR_SHIFT );
    6c46:	f243 0300 	movw	r3, #12288	; 0x3000
    6c4a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6c4e:	f243 0200 	movw	r2, #12288	; 0x3000
    6c52:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6c56:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6c58:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    6c5c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    6c60:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    6c62:	e01a      	b.n	6c9a <MSS_MAC_configure+0x17a>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_10:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)2 << CSR6_TR_SHIFT );
    6c64:	f243 0300 	movw	r3, #12288	; 0x3000
    6c68:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6c6c:	f243 0200 	movw	r2, #12288	; 0x3000
    6c70:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6c74:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6c76:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    6c7a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    6c7e:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    6c80:	e00b      	b.n	6c9a <MSS_MAC_configure+0x17a>
    case MSS_MAC_CFG_THRESHOLD_CONTROL_11:
        MAC->CSR6 = (MAC->CSR6 & ~CSR6_TR_MASK) | ((uint32_t)3 << CSR6_TR_SHIFT );
    6c82:	f243 0300 	movw	r3, #12288	; 0x3000
    6c86:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6c8a:	f243 0200 	movw	r2, #12288	; 0x3000
    6c8e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    6c92:	6b12      	ldr	r2, [r2, #48]	; 0x30
    6c94:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
    6c98:	631a      	str	r2, [r3, #48]	; 0x30
        break;
    default:
        break;
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    6c9a:	f240 0300 	movw	r3, #0
    6c9e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6ca2:	687a      	ldr	r2, [r7, #4]
    6ca4:	f002 0220 	and.w	r2, r2, #32
    6ca8:	2a00      	cmp	r2, #0
    6caa:	d002      	beq.n	6cb2 <MSS_MAC_configure+0x192>
    6cac:	f04f 0201 	mov.w	r2, #1
    6cb0:	e001      	b.n	6cb6 <MSS_MAC_configure+0x196>
    6cb2:	f04f 0200 	mov.w	r2, #0
    6cb6:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    6cba:	f240 0300 	movw	r3, #0
    6cbe:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6cc2:	687a      	ldr	r2, [r7, #4]
    6cc4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    6cc8:	2a00      	cmp	r2, #0
    6cca:	d002      	beq.n	6cd2 <MSS_MAC_configure+0x1b2>
    6ccc:	f04f 0201 	mov.w	r2, #1
    6cd0:	e001      	b.n	6cd6 <MSS_MAC_configure+0x1b6>
    6cd2:	f04f 0200 	mov.w	r2, #0
    6cd6:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    6cda:	f240 0300 	movw	r3, #0
    6cde:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6ce2:	687a      	ldr	r2, [r7, #4]
    6ce4:	f002 0280 	and.w	r2, r2, #128	; 0x80
    6ce8:	2a00      	cmp	r2, #0
    6cea:	d002      	beq.n	6cf2 <MSS_MAC_configure+0x1d2>
    6cec:	f04f 0201 	mov.w	r2, #1
    6cf0:	e001      	b.n	6cf6 <MSS_MAC_configure+0x1d6>
    6cf2:	f04f 0200 	mov.w	r2, #0
    6cf6:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    6cfa:	f240 0300 	movw	r3, #0
    6cfe:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6d02:	687a      	ldr	r2, [r7, #4]
    6d04:	f402 7200 	and.w	r2, r2, #512	; 0x200
    6d08:	2a00      	cmp	r2, #0
    6d0a:	d002      	beq.n	6d12 <MSS_MAC_configure+0x1f2>
    6d0c:	f04f 0201 	mov.w	r2, #1
    6d10:	e001      	b.n	6d16 <MSS_MAC_configure+0x1f6>
    6d12:	f04f 0200 	mov.w	r2, #0
    6d16:	f8c3 260c 	str.w	r2, [r3, #1548]	; 0x60c
    PHY_set_link_type( (uint8_t)
    6d1a:	687b      	ldr	r3, [r7, #4]
    6d1c:	b2db      	uxtb	r3, r3
    6d1e:	f003 0302 	and.w	r3, r3, #2
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );
    6d22:	687a      	ldr	r2, [r7, #4]
    6d24:	f002 0220 	and.w	r2, r2, #32
    }
    MAC_BITBAND->CSR6_FD = (uint32_t)(((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PM = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_ALL_MULTICAST) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PR = (uint32_t)(((configuration & MSS_MAC_CFG_PROMISCUOUS_MODE) != 0u) ? 1u : 0u );
    MAC_BITBAND->CSR6_PB = (uint32_t)(((configuration & MSS_MAC_CFG_PASS_BAD_FRAMES) != 0u) ? 1u : 0u );
    PHY_set_link_type( (uint8_t)
    6d28:	2a00      	cmp	r2, #0
    6d2a:	d002      	beq.n	6d32 <MSS_MAC_configure+0x212>
    6d2c:	f04f 0204 	mov.w	r2, #4
    6d30:	e001      	b.n	6d36 <MSS_MAC_configure+0x216>
    6d32:	f04f 0200 	mov.w	r2, #0
    6d36:	ea43 0302 	orr.w	r3, r3, r2
    6d3a:	b2db      	uxtb	r3, r3
    6d3c:	4618      	mov	r0, r3
    6d3e:	f001 fdb9 	bl	88b4 <PHY_set_link_type>
        ((((configuration & MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE) != 0u) ? MSS_MAC_LINK_STATUS_100MB : 0u ) |
        (((configuration & MSS_MAC_CFG_FULL_DUPLEX_MODE) != 0u) ? MSS_MAC_LINK_STATUS_FDX : 0u )) );

    MAC_start_transmission();
    6d42:	f001 f8bf 	bl	7ec4 <MAC_start_transmission>
    MAC_start_receiving();
    6d46:	f001 f8fb 	bl	7f40 <MAC_start_receiving>

    MSS_MAC_auto_setup_link();
    6d4a:	f000 fb89 	bl	7460 <MSS_MAC_auto_setup_link>
}
    6d4e:	f107 0710 	add.w	r7, r7, #16
    6d52:	46bd      	mov	sp, r7
    6d54:	bd80      	pop	{r7, pc}
    6d56:	bf00      	nop

00006d58 <MSS_MAC_get_configuration>:
 *    - #MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE
 * @see   MAC_configure()
 */
int32_t
MSS_MAC_get_configuration( void )
{
    6d58:	b580      	push	{r7, lr}
    6d5a:	b082      	sub	sp, #8
    6d5c:	af00      	add	r7, sp, #0
    uint32_t configuration;

    ASSERT( MAC_test_instance() == MAC_OK );
    6d5e:	f000 fd6d 	bl	783c <MAC_test_instance>
    6d62:	4603      	mov	r3, r0
    6d64:	2b00      	cmp	r3, #0
    6d66:	d000      	beq.n	6d6a <MSS_MAC_get_configuration+0x12>
    6d68:	be00      	bkpt	0x0000

    configuration = 0u;
    6d6a:	f04f 0300 	mov.w	r3, #0
    6d6e:	607b      	str	r3, [r7, #4]
    if( MAC_BITBAND->CSR6_RA != 0u ) {
    6d70:	f240 0300 	movw	r3, #0
    6d74:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6d78:	f8d3 3678 	ldr.w	r3, [r3, #1656]	; 0x678
    6d7c:	2b00      	cmp	r3, #0
    6d7e:	d003      	beq.n	6d88 <MSS_MAC_get_configuration+0x30>
        configuration |= MSS_MAC_CFG_RECEIVE_ALL;
    6d80:	687b      	ldr	r3, [r7, #4]
    6d82:	f043 0301 	orr.w	r3, r3, #1
    6d86:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_TTM != 0u ) {
    6d88:	f240 0300 	movw	r3, #0
    6d8c:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6d90:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    6d94:	2b00      	cmp	r3, #0
    6d96:	d003      	beq.n	6da0 <MSS_MAC_get_configuration+0x48>
        configuration |= MSS_MAC_CFG_TRANSMIT_THRESHOLD_MODE;
    6d98:	687b      	ldr	r3, [r7, #4]
    6d9a:	f043 0302 	orr.w	r3, r3, #2
    6d9e:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_SF != 0u ) {
    6da0:	f240 0300 	movw	r3, #0
    6da4:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6da8:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
    6dac:	2b00      	cmp	r3, #0
    6dae:	d003      	beq.n	6db8 <MSS_MAC_get_configuration+0x60>
        configuration |= MSS_MAC_CFG_STORE_AND_FORWARD;
    6db0:	687b      	ldr	r3, [r7, #4]
    6db2:	f043 0304 	orr.w	r3, r3, #4
    6db6:	607b      	str	r3, [r7, #4]
    }

    switch( (MAC->CSR6 & CSR6_TR_MASK) >> CSR6_TR_SHIFT ) {
    6db8:	f243 0300 	movw	r3, #12288	; 0x3000
    6dbc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6dc0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6dc2:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
    6dc6:	ea4f 3393 	mov.w	r3, r3, lsr #14
    6dca:	2b02      	cmp	r3, #2
    6dcc:	d008      	beq.n	6de0 <MSS_MAC_get_configuration+0x88>
    6dce:	2b03      	cmp	r3, #3
    6dd0:	d00b      	beq.n	6dea <MSS_MAC_get_configuration+0x92>
    6dd2:	2b01      	cmp	r3, #1
    6dd4:	d10d      	bne.n	6df2 <MSS_MAC_get_configuration+0x9a>
    case 1: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_01; break;
    6dd6:	687b      	ldr	r3, [r7, #4]
    6dd8:	f043 0308 	orr.w	r3, r3, #8
    6ddc:	607b      	str	r3, [r7, #4]
    6dde:	e008      	b.n	6df2 <MSS_MAC_get_configuration+0x9a>
    case 2: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_10; break;
    6de0:	687b      	ldr	r3, [r7, #4]
    6de2:	f043 0310 	orr.w	r3, r3, #16
    6de6:	607b      	str	r3, [r7, #4]
    6de8:	e003      	b.n	6df2 <MSS_MAC_get_configuration+0x9a>
    case 3: configuration |= MSS_MAC_CFG_THRESHOLD_CONTROL_11; break;
    6dea:	687b      	ldr	r3, [r7, #4]
    6dec:	f043 0318 	orr.w	r3, r3, #24
    6df0:	607b      	str	r3, [r7, #4]
    default: break;
    }
    if( MAC_BITBAND->CSR6_FD != 0u ) {
    6df2:	f240 0300 	movw	r3, #0
    6df6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6dfa:	f8d3 3624 	ldr.w	r3, [r3, #1572]	; 0x624
    6dfe:	2b00      	cmp	r3, #0
    6e00:	d003      	beq.n	6e0a <MSS_MAC_get_configuration+0xb2>
        configuration |= MSS_MAC_CFG_FULL_DUPLEX_MODE;
    6e02:	687b      	ldr	r3, [r7, #4]
    6e04:	f043 0320 	orr.w	r3, r3, #32
    6e08:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PM != 0u ) {
    6e0a:	f240 0300 	movw	r3, #0
    6e0e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e12:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
    6e16:	2b00      	cmp	r3, #0
    6e18:	d003      	beq.n	6e22 <MSS_MAC_get_configuration+0xca>
        configuration |= MSS_MAC_CFG_PASS_ALL_MULTICAST;
    6e1a:	687b      	ldr	r3, [r7, #4]
    6e1c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6e20:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PR != 0u ) {
    6e22:	f240 0300 	movw	r3, #0
    6e26:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e2a:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
    6e2e:	2b00      	cmp	r3, #0
    6e30:	d003      	beq.n	6e3a <MSS_MAC_get_configuration+0xe2>
        configuration |= MSS_MAC_CFG_PROMISCUOUS_MODE;
    6e32:	687b      	ldr	r3, [r7, #4]
    6e34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    6e38:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_IF != 0u ) {
    6e3a:	f240 0300 	movw	r3, #0
    6e3e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e42:	f8d3 3610 	ldr.w	r3, [r3, #1552]	; 0x610
    6e46:	2b00      	cmp	r3, #0
    6e48:	d003      	beq.n	6e52 <MSS_MAC_get_configuration+0xfa>
        configuration |= MSS_MAC_CFG_INVERSE_FILTERING;
    6e4a:	687b      	ldr	r3, [r7, #4]
    6e4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    6e50:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_PB != 0u ) {
    6e52:	f240 0300 	movw	r3, #0
    6e56:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e5a:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    6e5e:	2b00      	cmp	r3, #0
    6e60:	d003      	beq.n	6e6a <MSS_MAC_get_configuration+0x112>
        configuration |= MSS_MAC_CFG_PASS_BAD_FRAMES;
    6e62:	687b      	ldr	r3, [r7, #4]
    6e64:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    6e68:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HO != 0u ) {
    6e6a:	f240 0300 	movw	r3, #0
    6e6e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e72:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    6e76:	2b00      	cmp	r3, #0
    6e78:	d003      	beq.n	6e82 <MSS_MAC_get_configuration+0x12a>
        configuration |= MSS_MAC_CFG_HASH_ONLY_FILTERING_MODE;
    6e7a:	687b      	ldr	r3, [r7, #4]
    6e7c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    6e80:	607b      	str	r3, [r7, #4]
    }

    if( MAC_BITBAND->CSR6_HP != 0u ) {
    6e82:	f240 0300 	movw	r3, #0
    6e86:	f2c4 2306 	movt	r3, #16902	; 0x4206
    6e8a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    6e8e:	2b00      	cmp	r3, #0
    6e90:	d003      	beq.n	6e9a <MSS_MAC_get_configuration+0x142>
        configuration |= MSS_MAC_CFG_HASH_PERFECT_RECEIVE_FILTERING_MODE;
    6e92:	687b      	ldr	r3, [r7, #4]
    6e94:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    6e98:	607b      	str	r3, [r7, #4]
    }
    
    return (int32_t)configuration;
    6e9a:	687b      	ldr	r3, [r7, #4]
}
    6e9c:	4618      	mov	r0, r3
    6e9e:	f107 0708 	add.w	r7, r7, #8
    6ea2:	46bd      	mov	sp, r7
    6ea4:	bd80      	pop	{r7, pc}
    6ea6:	bf00      	nop

00006ea8 <MSS_MAC_tx_packet>:
(
    const uint8_t *pacData,
    uint16_t pacLen,
    uint32_t time_out
)
{
    6ea8:	b580      	push	{r7, lr}
    6eaa:	b086      	sub	sp, #24
    6eac:	af00      	add	r7, sp, #0
    6eae:	60f8      	str	r0, [r7, #12]
    6eb0:	460b      	mov	r3, r1
    6eb2:	607a      	str	r2, [r7, #4]
    6eb4:	817b      	strh	r3, [r7, #10]
	uint32_t desc;
    int32_t error = MAC_OK;
    6eb6:	f04f 0300 	mov.w	r3, #0
    6eba:	617b      	str	r3, [r7, #20]

    ASSERT( MAC_test_instance() == MAC_OK );
    6ebc:	f000 fcbe 	bl	783c <MAC_test_instance>
    6ec0:	4603      	mov	r3, r0
    6ec2:	2b00      	cmp	r3, #0
    6ec4:	d000      	beq.n	6ec8 <MSS_MAC_tx_packet+0x20>
    6ec6:	be00      	bkpt	0x0000

    ASSERT( pacData != NULL_buffer );
    6ec8:	f243 138c 	movw	r3, #12684	; 0x318c
    6ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ed0:	681b      	ldr	r3, [r3, #0]
    6ed2:	68fa      	ldr	r2, [r7, #12]
    6ed4:	429a      	cmp	r2, r3
    6ed6:	d100      	bne.n	6eda <MSS_MAC_tx_packet+0x32>
    6ed8:	be00      	bkpt	0x0000

	ASSERT( pacLen >= 12 );
    6eda:	897b      	ldrh	r3, [r7, #10]
    6edc:	2b0b      	cmp	r3, #11
    6ede:	d800      	bhi.n	6ee2 <MSS_MAC_tx_packet+0x3a>
    6ee0:	be00      	bkpt	0x0000

    if( (g_mss_mac.flags & FLAG_EXCEED_LIMIT) == 0u )
    6ee2:	f247 1324 	movw	r3, #28964	; 0x7124
    6ee6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6eea:	791b      	ldrb	r3, [r3, #4]
    6eec:	f003 0308 	and.w	r3, r3, #8
    6ef0:	2b00      	cmp	r3, #0
    6ef2:	d105      	bne.n	6f00 <MSS_MAC_tx_packet+0x58>
    {
		ASSERT( pacLen <= MSS_MAX_PACKET_SIZE );
    6ef4:	897a      	ldrh	r2, [r7, #10]
    6ef6:	f240 53ea 	movw	r3, #1514	; 0x5ea
    6efa:	429a      	cmp	r2, r3
    6efc:	d900      	bls.n	6f00 <MSS_MAC_tx_packet+0x58>
    6efe:	be00      	bkpt	0x0000
	}

    ASSERT(  (time_out == MSS_MAC_BLOCKING) ||
    6f00:	687b      	ldr	r3, [r7, #4]
    6f02:	f1b3 3fff 	cmp.w	r3, #4294967295
    6f06:	d00a      	beq.n	6f1e <MSS_MAC_tx_packet+0x76>
    6f08:	687b      	ldr	r3, [r7, #4]
    6f0a:	2b00      	cmp	r3, #0
    6f0c:	d007      	beq.n	6f1e <MSS_MAC_tx_packet+0x76>
    6f0e:	687b      	ldr	r3, [r7, #4]
    6f10:	2b00      	cmp	r3, #0
    6f12:	d003      	beq.n	6f1c <MSS_MAC_tx_packet+0x74>
    6f14:	687b      	ldr	r3, [r7, #4]
    6f16:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    6f1a:	d900      	bls.n	6f1e <MSS_MAC_tx_packet+0x76>
    6f1c:	be00      	bkpt	0x0000
    			(time_out == MSS_MAC_NONBLOCKING) ||
    			((time_out >= 1) && (time_out <= 0x01000000uL)) );

    if( time_out == MSS_MAC_NONBLOCKING )
    6f1e:	687b      	ldr	r3, [r7, #4]
    6f20:	2b00      	cmp	r3, #0
    6f22:	d116      	bne.n	6f52 <MSS_MAC_tx_packet+0xaa>
    {
    	/* Check if current descriptor is free */
    	if(((g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0) & TDES0_OWN) == TDES0_OWN )
    6f24:	f247 1324 	movw	r3, #28964	; 0x7124
    6f28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f2c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    6f2e:	f247 1324 	movw	r3, #28964	; 0x7124
    6f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f36:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6f3a:	4413      	add	r3, r2
    6f3c:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
    6f40:	f103 030c 	add.w	r3, r3, #12
    6f44:	681b      	ldr	r3, [r3, #0]
    6f46:	2b00      	cmp	r3, #0
    6f48:	da37      	bge.n	6fba <MSS_MAC_tx_packet+0x112>
        {
			error = MAC_BUFFER_IS_FULL;
    6f4a:	f06f 0303 	mvn.w	r3, #3
    6f4e:	617b      	str	r3, [r7, #20]
    6f50:	e034      	b.n	6fbc <MSS_MAC_tx_packet+0x114>
    	}
    }
    else
	{
	    /* Wait until descriptor is free */
	    if( time_out != MSS_MAC_BLOCKING ) {
    6f52:	687b      	ldr	r3, [r7, #4]
    6f54:	f1b3 3fff 	cmp.w	r3, #4294967295
    6f58:	d017      	beq.n	6f8a <MSS_MAC_tx_packet+0xe2>
    	    MAC_set_time_out( time_out );
    6f5a:	6878      	ldr	r0, [r7, #4]
    6f5c:	f001 f850 	bl	8000 <MAC_set_time_out>
	    }
        
        while( (((g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0) & TDES0_OWN) == TDES0_OWN )
    6f60:	e014      	b.n	6f8c <MSS_MAC_tx_packet+0xe4>
                && (error == MAC_OK) )
	    {
		     /* transmit poll demand */
            MAC->CSR1 = 1u;
    6f62:	f243 0300 	movw	r3, #12288	; 0x3000
    6f66:	f2c4 0300 	movt	r3, #16384	; 0x4000
    6f6a:	f04f 0201 	mov.w	r2, #1
    6f6e:	609a      	str	r2, [r3, #8]
            
	    	if(time_out != MSS_MAC_BLOCKING){
    6f70:	687b      	ldr	r3, [r7, #4]
    6f72:	f1b3 3fff 	cmp.w	r3, #4294967295
    6f76:	d009      	beq.n	6f8c <MSS_MAC_tx_packet+0xe4>
	    		if(MAC_get_time_out() == 0u) {
    6f78:	f001 f86a 	bl	8050 <MAC_get_time_out>
    6f7c:	4603      	mov	r3, r0
    6f7e:	2b00      	cmp	r3, #0
    6f80:	d104      	bne.n	6f8c <MSS_MAC_tx_packet+0xe4>
	    			error = MAC_TIME_OUT;
    6f82:	f06f 0305 	mvn.w	r3, #5
    6f86:	617b      	str	r3, [r7, #20]
    6f88:	e000      	b.n	6f8c <MSS_MAC_tx_packet+0xe4>
	    /* Wait until descriptor is free */
	    if( time_out != MSS_MAC_BLOCKING ) {
    	    MAC_set_time_out( time_out );
	    }
        
        while( (((g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0) & TDES0_OWN) == TDES0_OWN )
    6f8a:	bf00      	nop
    6f8c:	f247 1324 	movw	r3, #28964	; 0x7124
    6f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f94:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    6f96:	f247 1324 	movw	r3, #28964	; 0x7124
    6f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f9e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6fa2:	4413      	add	r3, r2
    6fa4:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
    6fa8:	f103 030c 	add.w	r3, r3, #12
    6fac:	681b      	ldr	r3, [r3, #0]
    6fae:	2b00      	cmp	r3, #0
    6fb0:	da04      	bge.n	6fbc <MSS_MAC_tx_packet+0x114>
    6fb2:	697b      	ldr	r3, [r7, #20]
    6fb4:	2b00      	cmp	r3, #0
    6fb6:	d0d4      	beq.n	6f62 <MSS_MAC_tx_packet+0xba>
    6fb8:	e000      	b.n	6fbc <MSS_MAC_tx_packet+0x114>
    if( time_out == MSS_MAC_NONBLOCKING )
    {
    	/* Check if current descriptor is free */
    	if(((g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0) & TDES0_OWN) == TDES0_OWN )
        {
			error = MAC_BUFFER_IS_FULL;
    6fba:	bf00      	nop
	    		}
	    	}
	    }
	}

	if( error == MAC_OK ) {
    6fbc:	697b      	ldr	r3, [r7, #20]
    6fbe:	2b00      	cmp	r3, #0
    6fc0:	f040 8176 	bne.w	72b0 <MSS_MAC_tx_packet+0x408>

		g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 = 0u;
    6fc4:	f247 1324 	movw	r3, #28964	; 0x7124
    6fc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fcc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    6fce:	f247 1324 	movw	r3, #28964	; 0x7124
    6fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fd6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6fda:	4413      	add	r3, r2
    6fdc:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    6fe0:	f04f 0200 	mov.w	r2, #0
    6fe4:	601a      	str	r2, [r3, #0]

		if( (g_mss_mac.flags & FLAG_CRC_DISABLE) != 0u ) {
    6fe6:	f247 1324 	movw	r3, #28964	; 0x7124
    6fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fee:	791b      	ldrb	r3, [r3, #4]
    6ff0:	f003 0304 	and.w	r3, r3, #4
    6ff4:	2b00      	cmp	r3, #0
    6ff6:	d01f      	beq.n	7038 <MSS_MAC_tx_packet+0x190>
			g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |=	TDES1_AC;
    6ff8:	f247 1324 	movw	r3, #28964	; 0x7124
    6ffc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7000:	6f19      	ldr	r1, [r3, #112]	; 0x70
    7002:	f247 1324 	movw	r3, #28964	; 0x7124
    7006:	f2c2 0300 	movt	r3, #8192	; 0x2000
    700a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    700c:	f247 1324 	movw	r3, #28964	; 0x7124
    7010:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7014:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7018:	4413      	add	r3, r2
    701a:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    701e:	681b      	ldr	r3, [r3, #0]
    7020:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    7024:	f247 1324 	movw	r3, #28964	; 0x7124
    7028:	f2c2 0300 	movt	r3, #8192	; 0x2000
    702c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    7030:	440b      	add	r3, r1
    7032:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    7036:	601a      	str	r2, [r3, #0]
		}

        /* Every buffer can hold a full frame so they are always first and last
           descriptor */
        g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= TDES1_LS | TDES1_FS;
    7038:	f247 1324 	movw	r3, #28964	; 0x7124
    703c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7040:	6f19      	ldr	r1, [r3, #112]	; 0x70
    7042:	f247 1324 	movw	r3, #28964	; 0x7124
    7046:	f2c2 0300 	movt	r3, #8192	; 0x2000
    704a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    704c:	f247 1324 	movw	r3, #28964	; 0x7124
    7050:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7054:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7058:	4413      	add	r3, r2
    705a:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    705e:	681b      	ldr	r3, [r3, #0]
    7060:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000
    7064:	f247 1324 	movw	r3, #28964	; 0x7124
    7068:	f2c2 0300 	movt	r3, #8192	; 0x2000
    706c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    7070:	440b      	add	r3, r1
    7072:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    7076:	601a      	str	r2, [r3, #0]

        /* set data size */
        g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_1 |= pacLen;
    7078:	f247 1324 	movw	r3, #28964	; 0x7124
    707c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7080:	6f19      	ldr	r1, [r3, #112]	; 0x70
    7082:	f247 1324 	movw	r3, #28964	; 0x7124
    7086:	f2c2 0300 	movt	r3, #8192	; 0x2000
    708a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    708c:	f247 1324 	movw	r3, #28964	; 0x7124
    7090:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7094:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7098:	4413      	add	r3, r2
    709a:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    709e:	681a      	ldr	r2, [r3, #0]
    70a0:	897b      	ldrh	r3, [r7, #10]
    70a2:	ea42 0203 	orr.w	r2, r2, r3
    70a6:	f247 1324 	movw	r3, #28964	; 0x7124
    70aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70ae:	ea4f 1101 	mov.w	r1, r1, lsl #4
    70b2:	440b      	add	r3, r1
    70b4:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    70b8:	601a      	str	r2, [r3, #0]

        /* reset end of ring */
        g_mss_mac.tx_descriptors[TX_RING_SIZE-1].descriptor_1 |= TDES1_TER;
    70ba:	f247 1324 	movw	r3, #28964	; 0x7124
    70be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70c2:	f8d3 3c60 	ldr.w	r3, [r3, #3168]	; 0xc60
    70c6:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    70ca:	f247 1324 	movw	r3, #28964	; 0x7124
    70ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70d2:	f8c3 2c60 	str.w	r2, [r3, #3168]	; 0xc60

        /* copy data into buffer */
        if( pacLen > MSS_TX_BUFF_SIZE ) /* FLAG_EXCEED_LIMIT */
    70d6:	897a      	ldrh	r2, [r7, #10]
    70d8:	f240 53ec 	movw	r3, #1516	; 0x5ec
    70dc:	429a      	cmp	r2, r3
    70de:	d902      	bls.n	70e6 <MSS_MAC_tx_packet+0x23e>
        {
	        pacLen = (uint16_t)MSS_TX_BUFF_SIZE;
    70e0:	f240 53ec 	movw	r3, #1516	; 0x5ec
    70e4:	817b      	strh	r3, [r7, #10]
        }
        MAC_memcpy(
	        (uint8_t*)
	        g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].buffer_1,
    70e6:	f247 1324 	movw	r3, #28964	; 0x7124
    70ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        /* copy data into buffer */
        if( pacLen > MSS_TX_BUFF_SIZE ) /* FLAG_EXCEED_LIMIT */
        {
	        pacLen = (uint16_t)MSS_TX_BUFF_SIZE;
        }
        MAC_memcpy(
    70f0:	f247 1324 	movw	r3, #28964	; 0x7124
    70f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70f8:	f102 02c5 	add.w	r2, r2, #197	; 0xc5
    70fc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7100:	4413      	add	r3, r2
    7102:	f103 0304 	add.w	r3, r3, #4
    7106:	681b      	ldr	r3, [r3, #0]
    7108:	461a      	mov	r2, r3
    710a:	897b      	ldrh	r3, [r7, #10]
    710c:	4610      	mov	r0, r2
    710e:	68f9      	ldr	r1, [r7, #12]
    7110:	461a      	mov	r2, r3
    7112:	f001 f999 	bl	8448 <MAC_memcpy>
	        (uint8_t*)
	        g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].buffer_1,
	        pacData, (uint32_t)pacLen );

        /* update counters */
        desc = g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0;
    7116:	f247 1324 	movw	r3, #28964	; 0x7124
    711a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    711e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    7120:	f247 1324 	movw	r3, #28964	; 0x7124
    7124:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7128:	ea4f 1202 	mov.w	r2, r2, lsl #4
    712c:	4413      	add	r3, r2
    712e:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
    7132:	f103 030c 	add.w	r3, r3, #12
    7136:	681b      	ldr	r3, [r3, #0]
    7138:	613b      	str	r3, [r7, #16]
        if( (desc & TDES0_LO) != 0u ) {
    713a:	693b      	ldr	r3, [r7, #16]
    713c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    7140:	2b00      	cmp	r3, #0
    7142:	d013      	beq.n	716c <MSS_MAC_tx_packet+0x2c4>
	        g_mss_mac.statistics.tx_loss_of_carrier++;
    7144:	f247 1324 	movw	r3, #28964	; 0x7124
    7148:	f2c2 0300 	movt	r3, #8192	; 0x2000
    714c:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7150:	f103 0334 	add.w	r3, r3, #52	; 0x34
    7154:	681b      	ldr	r3, [r3, #0]
    7156:	f103 0201 	add.w	r2, r3, #1
    715a:	f247 1324 	movw	r3, #28964	; 0x7124
    715e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7162:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7166:	f103 0334 	add.w	r3, r3, #52	; 0x34
    716a:	601a      	str	r2, [r3, #0]
        }
        if( (desc & TDES0_NC) != 0u ) {
    716c:	693b      	ldr	r3, [r7, #16]
    716e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    7172:	2b00      	cmp	r3, #0
    7174:	d013      	beq.n	719e <MSS_MAC_tx_packet+0x2f6>
	        g_mss_mac.statistics.tx_no_carrier++;
    7176:	f247 1324 	movw	r3, #28964	; 0x7124
    717a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    717e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7182:	f103 0338 	add.w	r3, r3, #56	; 0x38
    7186:	681b      	ldr	r3, [r3, #0]
    7188:	f103 0201 	add.w	r2, r3, #1
    718c:	f247 1324 	movw	r3, #28964	; 0x7124
    7190:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7194:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7198:	f103 0338 	add.w	r3, r3, #56	; 0x38
    719c:	601a      	str	r2, [r3, #0]
        }
        if( (desc & TDES0_LC) != 0u ) {
    719e:	693b      	ldr	r3, [r7, #16]
    71a0:	f403 7300 	and.w	r3, r3, #512	; 0x200
    71a4:	2b00      	cmp	r3, #0
    71a6:	d013      	beq.n	71d0 <MSS_MAC_tx_packet+0x328>
	        g_mss_mac.statistics.tx_late_collision++;
    71a8:	f247 1324 	movw	r3, #28964	; 0x7124
    71ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    71b0:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    71b4:	f103 033c 	add.w	r3, r3, #60	; 0x3c
    71b8:	681b      	ldr	r3, [r3, #0]
    71ba:	f103 0201 	add.w	r2, r3, #1
    71be:	f247 1324 	movw	r3, #28964	; 0x7124
    71c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    71c6:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    71ca:	f103 033c 	add.w	r3, r3, #60	; 0x3c
    71ce:	601a      	str	r2, [r3, #0]
        }
        if( (desc & TDES0_EC) != 0u ) {
    71d0:	693b      	ldr	r3, [r7, #16]
    71d2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    71d6:	2b00      	cmp	r3, #0
    71d8:	d00f      	beq.n	71fa <MSS_MAC_tx_packet+0x352>
	        g_mss_mac.statistics.tx_excessive_collision++;
    71da:	f247 1324 	movw	r3, #28964	; 0x7124
    71de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    71e2:	f503 5313 	add.w	r3, r3, #9408	; 0x24c0
    71e6:	681b      	ldr	r3, [r3, #0]
    71e8:	f103 0201 	add.w	r2, r3, #1
    71ec:	f247 1324 	movw	r3, #28964	; 0x7124
    71f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    71f4:	f503 5313 	add.w	r3, r3, #9408	; 0x24c0
    71f8:	601a      	str	r2, [r3, #0]
        }
        if( (desc & TDES0_UF) != 0u ) {
    71fa:	693b      	ldr	r3, [r7, #16]
    71fc:	f003 0302 	and.w	r3, r3, #2
    7200:	2b00      	cmp	r3, #0
    7202:	d013      	beq.n	722c <MSS_MAC_tx_packet+0x384>
	        g_mss_mac.statistics.tx_underflow_error++;
    7204:	f247 1324 	movw	r3, #28964	; 0x7124
    7208:	f2c2 0300 	movt	r3, #8192	; 0x2000
    720c:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7210:	f103 0348 	add.w	r3, r3, #72	; 0x48
    7214:	681b      	ldr	r3, [r3, #0]
    7216:	f103 0201 	add.w	r2, r3, #1
    721a:	f247 1324 	movw	r3, #28964	; 0x7124
    721e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7222:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7226:	f103 0348 	add.w	r3, r3, #72	; 0x48
    722a:	601a      	str	r2, [r3, #0]
        }
        g_mss_mac.statistics.tx_collision_count +=
    722c:	f247 1324 	movw	r3, #28964	; 0x7124
    7230:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7234:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7238:	f103 0344 	add.w	r3, r3, #68	; 0x44
    723c:	681a      	ldr	r2, [r3, #0]
	        (desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;
    723e:	693b      	ldr	r3, [r7, #16]
    7240:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    7244:	f003 030f 	and.w	r3, r3, #15
	        g_mss_mac.statistics.tx_excessive_collision++;
        }
        if( (desc & TDES0_UF) != 0u ) {
	        g_mss_mac.statistics.tx_underflow_error++;
        }
        g_mss_mac.statistics.tx_collision_count +=
    7248:	441a      	add	r2, r3
    724a:	f247 1324 	movw	r3, #28964	; 0x7124
    724e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7252:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7256:	f103 0344 	add.w	r3, r3, #68	; 0x44
    725a:	601a      	str	r2, [r3, #0]
	        (desc >> TDES0_CC_OFFSET) & TDES0_CC_MASK;

        /* Give ownership of descriptor to the MAC */
        g_mss_mac.tx_descriptors[ g_mss_mac.tx_desc_index ].descriptor_0 = RDES0_OWN;
    725c:	f247 1324 	movw	r3, #28964	; 0x7124
    7260:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7264:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    7266:	f247 1324 	movw	r3, #28964	; 0x7124
    726a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    726e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7272:	4413      	add	r3, r2
    7274:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
    7278:	f103 030c 	add.w	r3, r3, #12
    727c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    7280:	601a      	str	r2, [r3, #0]

        g_mss_mac.tx_desc_index = (g_mss_mac.tx_desc_index + 1u) % (uint32_t)TX_RING_SIZE;
    7282:	f247 1324 	movw	r3, #28964	; 0x7124
    7286:	f2c2 0300 	movt	r3, #8192	; 0x2000
    728a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    728c:	f103 0301 	add.w	r3, r3, #1
    7290:	f003 0201 	and.w	r2, r3, #1
    7294:	f247 1324 	movw	r3, #28964	; 0x7124
    7298:	f2c2 0300 	movt	r3, #8192	; 0x2000
    729c:	671a      	str	r2, [r3, #112]	; 0x70

        /* Start transmission */
        MAC_start_transmission();
    729e:	f000 fe11 	bl	7ec4 <MAC_start_transmission>

        /* transmit poll demand */
        MAC->CSR1 = 1u;
    72a2:	f243 0300 	movw	r3, #12288	; 0x3000
    72a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    72aa:	f04f 0201 	mov.w	r2, #1
    72ae:	609a      	str	r2, [r3, #8]
    }
    
    if (error == MAC_OK)
    72b0:	697b      	ldr	r3, [r7, #20]
    72b2:	2b00      	cmp	r3, #0
    72b4:	d102      	bne.n	72bc <MSS_MAC_tx_packet+0x414>
    {
        error = (int32_t)pacLen;
    72b6:	897b      	ldrh	r3, [r7, #10]
    72b8:	617b      	str	r3, [r7, #20]
    72ba:	e002      	b.n	72c2 <MSS_MAC_tx_packet+0x41a>
    }
    else
    {
        error = 0;
    72bc:	f04f 0300 	mov.w	r3, #0
    72c0:	617b      	str	r3, [r7, #20]
    }
    return ( error );
    72c2:	697b      	ldr	r3, [r7, #20]
}
    72c4:	4618      	mov	r0, r3
    72c6:	f107 0718 	add.w	r7, r7, #24
    72ca:	46bd      	mov	sp, r7
    72cc:	bd80      	pop	{r7, pc}
    72ce:	bf00      	nop

000072d0 <MSS_MAC_rx_packet>:
(
    uint8_t *pacData,
    uint16_t pacLen,
    uint32_t time_out
)
{
    72d0:	b580      	push	{r7, lr}
    72d2:	b086      	sub	sp, #24
    72d4:	af00      	add	r7, sp, #0
    72d6:	60f8      	str	r0, [r7, #12]
    72d8:	460b      	mov	r3, r1
    72da:	607a      	str	r2, [r7, #4]
    72dc:	817b      	strh	r3, [r7, #10]
	uint16_t frame_length=0u;
    72de:	f04f 0300 	mov.w	r3, #0
    72e2:	82bb      	strh	r3, [r7, #20]
    int8_t exit=0;
    72e4:	f04f 0300 	mov.w	r3, #0
    72e8:	75fb      	strb	r3, [r7, #23]

    ASSERT( MAC_test_instance() == MAC_OK );
    72ea:	f000 faa7 	bl	783c <MAC_test_instance>
    72ee:	4603      	mov	r3, r0
    72f0:	2b00      	cmp	r3, #0
    72f2:	d000      	beq.n	72f6 <MSS_MAC_rx_packet+0x26>
    72f4:	be00      	bkpt	0x0000

    ASSERT( pacData != NULL_buffer );
    72f6:	f243 138c 	movw	r3, #12684	; 0x318c
    72fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    72fe:	681b      	ldr	r3, [r3, #0]
    7300:	68fa      	ldr	r2, [r7, #12]
    7302:	429a      	cmp	r2, r3
    7304:	d100      	bne.n	7308 <MSS_MAC_rx_packet+0x38>
    7306:	be00      	bkpt	0x0000

    ASSERT(  (time_out == MSS_MAC_BLOCKING) ||
    7308:	687b      	ldr	r3, [r7, #4]
    730a:	f1b3 3fff 	cmp.w	r3, #4294967295
    730e:	d00a      	beq.n	7326 <MSS_MAC_rx_packet+0x56>
    7310:	687b      	ldr	r3, [r7, #4]
    7312:	2b00      	cmp	r3, #0
    7314:	d007      	beq.n	7326 <MSS_MAC_rx_packet+0x56>
    7316:	687b      	ldr	r3, [r7, #4]
    7318:	2b00      	cmp	r3, #0
    731a:	d003      	beq.n	7324 <MSS_MAC_rx_packet+0x54>
    731c:	687b      	ldr	r3, [r7, #4]
    731e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    7322:	d900      	bls.n	7326 <MSS_MAC_rx_packet+0x56>
    7324:	be00      	bkpt	0x0000
    			(time_out == MSS_MAC_NONBLOCKING) ||
    			((time_out >= 1) && (time_out <= 0x01000000UL)) );

    MAC_dismiss_bad_frames();
    7326:	f000 fe19 	bl	7f5c <MAC_dismiss_bad_frames>

    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
    732a:	687b      	ldr	r3, [r7, #4]
    732c:	f1b3 3fff 	cmp.w	r3, #4294967295
    7330:	d018      	beq.n	7364 <MSS_MAC_rx_packet+0x94>
		if( time_out == MSS_MAC_NONBLOCKING ) {
    7332:	687b      	ldr	r3, [r7, #4]
    7334:	2b00      	cmp	r3, #0
    7336:	d104      	bne.n	7342 <MSS_MAC_rx_packet+0x72>
    		MAC_set_time_out( 0u );
    7338:	f04f 0000 	mov.w	r0, #0
    733c:	f000 fe60 	bl	8000 <MAC_set_time_out>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7340:	e011      	b.n	7366 <MSS_MAC_rx_packet+0x96>
    /* wait for a packet */
	if( time_out != MSS_MAC_BLOCKING ) {
		if( time_out == MSS_MAC_NONBLOCKING ) {
    		MAC_set_time_out( 0u );
		} else {
    		MAC_set_time_out( time_out );
    7342:	6878      	ldr	r0, [r7, #4]
    7344:	f000 fe5c 	bl	8000 <MAC_set_time_out>
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7348:	e00d      	b.n	7366 <MSS_MAC_rx_packet+0x96>
    	RDES0_OWN) != 0u) && (exit == 0) )
    {
    	if( time_out != MSS_MAC_BLOCKING )
    734a:	687b      	ldr	r3, [r7, #4]
    734c:	f1b3 3fff 	cmp.w	r3, #4294967295
    7350:	d009      	beq.n	7366 <MSS_MAC_rx_packet+0x96>
    	{
    		if( MAC_get_time_out() == 0u ) {
    7352:	f000 fe7d 	bl	8050 <MAC_get_time_out>
    7356:	4603      	mov	r3, r0
    7358:	2b00      	cmp	r3, #0
    735a:	d104      	bne.n	7366 <MSS_MAC_rx_packet+0x96>
    			exit = 1;
    735c:	f04f 0301 	mov.w	r3, #1
    7360:	75fb      	strb	r3, [r7, #23]
    7362:	e000      	b.n	7366 <MSS_MAC_rx_packet+0x96>
		} else {
    		MAC_set_time_out( time_out );
		}
	}

    while( ((g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7364:	bf00      	nop
    7366:	f247 1324 	movw	r3, #28964	; 0x7124
    736a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    736e:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    7372:	f247 1324 	movw	r3, #28964	; 0x7124
    7376:	f2c2 0300 	movt	r3, #8192	; 0x2000
    737a:	f502 7211 	add.w	r2, r2, #580	; 0x244
    737e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7382:	4413      	add	r3, r2
    7384:	681b      	ldr	r3, [r3, #0]
    7386:	2b00      	cmp	r3, #0
    7388:	da03      	bge.n	7392 <MSS_MAC_rx_packet+0xc2>
    738a:	f997 3017 	ldrsb.w	r3, [r7, #23]
    738e:	2b00      	cmp	r3, #0
    7390:	d0db      	beq.n	734a <MSS_MAC_rx_packet+0x7a>
    			exit = 1;
    		}
    	}
    }

    if(exit == 0)
    7392:	f997 3017 	ldrsb.w	r3, [r7, #23]
    7396:	2b00      	cmp	r3, #0
    7398:	d13d      	bne.n	7416 <MSS_MAC_rx_packet+0x146>
    {
        frame_length = ( (
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    739a:	f247 1324 	movw	r3, #28964	; 0x7124
    739e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73a2:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    73a6:	f247 1324 	movw	r3, #28964	; 0x7124
    73aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73ae:	f502 7211 	add.w	r2, r2, #580	; 0x244
    73b2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    73b6:	4413      	add	r3, r2
    73b8:	681b      	ldr	r3, [r3, #0]
    73ba:	ea4f 4313 	mov.w	r3, r3, lsr #16
    	}
    }

    if(exit == 0)
    {
        frame_length = ( (
    73be:	b29b      	uxth	r3, r3
    73c0:	ea4f 4383 	mov.w	r3, r3, lsl #18
    73c4:	ea4f 4393 	mov.w	r3, r3, lsr #18
    73c8:	82bb      	strh	r3, [r7, #20]
    	    g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 >>
    	    RDES0_FL_OFFSET ) & RDES0_FL_MASK );

        /* strip crc */
        frame_length -= 4u;
    73ca:	8abb      	ldrh	r3, [r7, #20]
    73cc:	f1a3 0304 	sub.w	r3, r3, #4
    73d0:	82bb      	strh	r3, [r7, #20]

        if( frame_length > pacLen ) {
    73d2:	8aba      	ldrh	r2, [r7, #20]
    73d4:	897b      	ldrh	r3, [r7, #10]
    73d6:	429a      	cmp	r2, r3
    73d8:	d902      	bls.n	73e0 <MSS_MAC_rx_packet+0x110>
        	return MAC_NOT_ENOUGH_SPACE;
    73da:	f06f 0304 	mvn.w	r3, #4
    73de:	e01b      	b.n	7418 <MSS_MAC_rx_packet+0x148>
        }
       
        MAC_memcpy( pacData,
    	        (uint8_t*)
    	        g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1,
    73e0:	f247 1324 	movw	r3, #28964	; 0x7124
    73e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73e8:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c

        if( frame_length > pacLen ) {
        	return MAC_NOT_ENOUGH_SPACE;
        }
       
        MAC_memcpy( pacData,
    73ec:	f247 1324 	movw	r3, #28964	; 0x7124
    73f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    73f4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    73f8:	4413      	add	r3, r2
    73fa:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    73fe:	f103 0348 	add.w	r3, r3, #72	; 0x48
    7402:	681b      	ldr	r3, [r3, #0]
    7404:	461a      	mov	r2, r3
    7406:	8abb      	ldrh	r3, [r7, #20]
    7408:	68f8      	ldr	r0, [r7, #12]
    740a:	4611      	mov	r1, r2
    740c:	461a      	mov	r2, r3
    740e:	f001 f81b 	bl	8448 <MAC_memcpy>
    	        (uint8_t*)
    	        g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].buffer_1,
    	        (uint32_t)frame_length );

        MSS_MAC_prepare_rx_descriptor();
    7412:	f000 fa51 	bl	78b8 <MSS_MAC_prepare_rx_descriptor>
       
    }
    return ((int32_t)frame_length);
    7416:	8abb      	ldrh	r3, [r7, #20]
}
    7418:	4618      	mov	r0, r3
    741a:	f107 0718 	add.w	r7, r7, #24
    741e:	46bd      	mov	sp, r7
    7420:	bd80      	pop	{r7, pc}
    7422:	bf00      	nop

00007424 <MSS_MAC_link_status>:
int32_t
MSS_MAC_link_status
(
    void
)
{
    7424:	b580      	push	{r7, lr}
    7426:	b082      	sub	sp, #8
    7428:	af00      	add	r7, sp, #0
	uint32_t link;

    ASSERT( MAC_test_instance() == MAC_OK );
    742a:	f000 fa07 	bl	783c <MAC_test_instance>
    742e:	4603      	mov	r3, r0
    7430:	2b00      	cmp	r3, #0
    7432:	d000      	beq.n	7436 <MSS_MAC_link_status+0x12>
    7434:	be00      	bkpt	0x0000

    link = PHY_link_status();
    7436:	f001 fa01 	bl	883c <PHY_link_status>
    743a:	4603      	mov	r3, r0
    743c:	607b      	str	r3, [r7, #4]
    if( link == MSS_MAC_LINK_STATUS_LINK ) {
    743e:	687b      	ldr	r3, [r7, #4]
    7440:	2b01      	cmp	r3, #1
    7442:	d106      	bne.n	7452 <MSS_MAC_link_status+0x2e>
    	link |= PHY_link_type();
    7444:	f001 fa12 	bl	886c <PHY_link_type>
    7448:	4603      	mov	r3, r0
    744a:	687a      	ldr	r2, [r7, #4]
    744c:	ea42 0303 	orr.w	r3, r2, r3
    7450:	607b      	str	r3, [r7, #4]
    }

    return ((int32_t)link);
    7452:	687b      	ldr	r3, [r7, #4]
}
    7454:	4618      	mov	r0, r3
    7456:	f107 0708 	add.w	r7, r7, #8
    745a:	46bd      	mov	sp, r7
    745c:	bd80      	pop	{r7, pc}
    745e:	bf00      	nop

00007460 <MSS_MAC_auto_setup_link>:
int32_t
MSS_MAC_auto_setup_link
(
    void
)
{
    7460:	b580      	push	{r7, lr}
    7462:	b082      	sub	sp, #8
    7464:	af00      	add	r7, sp, #0
	int32_t link;
    ASSERT( MAC_test_instance() == MAC_OK );
    7466:	f000 f9e9 	bl	783c <MAC_test_instance>
    746a:	4603      	mov	r3, r0
    746c:	2b00      	cmp	r3, #0
    746e:	d000      	beq.n	7472 <MSS_MAC_auto_setup_link+0x12>
    7470:	be00      	bkpt	0x0000

    PHY_auto_negotiate();
    7472:	f001 f987 	bl	8784 <PHY_auto_negotiate>

    link = MSS_MAC_link_status();
    7476:	f7ff ffd5 	bl	7424 <MSS_MAC_link_status>
    747a:	4603      	mov	r3, r0
    747c:	603b      	str	r3, [r7, #0]

    if( (link & MSS_MAC_LINK_STATUS_LINK) != 0u ) {
    747e:	683b      	ldr	r3, [r7, #0]
    7480:	f003 0301 	and.w	r3, r3, #1
    7484:	b2db      	uxtb	r3, r3
    7486:	2b00      	cmp	r3, #0
    7488:	d03f      	beq.n	750a <MSS_MAC_auto_setup_link+0xaa>
    	int32_t ret;
	    ret = MAC_stop_transmission();
    748a:	f000 fceb 	bl	7e64 <MAC_stop_transmission>
    748e:	4603      	mov	r3, r0
    7490:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    7492:	687b      	ldr	r3, [r7, #4]
    7494:	2b00      	cmp	r3, #0
    7496:	d00a      	beq.n	74ae <MSS_MAC_auto_setup_link+0x4e>
    7498:	687b      	ldr	r3, [r7, #4]
    749a:	b2da      	uxtb	r2, r3
    749c:	f247 1324 	movw	r3, #28964	; 0x7124
    74a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    74a4:	715a      	strb	r2, [r3, #5]
    74a6:	687b      	ldr	r3, [r7, #4]
    74a8:	2b00      	cmp	r3, #0
    74aa:	d000      	beq.n	74ae <MSS_MAC_auto_setup_link+0x4e>
    74ac:	be00      	bkpt	0x0000

	    ret = MAC_stop_receiving();
    74ae:	f000 fd17 	bl	7ee0 <MAC_stop_receiving>
    74b2:	4603      	mov	r3, r0
    74b4:	607b      	str	r3, [r7, #4]
	    MAC_CHECK( ret == MAC_OK, ret );
    74b6:	687b      	ldr	r3, [r7, #4]
    74b8:	2b00      	cmp	r3, #0
    74ba:	d00a      	beq.n	74d2 <MSS_MAC_auto_setup_link+0x72>
    74bc:	687b      	ldr	r3, [r7, #4]
    74be:	b2da      	uxtb	r2, r3
    74c0:	f247 1324 	movw	r3, #28964	; 0x7124
    74c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    74c8:	715a      	strb	r2, [r3, #5]
    74ca:	687b      	ldr	r3, [r7, #4]
    74cc:	2b00      	cmp	r3, #0
    74ce:	d000      	beq.n	74d2 <MSS_MAC_auto_setup_link+0x72>
    74d0:	be00      	bkpt	0x0000
        MAC_BITBAND->CSR6_TTM = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_100MB) != 0u) ? 1u : 0u );
    74d2:	f240 0300 	movw	r3, #0
    74d6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    74da:	683a      	ldr	r2, [r7, #0]
    74dc:	f002 0202 	and.w	r2, r2, #2
    74e0:	2a00      	cmp	r2, #0
    74e2:	d002      	beq.n	74ea <MSS_MAC_auto_setup_link+0x8a>
    74e4:	f04f 0201 	mov.w	r2, #1
    74e8:	e001      	b.n	74ee <MSS_MAC_auto_setup_link+0x8e>
    74ea:	f04f 0200 	mov.w	r2, #0
    74ee:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
        MAC_BITBAND->CSR6_FD = (uint32_t)((((uint32_t)link & MSS_MAC_LINK_STATUS_FDX) != 0u) ? 1u : 1u );
    74f2:	f240 0300 	movw	r3, #0
    74f6:	f2c4 2306 	movt	r3, #16902	; 0x4206
    74fa:	f04f 0201 	mov.w	r2, #1
    74fe:	f8c3 2624 	str.w	r2, [r3, #1572]	; 0x624
	    MAC_start_transmission();
    7502:	f000 fcdf 	bl	7ec4 <MAC_start_transmission>
	    MAC_start_receiving();
    7506:	f000 fd1b 	bl	7f40 <MAC_start_receiving>
    }

    return link;
    750a:	683b      	ldr	r3, [r7, #0]
}
    750c:	4618      	mov	r0, r3
    750e:	f107 0708 	add.w	r7, r7, #8
    7512:	46bd      	mov	sp, r7
    7514:	bd80      	pop	{r7, pc}
    7516:	bf00      	nop

00007518 <MSS_MAC_set_mac_address>:
void
MSS_MAC_set_mac_address
(
    const uint8_t *new_address
)
{
    7518:	b580      	push	{r7, lr}
    751a:	b084      	sub	sp, #16
    751c:	af00      	add	r7, sp, #0
    751e:	6078      	str	r0, [r7, #4]
    ASSERT( MAC_test_instance() == MAC_OK );
    7520:	f000 f98c 	bl	783c <MAC_test_instance>
    7524:	4603      	mov	r3, r0
    7526:	2b00      	cmp	r3, #0
    7528:	d000      	beq.n	752c <MSS_MAC_set_mac_address+0x14>
    752a:	be00      	bkpt	0x0000
    /* Check if the new address is unicast */
    ASSERT( (new_address[0]&1) == 0 );
    752c:	687b      	ldr	r3, [r7, #4]
    752e:	781b      	ldrb	r3, [r3, #0]
    7530:	f003 0301 	and.w	r3, r3, #1
    7534:	2b00      	cmp	r3, #0
    7536:	d000      	beq.n	753a <MSS_MAC_set_mac_address+0x22>
    7538:	be00      	bkpt	0x0000

   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );
    753a:	481c      	ldr	r0, [pc, #112]	; (75ac <MSS_MAC_set_mac_address+0x94>)
    753c:	6879      	ldr	r1, [r7, #4]
    753e:	f04f 0206 	mov.w	r2, #6
    7542:	f000 ff81 	bl	8448 <MAC_memcpy>

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    7546:	f247 1324 	movw	r3, #28964	; 0x7124
    754a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    754e:	791b      	ldrb	r3, [r3, #4]
    7550:	f003 0302 	and.w	r3, r3, #2
    7554:	2b00      	cmp	r3, #0
    7556:	d023      	beq.n	75a0 <MSS_MAC_set_mac_address+0x88>
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    7558:	f04f 0354 	mov.w	r3, #84	; 0x54
    755c:	60fb      	str	r3, [r7, #12]
    755e:	e01c      	b.n	759a <MSS_MAC_set_mac_address+0x82>
			if( (g_mss_mac.mac_filter_data[a] & 1u) != 0u ) {
    7560:	68fa      	ldr	r2, [r7, #12]
    7562:	f247 1324 	movw	r3, #28964	; 0x7124
    7566:	f2c2 0300 	movt	r3, #8192	; 0x2000
    756a:	4413      	add	r3, r2
    756c:	7b1b      	ldrb	r3, [r3, #12]
    756e:	f003 0301 	and.w	r3, r3, #1
    7572:	b2db      	uxtb	r3, r3
    7574:	2b00      	cmp	r3, #0
    7576:	d003      	beq.n	7580 <MSS_MAC_set_mac_address+0x68>
				/* Filters with multicast addresses are used */
				a = -1;
    7578:	f04f 33ff 	mov.w	r3, #4294967295
    757c:	60fb      	str	r3, [r7, #12]
    757e:	e008      	b.n	7592 <MSS_MAC_set_mac_address+0x7a>
			} else {
				MAC_memcpy( &(g_mss_mac.mac_filter_data[a]),
    7580:	68fa      	ldr	r2, [r7, #12]
    7582:	4b0b      	ldr	r3, [pc, #44]	; (75b0 <MSS_MAC_set_mac_address+0x98>)
    7584:	4413      	add	r3, r2
    7586:	4618      	mov	r0, r3
    7588:	4908      	ldr	r1, [pc, #32]	; (75ac <MSS_MAC_set_mac_address+0x94>)
    758a:	f04f 0206 	mov.w	r2, #6
    758e:	f000 ff5b 	bl	8448 <MAC_memcpy>
   	MAC_memcpy( g_mss_mac.mac_address, new_address, 6u );

   	if((g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
		int32_t a;
	   	/* set unused filters to the new mac address */
		for( a=14*6; a>=0; a-=6 ) {
    7592:	68fb      	ldr	r3, [r7, #12]
    7594:	f1a3 0306 	sub.w	r3, r3, #6
    7598:	60fb      	str	r3, [r7, #12]
    759a:	68fb      	ldr	r3, [r7, #12]
    759c:	2b00      	cmp	r3, #0
    759e:	dadf      	bge.n	7560 <MSS_MAC_set_mac_address+0x48>
					g_mss_mac.mac_address, 6u );
			}
		}
   	}

   	MAC_send_setup_frame();
    75a0:	f000 fac8 	bl	7b34 <MAC_send_setup_frame>
}
    75a4:	f107 0710 	add.w	r7, r7, #16
    75a8:	46bd      	mov	sp, r7
    75aa:	bd80      	pop	{r7, pc}
    75ac:	2000712a 	.word	0x2000712a
    75b0:	20007130 	.word	0x20007130

000075b4 <MSS_MAC_set_mac_filters>:
MSS_MAC_set_mac_filters
(
	uint16_t filter_count,
	const uint8_t *filters
)
{
    75b4:	b580      	push	{r7, lr}
    75b6:	b088      	sub	sp, #32
    75b8:	af00      	add	r7, sp, #0
    75ba:	4603      	mov	r3, r0
    75bc:	6039      	str	r1, [r7, #0]
    75be:	80fb      	strh	r3, [r7, #6]
    ASSERT( MAC_test_instance() == MAC_OK );
    75c0:	f000 f93c 	bl	783c <MAC_test_instance>
    75c4:	4603      	mov	r3, r0
    75c6:	2b00      	cmp	r3, #0
    75c8:	d000      	beq.n	75cc <MSS_MAC_set_mac_filters+0x18>
    75ca:	be00      	bkpt	0x0000
    ASSERT( (filter_count==0) || (filters != NULL_buffer) );
    75cc:	88fb      	ldrh	r3, [r7, #6]
    75ce:	2b00      	cmp	r3, #0
    75d0:	d008      	beq.n	75e4 <MSS_MAC_set_mac_filters+0x30>
    75d2:	f243 138c 	movw	r3, #12684	; 0x318c
    75d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    75da:	681b      	ldr	r3, [r3, #0]
    75dc:	683a      	ldr	r2, [r7, #0]
    75de:	429a      	cmp	r2, r3
    75e0:	d100      	bne.n	75e4 <MSS_MAC_set_mac_filters+0x30>
    75e2:	be00      	bkpt	0x0000
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    75e4:	f04f 0300 	mov.w	r3, #0
    75e8:	60fb      	str	r3, [r7, #12]
    75ea:	e013      	b.n	7614 <MSS_MAC_set_mac_filters+0x60>
    		ASSERT( (filters[a*6]&1) == 1 );
    75ec:	68fa      	ldr	r2, [r7, #12]
    75ee:	4613      	mov	r3, r2
    75f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    75f4:	4413      	add	r3, r2
    75f6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    75fa:	461a      	mov	r2, r3
    75fc:	683b      	ldr	r3, [r7, #0]
    75fe:	4413      	add	r3, r2
    7600:	781b      	ldrb	r3, [r3, #0]
    7602:	f003 0301 	and.w	r3, r3, #1
    7606:	2b00      	cmp	r3, #0
    7608:	d100      	bne.n	760c <MSS_MAC_set_mac_filters+0x58>
    760a:	be00      	bkpt	0x0000
    ASSERT( MAC_test_instance() == MAC_OK );
    ASSERT( (filter_count==0) || (filters != NULL_buffer) );
    /* Check if the mac addresses is multicast */
    {
    	int32_t a;
    	for( a = 0u; a < filter_count; a++ ) {
    760c:	68fb      	ldr	r3, [r7, #12]
    760e:	f103 0301 	add.w	r3, r3, #1
    7612:	60fb      	str	r3, [r7, #12]
    7614:	88fa      	ldrh	r2, [r7, #6]
    7616:	68fb      	ldr	r3, [r7, #12]
    7618:	429a      	cmp	r2, r3
    761a:	dce7      	bgt.n	75ec <MSS_MAC_set_mac_filters+0x38>
    		ASSERT( (filters[a*6]&1) == 1 );
    	}
    }

    if( filter_count <= 15 ){
    761c:	88fb      	ldrh	r3, [r7, #6]
    761e:	2b0f      	cmp	r3, #15
    7620:	d833      	bhi.n	768a <MSS_MAC_set_mac_filters+0xd6>
    	int32_t a;
    	g_mss_mac.flags |= FLAG_PERFECT_FILTERING;
    7622:	f247 1324 	movw	r3, #28964	; 0x7124
    7626:	f2c2 0300 	movt	r3, #8192	; 0x2000
    762a:	791b      	ldrb	r3, [r3, #4]
    762c:	f043 0302 	orr.w	r3, r3, #2
    7630:	b2da      	uxtb	r2, r3
    7632:	f247 1324 	movw	r3, #28964	; 0x7124
    7636:	f2c2 0300 	movt	r3, #8192	; 0x2000
    763a:	711a      	strb	r2, [r3, #4]

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));
    763c:	88fa      	ldrh	r2, [r7, #6]
    763e:	4613      	mov	r3, r2
    7640:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7644:	4413      	add	r3, r2
    7646:	ea4f 0343 	mov.w	r3, r3, lsl #1
    764a:	483c      	ldr	r0, [pc, #240]	; (773c <MSS_MAC_set_mac_filters+0x188>)
    764c:	6839      	ldr	r1, [r7, #0]
    764e:	461a      	mov	r2, r3
    7650:	f000 fefa 	bl	8448 <MAC_memcpy>

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    7654:	88fb      	ldrh	r3, [r7, #6]
    7656:	613b      	str	r3, [r7, #16]
    7658:	e013      	b.n	7682 <MSS_MAC_set_mac_filters+0xce>
   			MAC_memcpy( &(g_mss_mac.mac_filter_data[a*6]),
    765a:	693a      	ldr	r2, [r7, #16]
    765c:	4613      	mov	r3, r2
    765e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7662:	4413      	add	r3, r2
    7664:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7668:	461a      	mov	r2, r3
    766a:	4b34      	ldr	r3, [pc, #208]	; (773c <MSS_MAC_set_mac_filters+0x188>)
    766c:	4413      	add	r3, r2
    766e:	4618      	mov	r0, r3
    7670:	4933      	ldr	r1, [pc, #204]	; (7740 <MSS_MAC_set_mac_filters+0x18c>)
    7672:	f04f 0206 	mov.w	r2, #6
    7676:	f000 fee7 	bl	8448 <MAC_memcpy>

    	/* copy new filters */
    	MAC_memcpy( g_mss_mac.mac_filter_data, filters, (uint32_t)(filter_count*6));

    	/* set unused filters to our mac address */
    	for( a=filter_count; a<15; a++ ) {
    767a:	693b      	ldr	r3, [r7, #16]
    767c:	f103 0301 	add.w	r3, r3, #1
    7680:	613b      	str	r3, [r7, #16]
    7682:	693b      	ldr	r3, [r7, #16]
    7684:	2b0e      	cmp	r3, #14
    7686:	dde8      	ble.n	765a <MSS_MAC_set_mac_filters+0xa6>
    7688:	e052      	b.n	7730 <MSS_MAC_set_mac_filters+0x17c>
    	}
    } else {
    	int32_t a,b;
    	uint32_t hash;

    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;
    768a:	f247 1324 	movw	r3, #28964	; 0x7124
    768e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7692:	791b      	ldrb	r3, [r3, #4]
    7694:	461a      	mov	r2, r3
    7696:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    769a:	f247 1324 	movw	r3, #28964	; 0x7124
    769e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76a2:	711a      	strb	r2, [r3, #4]

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );
    76a4:	4825      	ldr	r0, [pc, #148]	; (773c <MSS_MAC_set_mac_filters+0x188>)
    76a6:	f04f 0100 	mov.w	r1, #0
    76aa:	f04f 0240 	mov.w	r2, #64	; 0x40
    76ae:	f000 fd49 	bl	8144 <MAC_memset>

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    76b2:	f04f 0300 	mov.w	r3, #0
    76b6:	617b      	str	r3, [r7, #20]
    76b8:	f04f 0300 	mov.w	r3, #0
    76bc:	61bb      	str	r3, [r7, #24]
    76be:	e033      	b.n	7728 <MSS_MAC_set_mac_filters+0x174>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    76c0:	69ba      	ldr	r2, [r7, #24]
    76c2:	683b      	ldr	r3, [r7, #0]
    76c4:	4413      	add	r3, r2
    76c6:	4618      	mov	r0, r3
    76c8:	f04f 0106 	mov.w	r1, #6
    76cc:	f001 fa70 	bl	8bb0 <mss_ethernet_crc>
    76d0:	4603      	mov	r3, r0
    76d2:	ea4f 53c3 	mov.w	r3, r3, lsl #23
    76d6:	ea4f 53d3 	mov.w	r3, r3, lsr #23
    76da:	61fb      	str	r3, [r7, #28]
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    76dc:	69fb      	ldr	r3, [r7, #28]
    76de:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    76e2:	4619      	mov	r1, r3
    76e4:	461a      	mov	r2, r3
    76e6:	f247 1324 	movw	r3, #28964	; 0x7124
    76ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76ee:	4413      	add	r3, r2
    76f0:	7b1b      	ldrb	r3, [r3, #12]
    76f2:	461a      	mov	r2, r3
    76f4:	69fb      	ldr	r3, [r7, #28]
    76f6:	f003 0307 	and.w	r3, r3, #7
    76fa:	f04f 0001 	mov.w	r0, #1
    76fe:	fa00 f303 	lsl.w	r3, r0, r3
    7702:	b2db      	uxtb	r3, r3
    7704:	ea42 0303 	orr.w	r3, r2, r3
    7708:	b2db      	uxtb	r3, r3
    770a:	b2da      	uxtb	r2, r3
    770c:	f247 1324 	movw	r3, #28964	; 0x7124
    7710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7714:	440b      	add	r3, r1
    7716:	731a      	strb	r2, [r3, #12]
    	g_mss_mac.flags &= ~FLAG_PERFECT_FILTERING;

    	/* reset hash table */
    	MAC_memset( g_mss_mac.mac_filter_data, 0u, 64u );

    	for( a=0, b=0; a<filter_count; a++, b+=6 ) {
    7718:	697b      	ldr	r3, [r7, #20]
    771a:	f103 0301 	add.w	r3, r3, #1
    771e:	617b      	str	r3, [r7, #20]
    7720:	69bb      	ldr	r3, [r7, #24]
    7722:	f103 0306 	add.w	r3, r3, #6
    7726:	61bb      	str	r3, [r7, #24]
    7728:	88fa      	ldrh	r2, [r7, #6]
    772a:	697b      	ldr	r3, [r7, #20]
    772c:	429a      	cmp	r2, r3
    772e:	dcc7      	bgt.n	76c0 <MSS_MAC_set_mac_filters+0x10c>
    		hash = mss_ethernet_crc( &(filters[b]), 6 ) & 0x1FF;
    		g_mss_mac.mac_filter_data[ hash / 8 ] |= 1 << (hash & 0x7);
    	}
    }

    MAC_send_setup_frame();
    7730:	f000 fa00 	bl	7b34 <MAC_send_setup_frame>
}
    7734:	f107 0720 	add.w	r7, r7, #32
    7738:	46bd      	mov	sp, r7
    773a:	bd80      	pop	{r7, pc}
    773c:	20007130 	.word	0x20007130
    7740:	2000712a 	.word	0x2000712a

00007744 <EthernetMAC_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void EthernetMAC_IRQHandler( void )
#else
void EthernetMAC_IRQHandler( void )
#endif
{
    7744:	4668      	mov	r0, sp
    7746:	f020 0107 	bic.w	r1, r0, #7
    774a:	468d      	mov	sp, r1
    774c:	b581      	push	{r0, r7, lr}
    774e:	b083      	sub	sp, #12
    7750:	af00      	add	r7, sp, #0
    uint32_t events;
    uint32_t intr_status;

    ASSERT( MAC_test_instance() == MAC_OK );
    7752:	f000 f873 	bl	783c <MAC_test_instance>
    7756:	4603      	mov	r3, r0
    7758:	2b00      	cmp	r3, #0
    775a:	d000      	beq.n	775e <EthernetMAC_IRQHandler+0x1a>
    775c:	be00      	bkpt	0x0000

    events = 0u;
    775e:	f04f 0300 	mov.w	r3, #0
    7762:	603b      	str	r3, [r7, #0]
    intr_status = MAC->CSR5;
    7764:	f243 0300 	movw	r3, #12288	; 0x3000
    7768:	f2c4 0300 	movt	r3, #16384	; 0x4000
    776c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    776e:	607b      	str	r3, [r7, #4]

    if( (intr_status & CSR5_NIS_MASK) != 0u ) {
    7770:	687b      	ldr	r3, [r7, #4]
    7772:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    7776:	2b00      	cmp	r3, #0
    7778:	d03a      	beq.n	77f0 <EthernetMAC_IRQHandler+0xac>
    	if( (intr_status & CSR5_TI_MASK) != 0u ) { /* Transmit */
    777a:	687b      	ldr	r3, [r7, #4]
    777c:	f003 0301 	and.w	r3, r3, #1
    7780:	b2db      	uxtb	r3, r3
    7782:	2b00      	cmp	r3, #0
    7784:	d017      	beq.n	77b6 <EthernetMAC_IRQHandler+0x72>
    		g_mss_mac.statistics.tx_interrupts++;
    7786:	f247 1324 	movw	r3, #28964	; 0x7124
    778a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    778e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7792:	f103 0330 	add.w	r3, r3, #48	; 0x30
    7796:	681b      	ldr	r3, [r3, #0]
    7798:	f103 0201 	add.w	r2, r3, #1
    779c:	f247 1324 	movw	r3, #28964	; 0x7124
    77a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77a4:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    77a8:	f103 0330 	add.w	r3, r3, #48	; 0x30
    77ac:	601a      	str	r2, [r3, #0]
    		events |= MSS_MAC_EVENT_PACKET_SEND;
    77ae:	683b      	ldr	r3, [r7, #0]
    77b0:	f043 0301 	orr.w	r3, r3, #1
    77b4:	603b      	str	r3, [r7, #0]
    	}

    	if( (intr_status & CSR5_RI_MASK) != 0u ) { /* Receive */
    77b6:	687b      	ldr	r3, [r7, #4]
    77b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    77bc:	2b00      	cmp	r3, #0
    77be:	d017      	beq.n	77f0 <EthernetMAC_IRQHandler+0xac>
    		g_mss_mac.statistics.rx_interrupts++;
    77c0:	f247 1324 	movw	r3, #28964	; 0x7124
    77c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77c8:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    77cc:	f103 0304 	add.w	r3, r3, #4
    77d0:	681b      	ldr	r3, [r3, #0]
    77d2:	f103 0201 	add.w	r2, r3, #1
    77d6:	f247 1324 	movw	r3, #28964	; 0x7124
    77da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    77de:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    77e2:	f103 0304 	add.w	r3, r3, #4
    77e6:	601a      	str	r2, [r3, #0]
    		events |= MSS_MAC_EVENT_PACKET_RECEIVED;
    77e8:	683b      	ldr	r3, [r7, #0]
    77ea:	f043 0302 	orr.w	r3, r3, #2
    77ee:	603b      	str	r3, [r7, #0]
    	}
    }

    /* Clear interrupts */
    MAC->CSR5 = CSR5_INT_BITS;
    77f0:	f243 0300 	movw	r3, #12288	; 0x3000
    77f4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    77f8:	f64c 52e7 	movw	r2, #52711	; 0xcde7
    77fc:	f2c0 0201 	movt	r2, #1
    7800:	629a      	str	r2, [r3, #40]	; 0x28
    
    if( (events != 0u) && (g_mss_mac.listener != NULL_callback) ) {
    7802:	683b      	ldr	r3, [r7, #0]
    7804:	2b00      	cmp	r3, #0
    7806:	d012      	beq.n	782e <EthernetMAC_IRQHandler+0xea>
    7808:	f247 1324 	movw	r3, #28964	; 0x7124
    780c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7810:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    7812:	f243 1390 	movw	r3, #12688	; 0x3190
    7816:	f2c2 0300 	movt	r3, #8192	; 0x2000
    781a:	681b      	ldr	r3, [r3, #0]
    781c:	429a      	cmp	r2, r3
    781e:	d006      	beq.n	782e <EthernetMAC_IRQHandler+0xea>
        g_mss_mac.listener( events );
    7820:	f247 1324 	movw	r3, #28964	; 0x7124
    7824:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7828:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    782a:	6838      	ldr	r0, [r7, #0]
    782c:	4798      	blx	r3
    }
}
    782e:	f107 070c 	add.w	r7, r7, #12
    7832:	46bd      	mov	sp, r7
    7834:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
    7838:	4685      	mov	sp, r0
    783a:	4770      	bx	lr

0000783c <MAC_test_instance>:
static int32_t
MAC_test_instance
(
    void
)
{
    783c:	b480      	push	{r7}
    783e:	b085      	sub	sp, #20
    7840:	af00      	add	r7, sp, #0
    uint32_t val1;
    uint32_t val2;
    int32_t retval = MAC_WRONG_PARAMETER;
    7842:	f06f 0301 	mvn.w	r3, #1
    7846:	60fb      	str	r3, [r7, #12]

    val1 = MAC->CSR3;
    7848:	f243 0300 	movw	r3, #12288	; 0x3000
    784c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7850:	699b      	ldr	r3, [r3, #24]
    7852:	607b      	str	r3, [r7, #4]
    val2 = MAC->CSR4;
    7854:	f243 0300 	movw	r3, #12288	; 0x3000
    7858:	f2c4 0300 	movt	r3, #16384	; 0x4000
    785c:	6a1b      	ldr	r3, [r3, #32]
    785e:	60bb      	str	r3, [r7, #8]

    if( (&g_mss_mac != NULL_instance) &&
    7860:	f243 1388 	movw	r3, #12680	; 0x3188
    7864:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7868:	681a      	ldr	r2, [r3, #0]
    786a:	f247 1324 	movw	r3, #28964	; 0x7124
    786e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7872:	429a      	cmp	r2, r3
    7874:	d014      	beq.n	78a0 <MAC_test_instance+0x64>
    	((g_mss_mac.flags & FLAG_MAC_INIT_DONE) != 0u) &&
    7876:	f247 1324 	movw	r3, #28964	; 0x7124
    787a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    787e:	791b      	ldrb	r3, [r3, #4]
    7880:	f003 0301 	and.w	r3, r3, #1
    int32_t retval = MAC_WRONG_PARAMETER;

    val1 = MAC->CSR3;
    val2 = MAC->CSR4;

    if( (&g_mss_mac != NULL_instance) &&
    7884:	b2db      	uxtb	r3, r3
    7886:	2b00      	cmp	r3, #0
    7888:	d00a      	beq.n	78a0 <MAC_test_instance+0x64>
    	((g_mss_mac.flags & FLAG_MAC_INIT_DONE) != 0u) &&
    	( val1 == (uint32_t)g_mss_mac.rx_descriptors) &&
    788a:	4b09      	ldr	r3, [pc, #36]	; (78b0 <MAC_test_instance+0x74>)
    int32_t retval = MAC_WRONG_PARAMETER;

    val1 = MAC->CSR3;
    val2 = MAC->CSR4;

    if( (&g_mss_mac != NULL_instance) &&
    788c:	687a      	ldr	r2, [r7, #4]
    788e:	429a      	cmp	r2, r3
    7890:	d106      	bne.n	78a0 <MAC_test_instance+0x64>
    	((g_mss_mac.flags & FLAG_MAC_INIT_DONE) != 0u) &&
    	( val1 == (uint32_t)g_mss_mac.rx_descriptors) &&
    	(val2 == (uint32_t)g_mss_mac.tx_descriptors ) )
    7892:	4b08      	ldr	r3, [pc, #32]	; (78b4 <MAC_test_instance+0x78>)
    int32_t retval = MAC_WRONG_PARAMETER;

    val1 = MAC->CSR3;
    val2 = MAC->CSR4;

    if( (&g_mss_mac != NULL_instance) &&
    7894:	68ba      	ldr	r2, [r7, #8]
    7896:	429a      	cmp	r2, r3
    7898:	d102      	bne.n	78a0 <MAC_test_instance+0x64>
    	((g_mss_mac.flags & FLAG_MAC_INIT_DONE) != 0u) &&
    	( val1 == (uint32_t)g_mss_mac.rx_descriptors) &&
    	(val2 == (uint32_t)g_mss_mac.tx_descriptors ) )
    {
    	retval = MAC_OK;
    789a:	f04f 0300 	mov.w	r3, #0
    789e:	60fb      	str	r3, [r7, #12]
    }
    return retval;
    78a0:	68fb      	ldr	r3, [r7, #12]
}
    78a2:	4618      	mov	r0, r3
    78a4:	f107 0714 	add.w	r7, r7, #20
    78a8:	46bd      	mov	sp, r7
    78aa:	bc80      	pop	{r7}
    78ac:	4770      	bx	lr
    78ae:	bf00      	nop
    78b0:	20009564 	.word	0x20009564
    78b4:	20007d70 	.word	0x20007d70

000078b8 <MSS_MAC_prepare_rx_descriptor>:
void
MSS_MAC_prepare_rx_descriptor
(
    void
)
{
    78b8:	b580      	push	{r7, lr}
    78ba:	b082      	sub	sp, #8
    78bc:	af00      	add	r7, sp, #0
	uint32_t desc;

	/* update counters */
	desc = g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0;
    78be:	f247 1324 	movw	r3, #28964	; 0x7124
    78c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    78c6:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    78ca:	f247 1324 	movw	r3, #28964	; 0x7124
    78ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    78d2:	f502 7211 	add.w	r2, r2, #580	; 0x244
    78d6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    78da:	4413      	add	r3, r2
    78dc:	681b      	ldr	r3, [r3, #0]
    78de:	607b      	str	r3, [r7, #4]
	if( (desc & RDES0_FF) != 0u ) {
    78e0:	687b      	ldr	r3, [r7, #4]
    78e2:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
    78e6:	2b00      	cmp	r3, #0
    78e8:	d013      	beq.n	7912 <MSS_MAC_prepare_rx_descriptor+0x5a>
		g_mss_mac.statistics.rx_filtering_fail++;
    78ea:	f247 1324 	movw	r3, #28964	; 0x7124
    78ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    78f2:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    78f6:	f103 0308 	add.w	r3, r3, #8
    78fa:	681b      	ldr	r3, [r3, #0]
    78fc:	f103 0201 	add.w	r2, r3, #1
    7900:	f247 1324 	movw	r3, #28964	; 0x7124
    7904:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7908:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    790c:	f103 0308 	add.w	r3, r3, #8
    7910:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_DE) != 0u ) {
    7912:	687b      	ldr	r3, [r7, #4]
    7914:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    7918:	2b00      	cmp	r3, #0
    791a:	d013      	beq.n	7944 <MSS_MAC_prepare_rx_descriptor+0x8c>
		g_mss_mac.statistics.rx_descriptor_error++;
    791c:	f247 1324 	movw	r3, #28964	; 0x7124
    7920:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7924:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7928:	f103 030c 	add.w	r3, r3, #12
    792c:	681b      	ldr	r3, [r3, #0]
    792e:	f103 0201 	add.w	r2, r3, #1
    7932:	f247 1324 	movw	r3, #28964	; 0x7124
    7936:	f2c2 0300 	movt	r3, #8192	; 0x2000
    793a:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    793e:	f103 030c 	add.w	r3, r3, #12
    7942:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_RF) != 0u ) {
    7944:	687b      	ldr	r3, [r7, #4]
    7946:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    794a:	2b00      	cmp	r3, #0
    794c:	d013      	beq.n	7976 <MSS_MAC_prepare_rx_descriptor+0xbe>
		g_mss_mac.statistics.rx_runt_frame++;
    794e:	f247 1324 	movw	r3, #28964	; 0x7124
    7952:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7956:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    795a:	f103 0310 	add.w	r3, r3, #16
    795e:	681b      	ldr	r3, [r3, #0]
    7960:	f103 0201 	add.w	r2, r3, #1
    7964:	f247 1324 	movw	r3, #28964	; 0x7124
    7968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    796c:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7970:	f103 0310 	add.w	r3, r3, #16
    7974:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_FS) == 0u ) {
    7976:	687b      	ldr	r3, [r7, #4]
    7978:	f403 7300 	and.w	r3, r3, #512	; 0x200
    797c:	2b00      	cmp	r3, #0
    797e:	d113      	bne.n	79a8 <MSS_MAC_prepare_rx_descriptor+0xf0>
		g_mss_mac.statistics.rx_not_first++;
    7980:	f247 1324 	movw	r3, #28964	; 0x7124
    7984:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7988:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    798c:	f103 0314 	add.w	r3, r3, #20
    7990:	681b      	ldr	r3, [r3, #0]
    7992:	f103 0201 	add.w	r2, r3, #1
    7996:	f247 1324 	movw	r3, #28964	; 0x7124
    799a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    799e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    79a2:	f103 0314 	add.w	r3, r3, #20
    79a6:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_LS) == 0u ) {
    79a8:	687b      	ldr	r3, [r7, #4]
    79aa:	f403 7380 	and.w	r3, r3, #256	; 0x100
    79ae:	2b00      	cmp	r3, #0
    79b0:	d113      	bne.n	79da <MSS_MAC_prepare_rx_descriptor+0x122>
		g_mss_mac.statistics.rx_not_last++;
    79b2:	f247 1324 	movw	r3, #28964	; 0x7124
    79b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79ba:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    79be:	f103 0318 	add.w	r3, r3, #24
    79c2:	681b      	ldr	r3, [r3, #0]
    79c4:	f103 0201 	add.w	r2, r3, #1
    79c8:	f247 1324 	movw	r3, #28964	; 0x7124
    79cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79d0:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    79d4:	f103 0318 	add.w	r3, r3, #24
    79d8:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_TL) != 0u ) {
    79da:	687b      	ldr	r3, [r7, #4]
    79dc:	f003 0380 	and.w	r3, r3, #128	; 0x80
    79e0:	2b00      	cmp	r3, #0
    79e2:	d013      	beq.n	7a0c <MSS_MAC_prepare_rx_descriptor+0x154>
		g_mss_mac.statistics.rx_frame_too_long++;
    79e4:	f247 1324 	movw	r3, #28964	; 0x7124
    79e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79ec:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    79f0:	f103 031c 	add.w	r3, r3, #28
    79f4:	681b      	ldr	r3, [r3, #0]
    79f6:	f103 0201 	add.w	r2, r3, #1
    79fa:	f247 1324 	movw	r3, #28964	; 0x7124
    79fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a02:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a06:	f103 031c 	add.w	r3, r3, #28
    7a0a:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_CS) != 0u ) {
    7a0c:	687b      	ldr	r3, [r7, #4]
    7a0e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7a12:	2b00      	cmp	r3, #0
    7a14:	d013      	beq.n	7a3e <MSS_MAC_prepare_rx_descriptor+0x186>
		g_mss_mac.statistics.rx_collision_seen++;
    7a16:	f247 1324 	movw	r3, #28964	; 0x7124
    7a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a1e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a22:	f103 0320 	add.w	r3, r3, #32
    7a26:	681b      	ldr	r3, [r3, #0]
    7a28:	f103 0201 	add.w	r2, r3, #1
    7a2c:	f247 1324 	movw	r3, #28964	; 0x7124
    7a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a34:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a38:	f103 0320 	add.w	r3, r3, #32
    7a3c:	601a      	str	r2, [r3, #0]
	}
	if( (desc & RDES0_CE) != 0u ) {
    7a3e:	687b      	ldr	r3, [r7, #4]
    7a40:	f003 0302 	and.w	r3, r3, #2
    7a44:	2b00      	cmp	r3, #0
    7a46:	d013      	beq.n	7a70 <MSS_MAC_prepare_rx_descriptor+0x1b8>
		g_mss_mac.statistics.rx_crc_error++;
    7a48:	f247 1324 	movw	r3, #28964	; 0x7124
    7a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a50:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a54:	f103 0324 	add.w	r3, r3, #36	; 0x24
    7a58:	681b      	ldr	r3, [r3, #0]
    7a5a:	f103 0201 	add.w	r2, r3, #1
    7a5e:	f247 1324 	movw	r3, #28964	; 0x7124
    7a62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a66:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a6a:	f103 0324 	add.w	r3, r3, #36	; 0x24
    7a6e:	601a      	str	r2, [r3, #0]
	}
    
	desc = MAC->CSR8;
    7a70:	f243 0300 	movw	r3, #12288	; 0x3000
    7a74:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7a78:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7a7a:	607b      	str	r3, [r7, #4]
	g_mss_mac.statistics.rx_fifo_overflow +=
    7a7c:	f247 1324 	movw	r3, #28964	; 0x7124
    7a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a84:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7a88:	f103 0328 	add.w	r3, r3, #40	; 0x28
    7a8c:	681a      	ldr	r2, [r3, #0]
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
    7a8e:	6879      	ldr	r1, [r7, #4]
    7a90:	f240 0300 	movw	r3, #0
    7a94:	f6c1 73fe 	movt	r3, #8190	; 0x1ffe
    7a98:	ea01 0303 	and.w	r3, r1, r3
    7a9c:	ea4f 4353 	mov.w	r3, r3, lsr #17
	if( (desc & RDES0_CE) != 0u ) {
		g_mss_mac.statistics.rx_crc_error++;
	}
    
	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
    7aa0:	441a      	add	r2, r3
    7aa2:	f247 1324 	movw	r3, #28964	; 0x7124
    7aa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7aaa:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7aae:	f103 0328 	add.w	r3, r3, #40	; 0x28
    7ab2:	601a      	str	r2, [r3, #0]
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    7ab4:	f247 1324 	movw	r3, #28964	; 0x7124
    7ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7abc:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7ac0:	f103 032c 	add.w	r3, r3, #44	; 0x2c
    7ac4:	681a      	ldr	r2, [r3, #0]
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));
    7ac6:	687b      	ldr	r3, [r7, #4]
    7ac8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    7acc:	f423 037e 	bic.w	r3, r3, #16646144	; 0xfe0000
	}
    
	desc = MAC->CSR8;
	g_mss_mac.statistics.rx_fifo_overflow +=
		(desc & (CSR8_OCO_MASK|CSR8_FOC_MASK)) >> CSR8_FOC_SHIFT;
	g_mss_mac.statistics.rx_missed_frame +=
    7ad0:	441a      	add	r2, r3
    7ad2:	f247 1324 	movw	r3, #28964	; 0x7124
    7ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7ada:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    7ade:	f103 032c 	add.w	r3, r3, #44	; 0x2c
    7ae2:	601a      	str	r2, [r3, #0]
		(desc & (CSR8_MFO_MASK|CSR8_MFC_MASK));

	/* Give ownership of descriptor to the MAC */
	g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 =
    7ae4:	f247 1324 	movw	r3, #28964	; 0x7124
    7ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7aec:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    7af0:	f247 1324 	movw	r3, #28964	; 0x7124
    7af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7af8:	f502 7211 	add.w	r2, r2, #580	; 0x244
    7afc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7b00:	4413      	add	r3, r2
    7b02:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    7b06:	601a      	str	r2, [r3, #0]
		RDES0_OWN;
	g_mss_mac.rx_desc_index = (g_mss_mac.rx_desc_index + 1u) % RX_RING_SIZE;
    7b08:	f247 1324 	movw	r3, #28964	; 0x7124
    7b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b10:	f8d3 3c6c 	ldr.w	r3, [r3, #3180]	; 0xc6c
    7b14:	f103 0301 	add.w	r3, r3, #1
    7b18:	f003 0203 	and.w	r2, r3, #3
    7b1c:	f247 1324 	movw	r3, #28964	; 0x7124
    7b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b24:	f8c3 2c6c 	str.w	r2, [r3, #3180]	; 0xc6c

	/* Start receive */
    MAC_start_receiving();
    7b28:	f000 fa0a 	bl	7f40 <MAC_start_receiving>
}
    7b2c:	f107 0708 	add.w	r7, r7, #8
    7b30:	46bd      	mov	sp, r7
    7b32:	bd80      	pop	{r7, pc}

00007b34 <MAC_send_setup_frame>:
static int32_t
MAC_send_setup_frame
(
    void
)
{
    7b34:	b580      	push	{r7, lr}
    7b36:	b0ba      	sub	sp, #232	; 0xe8
    7b38:	af00      	add	r7, sp, #0
	uint8_t *data;
	int32_t a,b,c,d;
	int32_t ret;

    /* prepare descriptor */
	descriptor.descriptor_0 = TDES0_OWN;
    7b3a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    7b3e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
	descriptor.descriptor_1 = TDES1_SET | TDES1_TER |
    7b42:	f240 03c0 	movw	r3, #192	; 0xc0
    7b46:	f6c0 2300 	movt	r3, #2560	; 0xa00
    7b4a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
		(sizeof(frame_data) << TDES1_TBS1_OFFSET);

	if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) == 0u ) {
    7b4e:	f247 1324 	movw	r3, #28964	; 0x7124
    7b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b56:	791b      	ldrb	r3, [r3, #4]
    7b58:	f003 0302 	and.w	r3, r3, #2
    7b5c:	2b00      	cmp	r3, #0
    7b5e:	d105      	bne.n	7b6c <MAC_send_setup_frame+0x38>
		descriptor.descriptor_1 |= TDES1_FT0;
    7b60:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
    7b64:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    7b68:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	}

	descriptor.buffer_1 = (uint32_t)frame_data;
    7b6c:	463b      	mov	r3, r7
    7b6e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	descriptor.buffer_2 = 0u;
    7b72:	f04f 0300 	mov.w	r3, #0
    7b76:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc

    /* prepare frame */
    if( (g_mss_mac.flags & FLAG_PERFECT_FILTERING) != 0u ) {
    7b7a:	f247 1324 	movw	r3, #28964	; 0x7124
    7b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7b82:	791b      	ldrb	r3, [r3, #4]
    7b84:	f003 0302 	and.w	r3, r3, #2
    7b88:	2b00      	cmp	r3, #0
    7b8a:	d00c      	beq.n	7ba6 <MAC_send_setup_frame+0x72>
    	b = 0;
    7b8c:	f04f 0300 	mov.w	r3, #0
    7b90:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    	d = 12;
    7b94:	f04f 030c 	mov.w	r3, #12
    7b98:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    	c = 90;
    7b9c:	f04f 035a 	mov.w	r3, #90	; 0x5a
    7ba0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    7ba4:	e00b      	b.n	7bbe <MAC_send_setup_frame+0x8a>
    } else {
    	b = 156;
    7ba6:	f04f 039c 	mov.w	r3, #156	; 0x9c
    7baa:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    	d = 0;
    7bae:	f04f 0300 	mov.w	r3, #0
    7bb2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    	c = 64;
    7bb6:	f04f 0340 	mov.w	r3, #64	; 0x40
    7bba:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    }

   	data = g_mss_mac.mac_address;
    7bbe:	4ba6      	ldr	r3, [pc, #664]	; (7e58 <MAC_send_setup_frame+0x324>)
    7bc0:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
   	frame_data[b] = data[0];
    7bc4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7bc8:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7bcc:	7812      	ldrb	r2, [r2, #0]
    7bce:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7bd2:	440b      	add	r3, r1
    7bd4:	f803 2ce8 	strb.w	r2, [r3, #-232]
   	frame_data[b+1] = data[1];
    7bd8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7bdc:	f103 0301 	add.w	r3, r3, #1
    7be0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7be4:	f102 0201 	add.w	r2, r2, #1
    7be8:	7812      	ldrb	r2, [r2, #0]
    7bea:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7bee:	440b      	add	r3, r1
    7bf0:	f803 2ce8 	strb.w	r2, [r3, #-232]
   	frame_data[b+4] = data[2];
    7bf4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7bf8:	f103 0304 	add.w	r3, r3, #4
    7bfc:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7c00:	f102 0202 	add.w	r2, r2, #2
    7c04:	7812      	ldrb	r2, [r2, #0]
    7c06:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7c0a:	440b      	add	r3, r1
    7c0c:	f803 2ce8 	strb.w	r2, [r3, #-232]
   	frame_data[b+5] = data[3];
    7c10:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7c14:	f103 0305 	add.w	r3, r3, #5
    7c18:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7c1c:	f102 0203 	add.w	r2, r2, #3
    7c20:	7812      	ldrb	r2, [r2, #0]
    7c22:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7c26:	440b      	add	r3, r1
    7c28:	f803 2ce8 	strb.w	r2, [r3, #-232]
   	frame_data[b+8] = data[4];
    7c2c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7c30:	f103 0308 	add.w	r3, r3, #8
    7c34:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7c38:	f102 0204 	add.w	r2, r2, #4
    7c3c:	7812      	ldrb	r2, [r2, #0]
    7c3e:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7c42:	440b      	add	r3, r1
    7c44:	f803 2ce8 	strb.w	r2, [r3, #-232]
   	frame_data[b+9] = data[5];
    7c48:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
    7c4c:	f103 0309 	add.w	r3, r3, #9
    7c50:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7c54:	f102 0205 	add.w	r2, r2, #5
    7c58:	7812      	ldrb	r2, [r2, #0]
    7c5a:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7c5e:	440b      	add	r3, r1
    7c60:	f803 2ce8 	strb.w	r2, [r3, #-232]

   	data = g_mss_mac.mac_filter_data;
    7c64:	4b7d      	ldr	r3, [pc, #500]	; (7e5c <MAC_send_setup_frame+0x328>)
    7c66:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    for( a = 0; a < c; ) {
    7c6a:	f04f 0300 	mov.w	r3, #0
    7c6e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    7c72:	e081      	b.n	7d78 <MAC_send_setup_frame+0x244>
		frame_data[d] = data[a++];
    7c74:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7c78:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7c7c:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7c80:	440a      	add	r2, r1
    7c82:	7812      	ldrb	r2, [r2, #0]
    7c84:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7c88:	440b      	add	r3, r1
    7c8a:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7c8e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7c92:	f103 0301 	add.w	r3, r3, #1
    7c96:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	frame_data[d+1] = data[a++];
    7c9a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7c9e:	f103 0301 	add.w	r3, r3, #1
    7ca2:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7ca6:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7caa:	440a      	add	r2, r1
    7cac:	7812      	ldrb	r2, [r2, #0]
    7cae:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7cb2:	440b      	add	r3, r1
    7cb4:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7cb8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7cbc:	f103 0301 	add.w	r3, r3, #1
    7cc0:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	frame_data[d+4] = data[a++];
    7cc4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7cc8:	f103 0304 	add.w	r3, r3, #4
    7ccc:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7cd0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7cd4:	440a      	add	r2, r1
    7cd6:	7812      	ldrb	r2, [r2, #0]
    7cd8:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7cdc:	440b      	add	r3, r1
    7cde:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7ce2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7ce6:	f103 0301 	add.w	r3, r3, #1
    7cea:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	frame_data[d+5] = data[a++];
    7cee:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7cf2:	f103 0305 	add.w	r3, r3, #5
    7cf6:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7cfa:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7cfe:	440a      	add	r2, r1
    7d00:	7812      	ldrb	r2, [r2, #0]
    7d02:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7d06:	440b      	add	r3, r1
    7d08:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7d0c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7d10:	f103 0301 	add.w	r3, r3, #1
    7d14:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	frame_data[d+8] = data[a++];
    7d18:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7d1c:	f103 0308 	add.w	r3, r3, #8
    7d20:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7d24:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7d28:	440a      	add	r2, r1
    7d2a:	7812      	ldrb	r2, [r2, #0]
    7d2c:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7d30:	440b      	add	r3, r1
    7d32:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7d36:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7d3a:	f103 0301 	add.w	r3, r3, #1
    7d3e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	frame_data[d+9] = data[a++];
    7d42:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7d46:	f103 0309 	add.w	r3, r3, #9
    7d4a:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
    7d4e:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
    7d52:	440a      	add	r2, r1
    7d54:	7812      	ldrb	r2, [r2, #0]
    7d56:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
    7d5a:	440b      	add	r3, r1
    7d5c:	f803 2ce8 	strb.w	r2, [r3, #-232]
    7d60:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7d64:	f103 0301 	add.w	r3, r3, #1
    7d68:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	   	d += 12;
    7d6c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    7d70:	f103 030c 	add.w	r3, r3, #12
    7d74:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   	frame_data[b+5] = data[3];
   	frame_data[b+8] = data[4];
   	frame_data[b+9] = data[5];

   	data = g_mss_mac.mac_filter_data;
    for( a = 0; a < c; ) {
    7d78:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
    7d7c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    7d80:	429a      	cmp	r2, r3
    7d82:	f6ff af77 	blt.w	7c74 <MAC_send_setup_frame+0x140>
	   	frame_data[d+9] = data[a++];
	   	d += 12;
	}

	/* Stop transmission */
    ret = MAC_stop_transmission();
    7d86:	f000 f86d 	bl	7e64 <MAC_stop_transmission>
    7d8a:	4603      	mov	r3, r0
    7d8c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    ASSERT( ret == MAC_OK );
    7d90:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    7d94:	2b00      	cmp	r3, #0
    7d96:	d000      	beq.n	7d9a <MAC_send_setup_frame+0x266>
    7d98:	be00      	bkpt	0x0000

    ret = MAC_stop_receiving();
    7d9a:	f000 f8a1 	bl	7ee0 <MAC_stop_receiving>
    7d9e:	4603      	mov	r3, r0
    7da0:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    ASSERT( ret == MAC_OK );
    7da4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    7da8:	2b00      	cmp	r3, #0
    7daa:	d000      	beq.n	7dae <MAC_send_setup_frame+0x27a>
    7dac:	be00      	bkpt	0x0000

    /* Set descriptor */
    MAC->CSR4 = (uint32_t)&descriptor;
    7dae:	f243 0300 	movw	r3, #12288	; 0x3000
    7db2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7db6:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
    7dba:	621a      	str	r2, [r3, #32]
    
	/* Start transmission */
    MAC_start_transmission();
    7dbc:	f000 f882 	bl	7ec4 <MAC_start_transmission>

    /* Wait until transmission over */
    ret = MAC_OK;
    7dc0:	f04f 0300 	mov.w	r3, #0
    7dc4:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );
    7dc8:	f242 7010 	movw	r0, #10000	; 0x2710
    7dcc:	f000 f918 	bl	8000 <MAC_set_time_out>
    
    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) != 
    7dd0:	e00f      	b.n	7df2 <MAC_send_setup_frame+0x2be>
    	CSR5_TS_SUSPENDED) && (MAC_OK == ret) )
    {
    	/* transmit poll demand */
    	MAC->CSR1 = 1u;
    7dd2:	f243 0300 	movw	r3, #12288	; 0x3000
    7dd6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7dda:	f04f 0201 	mov.w	r2, #1
    7dde:	609a      	str	r2, [r3, #8]
    	if( MAC_get_time_out() == 0u ) {
    7de0:	f000 f936 	bl	8050 <MAC_get_time_out>
    7de4:	4603      	mov	r3, r0
    7de6:	2b00      	cmp	r3, #0
    7de8:	d103      	bne.n	7df2 <MAC_send_setup_frame+0x2be>
    		ret = MAC_TIME_OUT;
    7dea:	f06f 0305 	mvn.w	r3, #5
    7dee:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    /* Wait until transmission over */
    ret = MAC_OK;
    MAC_set_time_out( (uint32_t)SETUP_FRAME_TIME_OUT );
    
    while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) != 
    7df2:	f243 0300 	movw	r3, #12288	; 0x3000
    7df6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7dfa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7dfc:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    7e00:	ea4f 5313 	mov.w	r3, r3, lsr #20
    7e04:	2b06      	cmp	r3, #6
    7e06:	d003      	beq.n	7e10 <MAC_send_setup_frame+0x2dc>
    7e08:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
    7e0c:	2b00      	cmp	r3, #0
    7e0e:	d0e0      	beq.n	7dd2 <MAC_send_setup_frame+0x29e>
    	if( MAC_get_time_out() == 0u ) {
    		ret = MAC_TIME_OUT;
    	}
    }

	MAC_CHECK( MAC_stop_transmission() == MAC_OK, MAC_FAIL );
    7e10:	f000 f828 	bl	7e64 <MAC_stop_transmission>
    7e14:	4603      	mov	r3, r0
    7e16:	2b00      	cmp	r3, #0
    7e18:	d00c      	beq.n	7e34 <MAC_send_setup_frame+0x300>
    7e1a:	f247 1324 	movw	r3, #28964	; 0x7124
    7e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7e22:	f04f 32ff 	mov.w	r2, #4294967295
    7e26:	715a      	strb	r2, [r3, #5]
    7e28:	f000 f81c 	bl	7e64 <MAC_stop_transmission>
    7e2c:	4603      	mov	r3, r0
    7e2e:	2b00      	cmp	r3, #0
    7e30:	d000      	beq.n	7e34 <MAC_send_setup_frame+0x300>
    7e32:	be00      	bkpt	0x0000

    /* Set tx descriptor */
    MAC->CSR4 = (uint32_t)g_mss_mac.tx_descriptors;
    7e34:	f243 0300 	movw	r3, #12288	; 0x3000
    7e38:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7e3c:	4a08      	ldr	r2, [pc, #32]	; (7e60 <MAC_send_setup_frame+0x32c>)
    7e3e:	621a      	str	r2, [r3, #32]
    
    /* Start receiving and transmission */
    MAC_start_receiving();
    7e40:	f000 f87e 	bl	7f40 <MAC_start_receiving>
    MAC_start_transmission();
    7e44:	f000 f83e 	bl	7ec4 <MAC_start_transmission>

    return ret;
    7e48:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
}
    7e4c:	4618      	mov	r0, r3
    7e4e:	f107 07e8 	add.w	r7, r7, #232	; 0xe8
    7e52:	46bd      	mov	sp, r7
    7e54:	bd80      	pop	{r7, pc}
    7e56:	bf00      	nop
    7e58:	2000712a 	.word	0x2000712a
    7e5c:	20007130 	.word	0x20007130
    7e60:	20007d70 	.word	0x20007d70

00007e64 <MAC_stop_transmission>:
static int32_t
MAC_stop_transmission
(
    void
)
{
    7e64:	b580      	push	{r7, lr}
    7e66:	b082      	sub	sp, #8
    7e68:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    7e6a:	f04f 0300 	mov.w	r3, #0
    7e6e:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    7e70:	f242 7010 	movw	r0, #10000	; 0x2710
    7e74:	f000 f8c4 	bl	8000 <MAC_set_time_out>
    
	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    7e78:	e00f      	b.n	7e9a <MAC_stop_transmission+0x36>
		CSR5_TS_STOPPED) && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_ST = 0u;
    7e7a:	f240 0300 	movw	r3, #0
    7e7e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    7e82:	f04f 0200 	mov.w	r2, #0
    7e86:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
    	if( MAC_get_time_out() == 0u ) {
    7e8a:	f000 f8e1 	bl	8050 <MAC_get_time_out>
    7e8e:	4603      	mov	r3, r0
    7e90:	2b00      	cmp	r3, #0
    7e92:	d102      	bne.n	7e9a <MAC_stop_transmission+0x36>
    		retval = MAC_TIME_OUT;
    7e94:	f06f 0305 	mvn.w	r3, #5
    7e98:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    
	while( (((MAC->CSR5 & CSR5_TS_MASK) >> CSR5_TS_SHIFT) !=
    7e9a:	f243 0300 	movw	r3, #12288	; 0x3000
    7e9e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7ea2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7ea4:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
    7ea8:	ea4f 5313 	mov.w	r3, r3, lsr #20
    7eac:	2b00      	cmp	r3, #0
    7eae:	d002      	beq.n	7eb6 <MAC_stop_transmission+0x52>
    7eb0:	687b      	ldr	r3, [r7, #4]
    7eb2:	2b00      	cmp	r3, #0
    7eb4:	d0e1      	beq.n	7e7a <MAC_stop_transmission+0x16>
    	MAC_BITBAND->CSR6_ST = 0u;
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}
	return retval;
    7eb6:	687b      	ldr	r3, [r7, #4]
}
    7eb8:	4618      	mov	r0, r3
    7eba:	f107 0708 	add.w	r7, r7, #8
    7ebe:	46bd      	mov	sp, r7
    7ec0:	bd80      	pop	{r7, pc}
    7ec2:	bf00      	nop

00007ec4 <MAC_start_transmission>:
static void
MAC_start_transmission
(
    void
)
{
    7ec4:	b480      	push	{r7}
    7ec6:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_ST = 1u;
    7ec8:	f240 0300 	movw	r3, #0
    7ecc:	f2c4 2306 	movt	r3, #16902	; 0x4206
    7ed0:	f04f 0201 	mov.w	r2, #1
    7ed4:	f8c3 2634 	str.w	r2, [r3, #1588]	; 0x634
}
    7ed8:	46bd      	mov	sp, r7
    7eda:	bc80      	pop	{r7}
    7edc:	4770      	bx	lr
    7ede:	bf00      	nop

00007ee0 <MAC_stop_receiving>:
static int32_t
MAC_stop_receiving
(
    void
)
{
    7ee0:	b580      	push	{r7, lr}
    7ee2:	b082      	sub	sp, #8
    7ee4:	af00      	add	r7, sp, #0
    int32_t retval = MAC_OK;
    7ee6:	f04f 0300 	mov.w	r3, #0
    7eea:	607b      	str	r3, [r7, #4]
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );
    7eec:	f242 7010 	movw	r0, #10000	; 0x2710
    7ef0:	f000 f886 	bl	8000 <MAC_set_time_out>

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    7ef4:	e00f      	b.n	7f16 <MAC_stop_receiving+0x36>
            && (retval == MAC_OK) )
	{
    	MAC_BITBAND->CSR6_SR = 0u;
    7ef6:	f240 0300 	movw	r3, #0
    7efa:	f2c4 2306 	movt	r3, #16902	; 0x4206
    7efe:	f04f 0200 	mov.w	r2, #0
    7f02:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    	if( MAC_get_time_out() == 0u ) {
    7f06:	f000 f8a3 	bl	8050 <MAC_get_time_out>
    7f0a:	4603      	mov	r3, r0
    7f0c:	2b00      	cmp	r3, #0
    7f0e:	d102      	bne.n	7f16 <MAC_stop_receiving+0x36>
    		retval = MAC_TIME_OUT;
    7f10:	f06f 0305 	mvn.w	r3, #5
    7f14:	607b      	str	r3, [r7, #4]
)
{
    int32_t retval = MAC_OK;
    MAC_set_time_out( (uint16_t)STATE_CHANGE_TIME_OUT );

	while( (((MAC->CSR5 & CSR5_RS_MASK) >> CSR5_RS_SHIFT) != CSR5_RS_STOPPED)
    7f16:	f243 0300 	movw	r3, #12288	; 0x3000
    7f1a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    7f1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7f20:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    7f24:	ea4f 4353 	mov.w	r3, r3, lsr #17
    7f28:	2b00      	cmp	r3, #0
    7f2a:	d002      	beq.n	7f32 <MAC_stop_receiving+0x52>
    7f2c:	687b      	ldr	r3, [r7, #4]
    7f2e:	2b00      	cmp	r3, #0
    7f30:	d0e1      	beq.n	7ef6 <MAC_stop_receiving+0x16>
    	if( MAC_get_time_out() == 0u ) {
    		retval = MAC_TIME_OUT;
    	}
	}

	return retval;
    7f32:	687b      	ldr	r3, [r7, #4]
}
    7f34:	4618      	mov	r0, r3
    7f36:	f107 0708 	add.w	r7, r7, #8
    7f3a:	46bd      	mov	sp, r7
    7f3c:	bd80      	pop	{r7, pc}
    7f3e:	bf00      	nop

00007f40 <MAC_start_receiving>:
static void
MAC_start_receiving
(
    void
)
{
    7f40:	b480      	push	{r7}
    7f42:	af00      	add	r7, sp, #0
    MAC_BITBAND->CSR6_SR = 1u;
    7f44:	f240 0300 	movw	r3, #0
    7f48:	f2c4 2306 	movt	r3, #16902	; 0x4206
    7f4c:	f04f 0201 	mov.w	r2, #1
    7f50:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
}
    7f54:	46bd      	mov	sp, r7
    7f56:	bc80      	pop	{r7}
    7f58:	4770      	bx	lr
    7f5a:	bf00      	nop

00007f5c <MAC_dismiss_bad_frames>:
static int32_t
MAC_dismiss_bad_frames
(
    void
)
{
    7f5c:	b580      	push	{r7, lr}
    7f5e:	b082      	sub	sp, #8
    7f60:	af00      	add	r7, sp, #0
	int32_t dc = 0;
    7f62:	f04f 0300 	mov.w	r3, #0
    7f66:	603b      	str	r3, [r7, #0]
	int8_t cont = 1;
    7f68:	f04f 0301 	mov.w	r3, #1
    7f6c:	71fb      	strb	r3, [r7, #7]
    
	if( MAC_BITBAND->CSR6_PB != 0u ) {
    7f6e:	f240 0300 	movw	r3, #0
    7f72:	f2c4 2306 	movt	r3, #16902	; 0x4206
    7f76:	f8d3 360c 	ldr.w	r3, [r3, #1548]	; 0x60c
    7f7a:	2b00      	cmp	r3, #0
    7f7c:	d023      	beq.n	7fc6 <MAC_dismiss_bad_frames+0x6a>
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
    7f7e:	f04f 0300 	mov.w	r3, #0
    7f82:	71fb      	strb	r3, [r7, #7]
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7f84:	e020      	b.n	7fc8 <MAC_dismiss_bad_frames+0x6c>
            RDES0_OWN) == 0u) && (cont == 1) ) /* Host owns this descriptor */
    {
    	/* check error summary */
    	if( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7f86:	f247 1324 	movw	r3, #28964	; 0x7124
    7f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7f8e:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    7f92:	f247 1324 	movw	r3, #28964	; 0x7124
    7f96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7f9a:	f502 7211 	add.w	r2, r2, #580	; 0x244
    7f9e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7fa2:	4413      	add	r3, r2
    7fa4:	681b      	ldr	r3, [r3, #0]
    7fa6:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
    7faa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    7fae:	d006      	beq.n	7fbe <MAC_dismiss_bad_frames+0x62>
    		(RDES0_ES | RDES0_LS | RDES0_FS)) != (RDES0_LS | RDES0_FS) )
    	{
    		MSS_MAC_prepare_rx_descriptor();
    7fb0:	f7ff fc82 	bl	78b8 <MSS_MAC_prepare_rx_descriptor>
    		dc++;
    7fb4:	683b      	ldr	r3, [r7, #0]
    7fb6:	f103 0301 	add.w	r3, r3, #1
    7fba:	603b      	str	r3, [r7, #0]
    7fbc:	e004      	b.n	7fc8 <MAC_dismiss_bad_frames+0x6c>
    	}
        else
        {
    		cont = 0;
    7fbe:	f04f 0300 	mov.w	r3, #0
    7fc2:	71fb      	strb	r3, [r7, #7]
    7fc4:	e000      	b.n	7fc8 <MAC_dismiss_bad_frames+0x6c>
	if( MAC_BITBAND->CSR6_PB != 0u ) {
		/* User wants bad frames too, don't dismiss anything */
		cont = 0;
	}

	while( ( (g_mss_mac.rx_descriptors[ g_mss_mac.rx_desc_index ].descriptor_0 &
    7fc6:	bf00      	nop
    7fc8:	f247 1324 	movw	r3, #28964	; 0x7124
    7fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7fd0:	f8d3 2c6c 	ldr.w	r2, [r3, #3180]	; 0xc6c
    7fd4:	f247 1324 	movw	r3, #28964	; 0x7124
    7fd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7fdc:	f502 7211 	add.w	r2, r2, #580	; 0x244
    7fe0:	ea4f 1202 	mov.w	r2, r2, lsl #4
    7fe4:	4413      	add	r3, r2
    7fe6:	681b      	ldr	r3, [r3, #0]
    7fe8:	2b00      	cmp	r3, #0
    7fea:	db03      	blt.n	7ff4 <MAC_dismiss_bad_frames+0x98>
    7fec:	f997 3007 	ldrsb.w	r3, [r7, #7]
    7ff0:	2b01      	cmp	r3, #1
    7ff2:	d0c8      	beq.n	7f86 <MAC_dismiss_bad_frames+0x2a>
        {
    		cont = 0;
    	}
    }

	return dc;
    7ff4:	683b      	ldr	r3, [r7, #0]
}
    7ff6:	4618      	mov	r0, r3
    7ff8:	f107 0708 	add.w	r7, r7, #8
    7ffc:	46bd      	mov	sp, r7
    7ffe:	bd80      	pop	{r7, pc}

00008000 <MAC_set_time_out>:
static void
MAC_set_time_out
(
    uint32_t time_out
)
{
    8000:	b480      	push	{r7}
    8002:	b083      	sub	sp, #12
    8004:	af00      	add	r7, sp, #0
    8006:	6078      	str	r0, [r7, #4]
	g_mss_mac.time_out_value = (time_out * 122u) / 10u;
    8008:	687b      	ldr	r3, [r7, #4]
    800a:	f04f 027a 	mov.w	r2, #122	; 0x7a
    800e:	fb02 f203 	mul.w	r2, r2, r3
    8012:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    8016:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    801a:	fba3 1302 	umull	r1, r3, r3, r2
    801e:	ea4f 02d3 	mov.w	r2, r3, lsr #3
    8022:	f247 1324 	movw	r3, #28964	; 0x7124
    8026:	f2c2 0300 	movt	r3, #8192	; 0x2000
    802a:	669a      	str	r2, [r3, #104]	; 0x68

	g_mss_mac.last_timer_value = (uint16_t)( MAC->CSR11 & CSR11_TIM_MASK );
    802c:	f243 0300 	movw	r3, #12288	; 0x3000
    8030:	f2c4 0300 	movt	r3, #16384	; 0x4000
    8034:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    8036:	b29a      	uxth	r2, r3
    8038:	f247 1324 	movw	r3, #28964	; 0x7124
    803c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8040:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
}
    8044:	f107 070c 	add.w	r7, r7, #12
    8048:	46bd      	mov	sp, r7
    804a:	bc80      	pop	{r7}
    804c:	4770      	bx	lr
    804e:	bf00      	nop

00008050 <MAC_get_time_out>:
static uint32_t
MAC_get_time_out
(
    void
)
{
    8050:	b480      	push	{r7}
    8052:	b083      	sub	sp, #12
    8054:	af00      	add	r7, sp, #0
	uint32_t timer;
	uint32_t time = 0u;
    8056:	f04f 0300 	mov.w	r3, #0
    805a:	607b      	str	r3, [r7, #4]
    
	timer = ( MAC->CSR11 & CSR11_TIM_MASK );
    805c:	f243 0300 	movw	r3, #12288	; 0x3000
    8060:	f2c4 0300 	movt	r3, #16384	; 0x4000
    8064:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    8066:	ea4f 4303 	mov.w	r3, r3, lsl #16
    806a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    806e:	603b      	str	r3, [r7, #0]
    
	if( timer > g_mss_mac.last_timer_value ) {
    8070:	f247 1324 	movw	r3, #28964	; 0x7124
    8074:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8078:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    807c:	461a      	mov	r2, r3
    807e:	683b      	ldr	r3, [r7, #0]
    8080:	429a      	cmp	r2, r3
    8082:	d202      	bcs.n	808a <MAC_get_time_out+0x3a>
		time = 0x0000ffffUL;
    8084:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8088:	607b      	str	r3, [r7, #4]
	}
	time += g_mss_mac.last_timer_value - timer;
    808a:	f247 1324 	movw	r3, #28964	; 0x7124
    808e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8092:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    8096:	461a      	mov	r2, r3
    8098:	683b      	ldr	r3, [r7, #0]
    809a:	ebc3 0302 	rsb	r3, r3, r2
    809e:	687a      	ldr	r2, [r7, #4]
    80a0:	4413      	add	r3, r2
    80a2:	607b      	str	r3, [r7, #4]
    
	if( MAC_BITBAND->CSR6_TTM == 0u ) {
    80a4:	f240 0300 	movw	r3, #0
    80a8:	f2c4 2306 	movt	r3, #16902	; 0x4206
    80ac:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
    80b0:	2b00      	cmp	r3, #0
    80b2:	d107      	bne.n	80c4 <MAC_get_time_out+0x74>
		time *= 10u;
    80b4:	687a      	ldr	r2, [r7, #4]
    80b6:	4613      	mov	r3, r2
    80b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    80bc:	4413      	add	r3, r2
    80be:	ea4f 0343 	mov.w	r3, r3, lsl #1
    80c2:	607b      	str	r3, [r7, #4]
	}
	if( g_mss_mac.time_out_value <= time ){
    80c4:	f247 1324 	movw	r3, #28964	; 0x7124
    80c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80cc:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    80ce:	687b      	ldr	r3, [r7, #4]
    80d0:	429a      	cmp	r2, r3
    80d2:	d807      	bhi.n	80e4 <MAC_get_time_out+0x94>
		g_mss_mac.time_out_value = 0u;
    80d4:	f247 1324 	movw	r3, #28964	; 0x7124
    80d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80dc:	f04f 0200 	mov.w	r2, #0
    80e0:	669a      	str	r2, [r3, #104]	; 0x68
    80e2:	e00c      	b.n	80fe <MAC_get_time_out+0xae>
	} else {
		g_mss_mac.time_out_value -= time;
    80e4:	f247 1324 	movw	r3, #28964	; 0x7124
    80e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80ec:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    80ee:	687b      	ldr	r3, [r7, #4]
    80f0:	ebc3 0202 	rsb	r2, r3, r2
    80f4:	f247 1324 	movw	r3, #28964	; 0x7124
    80f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    80fc:	669a      	str	r2, [r3, #104]	; 0x68
	}

	g_mss_mac.last_timer_value = (uint16_t)timer;
    80fe:	683b      	ldr	r3, [r7, #0]
    8100:	b29a      	uxth	r2, r3
    8102:	f247 1324 	movw	r3, #28964	; 0x7124
    8106:	f2c2 0300 	movt	r3, #8192	; 0x2000
    810a:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

	return ((g_mss_mac.time_out_value * 10u) / 122u);
    810e:	f247 1324 	movw	r3, #28964	; 0x7124
    8112:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8116:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    8118:	4613      	mov	r3, r2
    811a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    811e:	4413      	add	r3, r2
    8120:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8124:	461a      	mov	r2, r3
    8126:	f24c 533f 	movw	r3, #50495	; 0xc53f
    812a:	f2c4 3325 	movt	r3, #17189	; 0x4325
    812e:	fba3 1302 	umull	r1, r3, r3, r2
    8132:	ea4f 1353 	mov.w	r3, r3, lsr #5
}
    8136:	4618      	mov	r0, r3
    8138:	f107 070c 	add.w	r7, r7, #12
    813c:	46bd      	mov	sp, r7
    813e:	bc80      	pop	{r7}
    8140:	4770      	bx	lr
    8142:	bf00      	nop

00008144 <MAC_memset>:
/***************************************************************************//**
 * Fills the first n bytes of the memory area pointed to by s with the constant
 * byte c.
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    8144:	b480      	push	{r7}
    8146:	b087      	sub	sp, #28
    8148:	af00      	add	r7, sp, #0
    814a:	60f8      	str	r0, [r7, #12]
    814c:	460b      	mov	r3, r1
    814e:	607a      	str	r2, [r7, #4]
    8150:	72fb      	strb	r3, [r7, #11]
    uint8_t *sb = s;
    8152:	68fb      	ldr	r3, [r7, #12]
    8154:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    8156:	e008      	b.n	816a <MAC_memset+0x26>
    	n--;
    8158:	687b      	ldr	r3, [r7, #4]
    815a:	f103 33ff 	add.w	r3, r3, #4294967295
    815e:	607b      	str	r3, [r7, #4]
        sb[n] = c;
    8160:	697a      	ldr	r2, [r7, #20]
    8162:	687b      	ldr	r3, [r7, #4]
    8164:	4413      	add	r3, r2
    8166:	7afa      	ldrb	r2, [r7, #11]
    8168:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memset(uint8_t *s, uint8_t c, uint32_t n)
{
    uint8_t *sb = s;

    while( n > 0u ) {
    816a:	687b      	ldr	r3, [r7, #4]
    816c:	2b00      	cmp	r3, #0
    816e:	d1f3      	bne.n	8158 <MAC_memset+0x14>
    	n--;
        sb[n] = c;
    }
}
    8170:	f107 071c 	add.w	r7, r7, #28
    8174:	46bd      	mov	sp, r7
    8176:	bc80      	pop	{r7}
    8178:	4770      	bx	lr
    817a:	bf00      	nop

0000817c <MAC_memset_All>:
 * Fills all fields of MAC_instance_t with c.
 *
 * @return          a pointer to the given MAC_instance_t s.
 */
static void MAC_memset_All(MAC_instance_t *s, uint32_t c)
{
    817c:	b580      	push	{r7, lr}
    817e:	b084      	sub	sp, #16
    8180:	af00      	add	r7, sp, #0
    8182:	6078      	str	r0, [r7, #4]
    8184:	6039      	str	r1, [r7, #0]
    int32_t count;
    s->base_address = (addr_t)c;
    8186:	687b      	ldr	r3, [r7, #4]
    8188:	683a      	ldr	r2, [r7, #0]
    818a:	601a      	str	r2, [r3, #0]
    s->flags = (uint8_t)c;
    818c:	683b      	ldr	r3, [r7, #0]
    818e:	b2da      	uxtb	r2, r3
    8190:	687b      	ldr	r3, [r7, #4]
    8192:	711a      	strb	r2, [r3, #4]
    s->last_error = (int8_t)c;
    8194:	683b      	ldr	r3, [r7, #0]
    8196:	b2da      	uxtb	r2, r3
    8198:	687b      	ldr	r3, [r7, #4]
    819a:	715a      	strb	r2, [r3, #5]
    s->last_timer_value = (uint16_t)c;
    819c:	683b      	ldr	r3, [r7, #0]
    819e:	b29a      	uxth	r2, r3
    81a0:	687b      	ldr	r3, [r7, #4]
    81a2:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    s->listener = NULL_callback;
    81a6:	f243 1390 	movw	r3, #12688	; 0x3190
    81aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    81ae:	681a      	ldr	r2, [r3, #0]
    81b0:	687b      	ldr	r3, [r7, #4]
    81b2:	66da      	str	r2, [r3, #108]	; 0x6c
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
    81b4:	687b      	ldr	r3, [r7, #4]
    81b6:	f103 0206 	add.w	r2, r3, #6
    81ba:	683b      	ldr	r3, [r7, #0]
    81bc:	b2db      	uxtb	r3, r3
    81be:	4610      	mov	r0, r2
    81c0:	4619      	mov	r1, r3
    81c2:	f04f 0206 	mov.w	r2, #6
    81c6:	f7ff ffbd 	bl	8144 <MAC_memset>
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    81ca:	687b      	ldr	r3, [r7, #4]
    81cc:	f103 020c 	add.w	r2, r3, #12
    81d0:	683b      	ldr	r3, [r7, #0]
    81d2:	b2db      	uxtb	r3, r3
    81d4:	4610      	mov	r0, r2
    81d6:	4619      	mov	r1, r3
    81d8:	f04f 025a 	mov.w	r2, #90	; 0x5a
    81dc:	f7ff ffb2 	bl	8144 <MAC_memset>
    s->phy_address = (uint8_t)c;
    81e0:	683b      	ldr	r3, [r7, #0]
    81e2:	b2da      	uxtb	r2, r3
    81e4:	687b      	ldr	r3, [r7, #4]
    81e6:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    81ea:	701a      	strb	r2, [r3, #0]
    for(count = 0; count<RX_RING_SIZE ;count++)
    81ec:	f04f 0300 	mov.w	r3, #0
    81f0:	60fb      	str	r3, [r7, #12]
    81f2:	e015      	b.n	8220 <MAC_memset_All+0xa4>
    {
        MAC_memset(s->rx_buffers[count], (uint8_t)c, (MSS_RX_BUFF_SIZE + 4u) );
    81f4:	687b      	ldr	r3, [r7, #4]
    81f6:	f503 6347 	add.w	r3, r3, #3184	; 0xc70
    81fa:	461a      	mov	r2, r3
    81fc:	68fb      	ldr	r3, [r7, #12]
    81fe:	f240 51f4 	movw	r1, #1524	; 0x5f4
    8202:	fb01 f303 	mul.w	r3, r1, r3
    8206:	441a      	add	r2, r3
    8208:	683b      	ldr	r3, [r7, #0]
    820a:	b2db      	uxtb	r3, r3
    820c:	4610      	mov	r0, r2
    820e:	4619      	mov	r1, r3
    8210:	f240 52f4 	movw	r2, #1524	; 0x5f4
    8214:	f7ff ff96 	bl	8144 <MAC_memset>
    s->last_timer_value = (uint16_t)c;
    s->listener = NULL_callback;
   	MAC_memset( s->mac_address, (uint8_t)c, 6u );
   	MAC_memset( s->mac_filter_data, (uint8_t)c, 90u );
    s->phy_address = (uint8_t)c;
    for(count = 0; count<RX_RING_SIZE ;count++)
    8218:	68fb      	ldr	r3, [r7, #12]
    821a:	f103 0301 	add.w	r3, r3, #1
    821e:	60fb      	str	r3, [r7, #12]
    8220:	68fb      	ldr	r3, [r7, #12]
    8222:	2b03      	cmp	r3, #3
    8224:	dde6      	ble.n	81f4 <MAC_memset_All+0x78>
    {
        MAC_memset(s->rx_buffers[count], (uint8_t)c, (MSS_RX_BUFF_SIZE + 4u) );
    }
    s->rx_desc_index =c;
    8226:	687b      	ldr	r3, [r7, #4]
    8228:	683a      	ldr	r2, [r7, #0]
    822a:	f8c3 2c6c 	str.w	r2, [r3, #3180]	; 0xc6c
    for(count = 0; count<RX_RING_SIZE ;count++)
    822e:	f04f 0300 	mov.w	r3, #0
    8232:	60fb      	str	r3, [r7, #12]
    8234:	e02d      	b.n	8292 <MAC_memset_All+0x116>
    {
        s->rx_descriptors[count].buffer_1 = c;
    8236:	68fa      	ldr	r2, [r7, #12]
    8238:	687b      	ldr	r3, [r7, #4]
    823a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    823e:	4413      	add	r3, r2
    8240:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    8244:	f103 0348 	add.w	r3, r3, #72	; 0x48
    8248:	683a      	ldr	r2, [r7, #0]
    824a:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].buffer_2 = c;
    824c:	68fa      	ldr	r2, [r7, #12]
    824e:	687b      	ldr	r3, [r7, #4]
    8250:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8254:	4413      	add	r3, r2
    8256:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
    825a:	f103 034c 	add.w	r3, r3, #76	; 0x4c
    825e:	683a      	ldr	r2, [r7, #0]
    8260:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_0 = c;
    8262:	68fa      	ldr	r2, [r7, #12]
    8264:	687b      	ldr	r3, [r7, #4]
    8266:	f502 7211 	add.w	r2, r2, #580	; 0x244
    826a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    826e:	4413      	add	r3, r2
    8270:	683a      	ldr	r2, [r7, #0]
    8272:	601a      	str	r2, [r3, #0]
        s->rx_descriptors[count].descriptor_1 = c;
    8274:	68fa      	ldr	r2, [r7, #12]
    8276:	687b      	ldr	r3, [r7, #4]
    8278:	f502 7211 	add.w	r2, r2, #580	; 0x244
    827c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8280:	4413      	add	r3, r2
    8282:	f103 0304 	add.w	r3, r3, #4
    8286:	683a      	ldr	r2, [r7, #0]
    8288:	601a      	str	r2, [r3, #0]
    for(count = 0; count<RX_RING_SIZE ;count++)
    {
        MAC_memset(s->rx_buffers[count], (uint8_t)c, (MSS_RX_BUFF_SIZE + 4u) );
    }
    s->rx_desc_index =c;
    for(count = 0; count<RX_RING_SIZE ;count++)
    828a:	68fb      	ldr	r3, [r7, #12]
    828c:	f103 0301 	add.w	r3, r3, #1
    8290:	60fb      	str	r3, [r7, #12]
    8292:	68fb      	ldr	r3, [r7, #12]
    8294:	2b03      	cmp	r3, #3
    8296:	ddce      	ble.n	8236 <MAC_memset_All+0xba>
        s->rx_descriptors[count].buffer_1 = c;
        s->rx_descriptors[count].buffer_2 = c;
        s->rx_descriptors[count].descriptor_0 = c;
        s->rx_descriptors[count].descriptor_1 = c;
    }
    s->statistics.rx_collision_seen =c;
    8298:	687b      	ldr	r3, [r7, #4]
    829a:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    829e:	f103 0320 	add.w	r3, r3, #32
    82a2:	683a      	ldr	r2, [r7, #0]
    82a4:	601a      	str	r2, [r3, #0]
    s->statistics.rx_crc_error = c;
    82a6:	687b      	ldr	r3, [r7, #4]
    82a8:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82ac:	f103 0324 	add.w	r3, r3, #36	; 0x24
    82b0:	683a      	ldr	r2, [r7, #0]
    82b2:	601a      	str	r2, [r3, #0]
    s->statistics.rx_descriptor_error = c;
    82b4:	687b      	ldr	r3, [r7, #4]
    82b6:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82ba:	f103 030c 	add.w	r3, r3, #12
    82be:	683a      	ldr	r2, [r7, #0]
    82c0:	601a      	str	r2, [r3, #0]
    s->statistics.rx_fifo_overflow = c;
    82c2:	687b      	ldr	r3, [r7, #4]
    82c4:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82c8:	f103 0328 	add.w	r3, r3, #40	; 0x28
    82cc:	683a      	ldr	r2, [r7, #0]
    82ce:	601a      	str	r2, [r3, #0]
    s->statistics.rx_filtering_fail = c;
    82d0:	687b      	ldr	r3, [r7, #4]
    82d2:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82d6:	f103 0308 	add.w	r3, r3, #8
    82da:	683a      	ldr	r2, [r7, #0]
    82dc:	601a      	str	r2, [r3, #0]
    s->statistics.rx_frame_too_long = c;
    82de:	687b      	ldr	r3, [r7, #4]
    82e0:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82e4:	f103 031c 	add.w	r3, r3, #28
    82e8:	683a      	ldr	r2, [r7, #0]
    82ea:	601a      	str	r2, [r3, #0]
    s->statistics.rx_interrupts = c;
    82ec:	687b      	ldr	r3, [r7, #4]
    82ee:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    82f2:	f103 0304 	add.w	r3, r3, #4
    82f6:	683a      	ldr	r2, [r7, #0]
    82f8:	601a      	str	r2, [r3, #0]
    s->statistics.rx_missed_frame = c;
    82fa:	687b      	ldr	r3, [r7, #4]
    82fc:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8300:	f103 032c 	add.w	r3, r3, #44	; 0x2c
    8304:	683a      	ldr	r2, [r7, #0]
    8306:	601a      	str	r2, [r3, #0]
    s->statistics.rx_not_first = c;
    8308:	687b      	ldr	r3, [r7, #4]
    830a:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    830e:	f103 0314 	add.w	r3, r3, #20
    8312:	683a      	ldr	r2, [r7, #0]
    8314:	601a      	str	r2, [r3, #0]
    s->statistics.rx_not_last = c;
    8316:	687b      	ldr	r3, [r7, #4]
    8318:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    831c:	f103 0318 	add.w	r3, r3, #24
    8320:	683a      	ldr	r2, [r7, #0]
    8322:	601a      	str	r2, [r3, #0]
    s->statistics.rx_runt_frame = c;
    8324:	687b      	ldr	r3, [r7, #4]
    8326:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    832a:	f103 0310 	add.w	r3, r3, #16
    832e:	683a      	ldr	r2, [r7, #0]
    8330:	601a      	str	r2, [r3, #0]
    s->statistics.tx_collision_count = c;
    8332:	687b      	ldr	r3, [r7, #4]
    8334:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8338:	f103 0344 	add.w	r3, r3, #68	; 0x44
    833c:	683a      	ldr	r2, [r7, #0]
    833e:	601a      	str	r2, [r3, #0]
    s->statistics.tx_excessive_collision = c;
    8340:	687b      	ldr	r3, [r7, #4]
    8342:	f503 5313 	add.w	r3, r3, #9408	; 0x24c0
    8346:	683a      	ldr	r2, [r7, #0]
    8348:	601a      	str	r2, [r3, #0]
    s->statistics.tx_interrupts = c;
    834a:	687b      	ldr	r3, [r7, #4]
    834c:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8350:	f103 0330 	add.w	r3, r3, #48	; 0x30
    8354:	683a      	ldr	r2, [r7, #0]
    8356:	601a      	str	r2, [r3, #0]
    s->statistics.tx_late_collision = c;
    8358:	687b      	ldr	r3, [r7, #4]
    835a:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    835e:	f103 033c 	add.w	r3, r3, #60	; 0x3c
    8362:	683a      	ldr	r2, [r7, #0]
    8364:	601a      	str	r2, [r3, #0]
    s->statistics.tx_loss_of_carrier = c;
    8366:	687b      	ldr	r3, [r7, #4]
    8368:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    836c:	f103 0334 	add.w	r3, r3, #52	; 0x34
    8370:	683a      	ldr	r2, [r7, #0]
    8372:	601a      	str	r2, [r3, #0]
    s->statistics.tx_no_carrier = c;
    8374:	687b      	ldr	r3, [r7, #4]
    8376:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    837a:	f103 0338 	add.w	r3, r3, #56	; 0x38
    837e:	683a      	ldr	r2, [r7, #0]
    8380:	601a      	str	r2, [r3, #0]
    s->statistics.tx_underflow_error = c;
    8382:	687b      	ldr	r3, [r7, #4]
    8384:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8388:	f103 0348 	add.w	r3, r3, #72	; 0x48
    838c:	683a      	ldr	r2, [r7, #0]
    838e:	601a      	str	r2, [r3, #0]
    s->time_out_value = c;
    8390:	687b      	ldr	r3, [r7, #4]
    8392:	683a      	ldr	r2, [r7, #0]
    8394:	669a      	str	r2, [r3, #104]	; 0x68
    for(count = 0; count < TX_RING_SIZE ;count++)
    8396:	f04f 0300 	mov.w	r3, #0
    839a:	60fb      	str	r3, [r7, #12]
    839c:	e015      	b.n	83ca <MAC_memset_All+0x24e>
    {
        MAC_memset( s->tx_buffers[count], (uint8_t)c, MSS_TX_BUFF_SIZE );
    839e:	687b      	ldr	r3, [r7, #4]
    83a0:	f103 0374 	add.w	r3, r3, #116	; 0x74
    83a4:	461a      	mov	r2, r3
    83a6:	68fb      	ldr	r3, [r7, #12]
    83a8:	f240 51ec 	movw	r1, #1516	; 0x5ec
    83ac:	fb01 f303 	mul.w	r3, r1, r3
    83b0:	441a      	add	r2, r3
    83b2:	683b      	ldr	r3, [r7, #0]
    83b4:	b2db      	uxtb	r3, r3
    83b6:	4610      	mov	r0, r2
    83b8:	4619      	mov	r1, r3
    83ba:	f240 52ec 	movw	r2, #1516	; 0x5ec
    83be:	f7ff fec1 	bl	8144 <MAC_memset>
    s->statistics.tx_late_collision = c;
    s->statistics.tx_loss_of_carrier = c;
    s->statistics.tx_no_carrier = c;
    s->statistics.tx_underflow_error = c;
    s->time_out_value = c;
    for(count = 0; count < TX_RING_SIZE ;count++)
    83c2:	68fb      	ldr	r3, [r7, #12]
    83c4:	f103 0301 	add.w	r3, r3, #1
    83c8:	60fb      	str	r3, [r7, #12]
    83ca:	68fb      	ldr	r3, [r7, #12]
    83cc:	2b01      	cmp	r3, #1
    83ce:	dde6      	ble.n	839e <MAC_memset_All+0x222>
    {
        MAC_memset( s->tx_buffers[count], (uint8_t)c, MSS_TX_BUFF_SIZE );
    }
    s->tx_desc_index = c;
    83d0:	687b      	ldr	r3, [r7, #4]
    83d2:	683a      	ldr	r2, [r7, #0]
    83d4:	671a      	str	r2, [r3, #112]	; 0x70
    for(count = 0; count < TX_RING_SIZE ;count++)
    83d6:	f04f 0300 	mov.w	r3, #0
    83da:	60fb      	str	r3, [r7, #12]
    83dc:	e02d      	b.n	843a <MAC_memset_All+0x2be>
    {
        s->tx_descriptors[count].buffer_1 = c;
    83de:	68fa      	ldr	r2, [r7, #12]
    83e0:	687b      	ldr	r3, [r7, #4]
    83e2:	f102 02c5 	add.w	r2, r2, #197	; 0xc5
    83e6:	ea4f 1202 	mov.w	r2, r2, lsl #4
    83ea:	4413      	add	r3, r2
    83ec:	f103 0304 	add.w	r3, r3, #4
    83f0:	683a      	ldr	r2, [r7, #0]
    83f2:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].buffer_2 = c;
    83f4:	68fa      	ldr	r2, [r7, #12]
    83f6:	687b      	ldr	r3, [r7, #4]
    83f8:	f102 02c5 	add.w	r2, r2, #197	; 0xc5
    83fc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8400:	4413      	add	r3, r2
    8402:	f103 0308 	add.w	r3, r3, #8
    8406:	683a      	ldr	r2, [r7, #0]
    8408:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_0 = c;
    840a:	68fa      	ldr	r2, [r7, #12]
    840c:	687b      	ldr	r3, [r7, #4]
    840e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8412:	4413      	add	r3, r2
    8414:	f503 6344 	add.w	r3, r3, #3136	; 0xc40
    8418:	f103 030c 	add.w	r3, r3, #12
    841c:	683a      	ldr	r2, [r7, #0]
    841e:	601a      	str	r2, [r3, #0]
        s->tx_descriptors[count].descriptor_1 = c;
    8420:	68fa      	ldr	r2, [r7, #12]
    8422:	687b      	ldr	r3, [r7, #4]
    8424:	ea4f 1202 	mov.w	r2, r2, lsl #4
    8428:	4413      	add	r3, r2
    842a:	f503 6345 	add.w	r3, r3, #3152	; 0xc50
    842e:	683a      	ldr	r2, [r7, #0]
    8430:	601a      	str	r2, [r3, #0]
    for(count = 0; count < TX_RING_SIZE ;count++)
    {
        MAC_memset( s->tx_buffers[count], (uint8_t)c, MSS_TX_BUFF_SIZE );
    }
    s->tx_desc_index = c;
    for(count = 0; count < TX_RING_SIZE ;count++)
    8432:	68fb      	ldr	r3, [r7, #12]
    8434:	f103 0301 	add.w	r3, r3, #1
    8438:	60fb      	str	r3, [r7, #12]
    843a:	68fb      	ldr	r3, [r7, #12]
    843c:	2b01      	cmp	r3, #1
    843e:	ddce      	ble.n	83de <MAC_memset_All+0x262>
        s->tx_descriptors[count].buffer_1 = c;
        s->tx_descriptors[count].buffer_2 = c;
        s->tx_descriptors[count].descriptor_0 = c;
        s->tx_descriptors[count].descriptor_1 = c;
    }
}
    8440:	f107 0710 	add.w	r7, r7, #16
    8444:	46bd      	mov	sp, r7
    8446:	bd80      	pop	{r7, pc}

00008448 <MAC_memcpy>:
 * The memory areas should not overlap.
 *
 * @return          a pointer to the memory area dest.
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    8448:	b480      	push	{r7}
    844a:	b087      	sub	sp, #28
    844c:	af00      	add	r7, sp, #0
    844e:	60f8      	str	r0, [r7, #12]
    8450:	60b9      	str	r1, [r7, #8]
    8452:	607a      	str	r2, [r7, #4]
    uint8_t *d = dest;
    8454:	68fb      	ldr	r3, [r7, #12]
    8456:	617b      	str	r3, [r7, #20]

    while( n > 0u ) {
    8458:	e00b      	b.n	8472 <MAC_memcpy+0x2a>
    	n--;
    845a:	687b      	ldr	r3, [r7, #4]
    845c:	f103 33ff 	add.w	r3, r3, #4294967295
    8460:	607b      	str	r3, [r7, #4]
        d[n] = src[n];
    8462:	697a      	ldr	r2, [r7, #20]
    8464:	687b      	ldr	r3, [r7, #4]
    8466:	4413      	add	r3, r2
    8468:	68b9      	ldr	r1, [r7, #8]
    846a:	687a      	ldr	r2, [r7, #4]
    846c:	440a      	add	r2, r1
    846e:	7812      	ldrb	r2, [r2, #0]
    8470:	701a      	strb	r2, [r3, #0]
 */
static void MAC_memcpy(uint8_t *dest, const uint8_t *src, uint32_t n)
{
    uint8_t *d = dest;

    while( n > 0u ) {
    8472:	687b      	ldr	r3, [r7, #4]
    8474:	2b00      	cmp	r3, #0
    8476:	d1f0      	bne.n	845a <MAC_memcpy+0x12>
    	n--;
        d[n] = src[n];
    }
}
    8478:	f107 071c 	add.w	r7, r7, #28
    847c:	46bd      	mov	sp, r7
    847e:	bc80      	pop	{r7}
    8480:	4770      	bx	lr
    8482:	bf00      	nop

00008484 <MDIO_management_clock>:
static void
MDIO_management_clock
(
    int32_t clock
)
{
    8484:	b480      	push	{r7}
    8486:	b085      	sub	sp, #20
    8488:	af00      	add	r7, sp, #0
    848a:	6078      	str	r0, [r7, #4]
	int32_t volatile a;
    
    MAC_BITBAND->CSR9_MDC = (uint32_t)clock;
    848c:	f240 0300 	movw	r3, #0
    8490:	f2c4 2306 	movt	r3, #16902	; 0x4206
    8494:	687a      	ldr	r2, [r7, #4]
    8496:	f8c3 2940 	str.w	r2, [r3, #2368]	; 0x940
    
	/* delay for 1us */
	for( a = 0; a < ONEMICROSECOND; a++ ){}
    849a:	f04f 0300 	mov.w	r3, #0
    849e:	60fb      	str	r3, [r7, #12]
    84a0:	e003      	b.n	84aa <MDIO_management_clock+0x26>
    84a2:	68fb      	ldr	r3, [r7, #12]
    84a4:	f103 0301 	add.w	r3, r3, #1
    84a8:	60fb      	str	r3, [r7, #12]
    84aa:	68fb      	ldr	r3, [r7, #12]
    84ac:	2b13      	cmp	r3, #19
    84ae:	d9f8      	bls.n	84a2 <MDIO_management_clock+0x1e>
}
    84b0:	f107 0714 	add.w	r7, r7, #20
    84b4:	46bd      	mov	sp, r7
    84b6:	bc80      	pop	{r7}
    84b8:	4770      	bx	lr
    84ba:	bf00      	nop

000084bc <MDIO_send_cmd>:
MDIO_send_cmd
(
    uint8_t regad,
    mdio_cmd_t mdio_cmd
)
{
    84bc:	b580      	push	{r7, lr}
    84be:	b084      	sub	sp, #16
    84c0:	af00      	add	r7, sp, #0
    84c2:	4602      	mov	r2, r0
    84c4:	460b      	mov	r3, r1
    84c6:	71fa      	strb	r2, [r7, #7]
    84c8:	71bb      	strb	r3, [r7, #6]
    int32_t i;
    uint16_t mask, data;

    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;
    84ca:	f240 0300 	movw	r3, #0
    84ce:	f2c4 2306 	movt	r3, #16902	; 0x4206
    84d2:	f04f 0201 	mov.w	r2, #1
    84d6:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    84da:	f240 0300 	movw	r3, #0
    84de:	f2c4 2306 	movt	r3, #16902	; 0x4206
    84e2:	f04f 0201 	mov.w	r2, #1
    84e6:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
    for (i = 0; i < PREAMBLECOUNT; i++) {
    84ea:	f04f 0300 	mov.w	r3, #0
    84ee:	60bb      	str	r3, [r7, #8]
    84f0:	e00b      	b.n	850a <MDIO_send_cmd+0x4e>
    	MDIO_management_clock( 0 );
    84f2:	f04f 0000 	mov.w	r0, #0
    84f6:	f7ff ffc5 	bl	8484 <MDIO_management_clock>
    	MDIO_management_clock( 1 );
    84fa:	f04f 0001 	mov.w	r0, #1
    84fe:	f7ff ffc1 	bl	8484 <MDIO_management_clock>
    /* enable MII output */
    MAC_BITBAND->CSR9_MDEN = 1;

    /* send 32 1's preamble */
    MAC_BITBAND->CSR9_MDO = 1;
    for (i = 0; i < PREAMBLECOUNT; i++) {
    8502:	68bb      	ldr	r3, [r7, #8]
    8504:	f103 0301 	add.w	r3, r3, #1
    8508:	60bb      	str	r3, [r7, #8]
    850a:	68bb      	ldr	r3, [r7, #8]
    850c:	2b1f      	cmp	r3, #31
    850e:	d9f0      	bls.n	84f2 <MDIO_send_cmd+0x36>
    	MDIO_management_clock( 0 );
    	MDIO_management_clock( 1 );
    }

    /* calculate data bits */
    data = MDIO_START |
    8510:	79bb      	ldrb	r3, [r7, #6]
    8512:	2b00      	cmp	r3, #0
    8514:	d102      	bne.n	851c <MDIO_send_cmd+0x60>
    8516:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    851a:	e001      	b.n	8520 <MDIO_send_cmd+0x64>
    851c:	f245 0202 	movw	r2, #20482	; 0x5002
    8520:	f247 1324 	movw	r3, #28964	; 0x7124
    8524:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8528:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    852c:	781b      	ldrb	r3, [r3, #0]
    852e:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    8532:	b29b      	uxth	r3, r3
    8534:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
    8538:	ea42 0303 	orr.w	r3, r2, r3
    853c:	b29a      	uxth	r2, r3
    853e:	79fb      	ldrb	r3, [r7, #7]
    8540:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8544:	b29b      	uxth	r3, r3
    8546:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    854a:	ea42 0303 	orr.w	r3, r2, r3
    854e:	81fb      	strh	r3, [r7, #14]
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    8550:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    8554:	81bb      	strh	r3, [r7, #12]
    8556:	e02b      	b.n	85b0 <MDIO_send_cmd+0xf4>
    {
        if ((mask == 0x2) && (mdio_cmd == MDIO_CMD_READ)) {
    8558:	89bb      	ldrh	r3, [r7, #12]
    855a:	2b02      	cmp	r3, #2
    855c:	d10a      	bne.n	8574 <MDIO_send_cmd+0xb8>
    855e:	79bb      	ldrb	r3, [r7, #6]
    8560:	2b00      	cmp	r3, #0
    8562:	d107      	bne.n	8574 <MDIO_send_cmd+0xb8>
    		/* enable MII input */
            MAC_BITBAND->CSR9_MDEN = 0;
    8564:	f240 0300 	movw	r3, #0
    8568:	f2c4 2306 	movt	r3, #16902	; 0x4206
    856c:	f04f 0200 	mov.w	r2, #0
    8570:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948
        }

    	MDIO_management_clock( 0 );
    8574:	f04f 0000 	mov.w	r0, #0
    8578:	f7ff ff84 	bl	8484 <MDIO_management_clock>

        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    857c:	f240 0300 	movw	r3, #0
    8580:	f2c4 2306 	movt	r3, #16902	; 0x4206
    8584:	89b9      	ldrh	r1, [r7, #12]
    8586:	89fa      	ldrh	r2, [r7, #14]
    8588:	ea01 0202 	and.w	r2, r1, r2
    858c:	b292      	uxth	r2, r2
    858e:	2a00      	cmp	r2, #0
    8590:	d002      	beq.n	8598 <MDIO_send_cmd+0xdc>
    8592:	f04f 0201 	mov.w	r2, #1
    8596:	e001      	b.n	859c <MDIO_send_cmd+0xe0>
    8598:	f04f 0200 	mov.w	r2, #0
    859c:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944
        
    	MDIO_management_clock( 1 );
    85a0:	f04f 0001 	mov.w	r0, #1
    85a4:	f7ff ff6e 	bl	8484 <MDIO_management_clock>
    	(( mdio_cmd == MDIO_CMD_READ ) ? MDIO_READ : MDIO_WRITE ) |
    	((g_mss_mac.phy_address << MDIO_ADDR_OFFSET) & MDIO_ADDR_MASK) |
    	((regad << MDIO_REG_ADDR_OFFSET) & MDIO_REG_ADDR_MASK);

    /* sent out */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    85a8:	89bb      	ldrh	r3, [r7, #12]
    85aa:	ea4f 0353 	mov.w	r3, r3, lsr #1
    85ae:	81bb      	strh	r3, [r7, #12]
    85b0:	89bb      	ldrh	r3, [r7, #12]
    85b2:	2b00      	cmp	r3, #0
    85b4:	d1d0      	bne.n	8558 <MDIO_send_cmd+0x9c>
        /* prepare MDO */
        MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
        
    	MDIO_management_clock( 1 );
    }
}
    85b6:	f107 0710 	add.w	r7, r7, #16
    85ba:	46bd      	mov	sp, r7
    85bc:	bd80      	pop	{r7, pc}
    85be:	bf00      	nop

000085c0 <MDIO_read>:
static uint16_t
MDIO_read
(
    uint8_t regad
)
{
    85c0:	b580      	push	{r7, lr}
    85c2:	b084      	sub	sp, #16
    85c4:	af00      	add	r7, sp, #0
    85c6:	4603      	mov	r3, r0
    85c8:	71fb      	strb	r3, [r7, #7]
    uint16_t mask;
    uint16_t data;

    MDIO_send_cmd( regad, MDIO_CMD_READ);
    85ca:	79fb      	ldrb	r3, [r7, #7]
    85cc:	4618      	mov	r0, r3
    85ce:	f04f 0100 	mov.w	r1, #0
    85d2:	f7ff ff73 	bl	84bc <MDIO_send_cmd>

    /* read data */
    data = 0;
    85d6:	f04f 0300 	mov.w	r3, #0
    85da:	81fb      	strh	r3, [r7, #14]
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    85dc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    85e0:	81bb      	strh	r3, [r7, #12]
    85e2:	e018      	b.n	8616 <MDIO_read+0x56>
    {
    	MDIO_management_clock( 0 );
    85e4:	f04f 0000 	mov.w	r0, #0
    85e8:	f7ff ff4c 	bl	8484 <MDIO_management_clock>

        /* read MDI */
        if(MAC_BITBAND-> CSR9_MDI != 0){
    85ec:	f240 0300 	movw	r3, #0
    85f0:	f2c4 2306 	movt	r3, #16902	; 0x4206
    85f4:	f8d3 394c 	ldr.w	r3, [r3, #2380]	; 0x94c
    85f8:	2b00      	cmp	r3, #0
    85fa:	d004      	beq.n	8606 <MDIO_read+0x46>
            data |= mask;
    85fc:	89fa      	ldrh	r2, [r7, #14]
    85fe:	89bb      	ldrh	r3, [r7, #12]
    8600:	ea42 0303 	orr.w	r3, r2, r3
    8604:	81fb      	strh	r3, [r7, #14]
        }

    	MDIO_management_clock( 1 );
    8606:	f04f 0001 	mov.w	r0, #1
    860a:	f7ff ff3b 	bl	8484 <MDIO_management_clock>

    MDIO_send_cmd( regad, MDIO_CMD_READ);

    /* read data */
    data = 0;
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    860e:	89bb      	ldrh	r3, [r7, #12]
    8610:	ea4f 0353 	mov.w	r3, r3, lsr #1
    8614:	81bb      	strh	r3, [r7, #12]
    8616:	89bb      	ldrh	r3, [r7, #12]
    8618:	2b00      	cmp	r3, #0
    861a:	d1e3      	bne.n	85e4 <MDIO_read+0x24>
        }

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    861c:	f04f 0000 	mov.w	r0, #0
    8620:	f7ff ff30 	bl	8484 <MDIO_management_clock>

    return data;
    8624:	89fb      	ldrh	r3, [r7, #14]
}
    8626:	4618      	mov	r0, r3
    8628:	f107 0710 	add.w	r7, r7, #16
    862c:	46bd      	mov	sp, r7
    862e:	bd80      	pop	{r7, pc}

00008630 <MDIO_write>:
MDIO_write
(
    uint8_t regad,
    uint16_t data
)
{
    8630:	b580      	push	{r7, lr}
    8632:	b084      	sub	sp, #16
    8634:	af00      	add	r7, sp, #0
    8636:	4602      	mov	r2, r0
    8638:	460b      	mov	r3, r1
    863a:	71fa      	strb	r2, [r7, #7]
    863c:	80bb      	strh	r3, [r7, #4]
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);
    863e:	79fb      	ldrb	r3, [r7, #7]
    8640:	4618      	mov	r0, r3
    8642:	f04f 0101 	mov.w	r1, #1
    8646:	f7ff ff39 	bl	84bc <MDIO_send_cmd>

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    864a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    864e:	81fb      	strh	r3, [r7, #14]
    8650:	e01d      	b.n	868e <MDIO_write+0x5e>
    {
    	MDIO_management_clock( 0 );
    8652:	f04f 0000 	mov.w	r0, #0
    8656:	f7ff ff15 	bl	8484 <MDIO_management_clock>

        /* prepare MDO */
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);
    865a:	f240 0300 	movw	r3, #0
    865e:	f2c4 2306 	movt	r3, #16902	; 0x4206
    8662:	89f9      	ldrh	r1, [r7, #14]
    8664:	88ba      	ldrh	r2, [r7, #4]
    8666:	ea01 0202 	and.w	r2, r1, r2
    866a:	b292      	uxth	r2, r2
    866c:	2a00      	cmp	r2, #0
    866e:	d002      	beq.n	8676 <MDIO_write+0x46>
    8670:	f04f 0201 	mov.w	r2, #1
    8674:	e001      	b.n	867a <MDIO_write+0x4a>
    8676:	f04f 0200 	mov.w	r2, #0
    867a:	f8c3 2944 	str.w	r2, [r3, #2372]	; 0x944

    	MDIO_management_clock( 1 );
    867e:	f04f 0001 	mov.w	r0, #1
    8682:	f7ff feff 	bl	8484 <MDIO_management_clock>
    uint16_t mask;

    MDIO_send_cmd(regad, MDIO_CMD_WRITE);

    /* write data */
    for( mask = 0x00008000L; mask>0; mask >>= 1 )
    8686:	89fb      	ldrh	r3, [r7, #14]
    8688:	ea4f 0353 	mov.w	r3, r3, lsr #1
    868c:	81fb      	strh	r3, [r7, #14]
    868e:	89fb      	ldrh	r3, [r7, #14]
    8690:	2b00      	cmp	r3, #0
    8692:	d1de      	bne.n	8652 <MDIO_write+0x22>
    	MAC_BITBAND->CSR9_MDO = (uint32_t)((mask & data) != 0 ? 1UL : 0UL);

    	MDIO_management_clock( 1 );
    }

    MDIO_management_clock( 0 );
    8694:	f04f 0000 	mov.w	r0, #0
    8698:	f7ff fef4 	bl	8484 <MDIO_management_clock>
}
    869c:	f107 0710 	add.w	r7, r7, #16
    86a0:	46bd      	mov	sp, r7
    86a2:	bd80      	pop	{r7, pc}

000086a4 <PHY_probe>:
 * Probe used PHY.
 *
 * return	PHY address. If PHY don't fount, returns 255.
 */
uint8_t PHY_probe( void )
{
    86a4:	b580      	push	{r7, lr}
    86a6:	b082      	sub	sp, #8
    86a8:	af00      	add	r7, sp, #0
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
    86aa:	f04f 0300 	mov.w	r3, #0
    86ae:	717b      	strb	r3, [r7, #5]
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    86b0:	f04f 0300 	mov.w	r3, #0
    86b4:	713b      	strb	r3, [r7, #4]
    86b6:	e01f      	b.n	86f8 <PHY_probe+0x54>
		g_mss_mac.phy_address = phy;
    86b8:	f247 1324 	movw	r3, #28964	; 0x7124
    86bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86c0:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    86c4:	793a      	ldrb	r2, [r7, #4]
    86c6:	701a      	strb	r2, [r3, #0]

        reg = MDIO_read( PHYREG_PHYID1R );
    86c8:	f04f 0002 	mov.w	r0, #2
    86cc:	f7ff ff78 	bl	85c0 <MDIO_read>
    86d0:	4603      	mov	r3, r0
    86d2:	80fb      	strh	r3, [r7, #6]

        if ((reg != 0x0000ffffUL) && (reg != 0x00000000UL)) {
    86d4:	88fa      	ldrh	r2, [r7, #6]
    86d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    86da:	429a      	cmp	r2, r3
    86dc:	d008      	beq.n	86f0 <PHY_probe+0x4c>
    86de:	88fb      	ldrh	r3, [r7, #6]
    86e0:	2b00      	cmp	r3, #0
    86e2:	d005      	beq.n	86f0 <PHY_probe+0x4c>
        	phy_found = 1;
    86e4:	f04f 0301 	mov.w	r3, #1
    86e8:	717b      	strb	r3, [r7, #5]
        	phy = MSS_PHY_ADDRESS_MAX + 1;
    86ea:	f04f 0320 	mov.w	r3, #32
    86ee:	713b      	strb	r3, [r7, #4]
	uint8_t phy;
	uint8_t phy_found;
	uint16_t reg;

	phy_found = 0;
	for (phy = MSS_PHY_ADDRESS_MIN; phy <= MSS_PHY_ADDRESS_MAX; phy++) {
    86f0:	793b      	ldrb	r3, [r7, #4]
    86f2:	f103 0301 	add.w	r3, r3, #1
    86f6:	713b      	strb	r3, [r7, #4]
    86f8:	793b      	ldrb	r3, [r7, #4]
    86fa:	2b1f      	cmp	r3, #31
    86fc:	d9dc      	bls.n	86b8 <PHY_probe+0x14>
        	phy_found = 1;
        	phy = MSS_PHY_ADDRESS_MAX + 1;
        }
    }

    if( phy_found == 0 ) {
    86fe:	797b      	ldrb	r3, [r7, #5]
    8700:	2b00      	cmp	r3, #0
    8702:	d108      	bne.n	8716 <PHY_probe+0x72>
    	g_mss_mac.phy_address = MSS_PHY_ADDRESS_AUTO_DETECT;
    8704:	f247 1324 	movw	r3, #28964	; 0x7124
    8708:	f2c2 0300 	movt	r3, #8192	; 0x2000
    870c:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8710:	f04f 32ff 	mov.w	r2, #4294967295
    8714:	701a      	strb	r2, [r3, #0]
    }
    return g_mss_mac.phy_address;
    8716:	f247 1324 	movw	r3, #28964	; 0x7124
    871a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    871e:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
    8722:	781b      	ldrb	r3, [r3, #0]
}
    8724:	4618      	mov	r0, r3
    8726:	f107 0708 	add.w	r7, r7, #8
    872a:	46bd      	mov	sp, r7
    872c:	bd80      	pop	{r7, pc}
    872e:	bf00      	nop

00008730 <PHY_reset>:

/***************************************************************************//**
 * Resets the PHY.
 */
void PHY_reset( void )
{
    8730:	b580      	push	{r7, lr}
    8732:	b082      	sub	sp, #8
    8734:	af00      	add	r7, sp, #0
	uint16_t phycr_reg;

	MDIO_write( PHYREG_MIIMCR, MIIMCR_RESET );
    8736:	f04f 0000 	mov.w	r0, #0
    873a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    873e:	f7ff ff77 	bl	8630 <MDIO_write>
	MDIO_write( PHYREG_MIIMCR,
    8742:	f04f 0000 	mov.w	r0, #0
    8746:	f44f 5194 	mov.w	r1, #4736	; 0x1280
    874a:	f7ff ff71 	bl	8630 <MDIO_write>
		MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		MIIMCR_COLLISION_TEST );

//MDIX HACK
	phycr_reg = MDIO_read(PHYREG_PHYCR);
    874e:	f04f 0019 	mov.w	r0, #25
    8752:	f7ff ff35 	bl	85c0 <MDIO_read>
    8756:	4603      	mov	r3, r0
    8758:	80fb      	strh	r3, [r7, #6]
	phycr_reg &= ~(MDIX_EN);
    875a:	88fb      	ldrh	r3, [r7, #6]
    875c:	ea4f 4343 	mov.w	r3, r3, lsl #17
    8760:	ea4f 4353 	mov.w	r3, r3, lsr #17
    8764:	80fb      	strh	r3, [r7, #6]
	phycr_reg |= FORCE_MDIX;
    8766:	88fb      	ldrh	r3, [r7, #6]
    8768:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    876c:	80fb      	strh	r3, [r7, #6]
	MDIO_write(PHYREG_PHYCR, phycr_reg);
    876e:	88fb      	ldrh	r3, [r7, #6]
    8770:	f04f 0019 	mov.w	r0, #25
    8774:	4619      	mov	r1, r3
    8776:	f7ff ff5b 	bl	8630 <MDIO_write>
}
    877a:	f107 0708 	add.w	r7, r7, #8
    877e:	46bd      	mov	sp, r7
    8780:	bd80      	pop	{r7, pc}
    8782:	bf00      	nop

00008784 <PHY_auto_negotiate>:

/***************************************************************************//**
 * Restarts PHY auto-negotiation and wait until it's over.
 */
void PHY_auto_negotiate( void )
{
    8784:	b580      	push	{r7, lr}
    8786:	b086      	sub	sp, #24
    8788:	af00      	add	r7, sp, #0
	int32_t a;
	uint16_t reg;
uint16_t bmcr, bmsr, anar, anlpar, aner, physts;
    int32_t exit = 1;
    878a:	f04f 0301 	mov.w	r3, #1
    878e:	617b      	str	r3, [r7, #20]

	reg = MDIO_read( PHYREG_MIIMCR );
    8790:	f04f 0000 	mov.w	r0, #0
    8794:	f7ff ff14 	bl	85c0 <MDIO_read>
    8798:	4603      	mov	r3, r0
    879a:	80fb      	strh	r3, [r7, #6]
	MDIO_write( PHYREG_MIIMCR,
    879c:	88fb      	ldrh	r3, [r7, #6]
    879e:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
    87a2:	b29b      	uxth	r3, r3
    87a4:	f04f 0000 	mov.w	r0, #0
    87a8:	4619      	mov	r1, r3
    87aa:	f7ff ff41 	bl	8630 <MDIO_write>
		(uint16_t)( MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		reg) );

	for(a=0; (a<1000) && (exit); a++) {
    87ae:	f04f 0300 	mov.w	r3, #0
    87b2:	603b      	str	r3, [r7, #0]
    87b4:	e035      	b.n	8822 <PHY_auto_negotiate+0x9e>
bmcr = MDIO_read( PHYREG_MIIMCR );
    87b6:	f04f 0000 	mov.w	r0, #0
    87ba:	f7ff ff01 	bl	85c0 <MDIO_read>
    87be:	4603      	mov	r3, r0
    87c0:	813b      	strh	r3, [r7, #8]
bmsr = MDIO_read( PHYREG_MIIMSR );
    87c2:	f04f 0001 	mov.w	r0, #1
    87c6:	f7ff fefb 	bl	85c0 <MDIO_read>
    87ca:	4603      	mov	r3, r0
    87cc:	817b      	strh	r3, [r7, #10]
anar = MDIO_read( PHYREG_ANAR );
    87ce:	f04f 0004 	mov.w	r0, #4
    87d2:	f7ff fef5 	bl	85c0 <MDIO_read>
    87d6:	4603      	mov	r3, r0
    87d8:	81bb      	strh	r3, [r7, #12]
anlpar = MDIO_read( PHYREG_ANLPAR );
    87da:	f04f 0005 	mov.w	r0, #5
    87de:	f7ff feef 	bl	85c0 <MDIO_read>
    87e2:	4603      	mov	r3, r0
    87e4:	81fb      	strh	r3, [r7, #14]
aner = MDIO_read( PHYREG_ANER );
    87e6:	f04f 0006 	mov.w	r0, #6
    87ea:	f7ff fee9 	bl	85c0 <MDIO_read>
    87ee:	4603      	mov	r3, r0
    87f0:	823b      	strh	r3, [r7, #16]
physts = MDIO_read( PHYREG_MFR );
    87f2:	f04f 0010 	mov.w	r0, #16
    87f6:	f7ff fee3 	bl	85c0 <MDIO_read>
    87fa:	4603      	mov	r3, r0
    87fc:	827b      	strh	r3, [r7, #18]
		reg = MDIO_read( PHYREG_MIIMSR );
    87fe:	f04f 0001 	mov.w	r0, #1
    8802:	f7ff fedd 	bl	85c0 <MDIO_read>
    8806:	4603      	mov	r3, r0
    8808:	80fb      	strh	r3, [r7, #6]
		if( (reg & MIIMSR_ANC) != 0 ) {
    880a:	88fb      	ldrh	r3, [r7, #6]
    880c:	f003 0320 	and.w	r3, r3, #32
    8810:	2b00      	cmp	r3, #0
    8812:	d002      	beq.n	881a <PHY_auto_negotiate+0x96>
			exit = 0;
    8814:	f04f 0300 	mov.w	r3, #0
    8818:	617b      	str	r3, [r7, #20]
	MDIO_write( PHYREG_MIIMCR,
		(uint16_t)( MIIMCR_ENABLE_AUTONEGOTIATION |
		MIIMCR_RESTART_AUTONEGOTIATION |
		reg) );

	for(a=0; (a<1000) && (exit); a++) {
    881a:	683b      	ldr	r3, [r7, #0]
    881c:	f103 0301 	add.w	r3, r3, #1
    8820:	603b      	str	r3, [r7, #0]
    8822:	683a      	ldr	r2, [r7, #0]
    8824:	f240 33e7 	movw	r3, #999	; 0x3e7
    8828:	429a      	cmp	r2, r3
    882a:	dc02      	bgt.n	8832 <PHY_auto_negotiate+0xae>
    882c:	697b      	ldr	r3, [r7, #20]
    882e:	2b00      	cmp	r3, #0
    8830:	d1c1      	bne.n	87b6 <PHY_auto_negotiate+0x32>
		reg = MDIO_read( PHYREG_MIIMSR );
		if( (reg & MIIMSR_ANC) != 0 ) {
			exit = 0;
		}
	}
}
    8832:	f107 0718 	add.w	r7, r7, #24
    8836:	46bd      	mov	sp, r7
    8838:	bd80      	pop	{r7, pc}
    883a:	bf00      	nop

0000883c <PHY_link_status>:
 * Returns link status.
 *
 * @return          #MAC_LINK_STATUS_LINK if link is up.
 */
uint8_t PHY_link_status( void )
{
    883c:	b580      	push	{r7, lr}
    883e:	b082      	sub	sp, #8
    8840:	af00      	add	r7, sp, #0
	uint8_t retval = 0;
    8842:	f04f 0300 	mov.w	r3, #0
    8846:	71fb      	strb	r3, [r7, #7]
	if(( MDIO_read( PHYREG_MIIMSR ) & MIIMSR_LINK ) != 0 ){
    8848:	f04f 0001 	mov.w	r0, #1
    884c:	f7ff feb8 	bl	85c0 <MDIO_read>
    8850:	4603      	mov	r3, r0
    8852:	f003 0304 	and.w	r3, r3, #4
    8856:	2b00      	cmp	r3, #0
    8858:	d002      	beq.n	8860 <PHY_link_status+0x24>
		retval = MSS_MAC_LINK_STATUS_LINK;
    885a:	f04f 0301 	mov.w	r3, #1
    885e:	71fb      	strb	r3, [r7, #7]
	}
	return retval;
    8860:	79fb      	ldrb	r3, [r7, #7]
}
    8862:	4618      	mov	r0, r3
    8864:	f107 0708 	add.w	r7, r7, #8
    8868:	46bd      	mov	sp, r7
    886a:	bd80      	pop	{r7, pc}

0000886c <PHY_link_type>:
 * @return          the logical OR of the following values:
 *      #MAC_LINK_STATUS_100MB   - Connection is 100Mb
 *      #MAC_LINK_STATUS_FDX     - Connection is full duplex
 */
uint8_t PHY_link_type( void )
{
    886c:	b580      	push	{r7, lr}
    886e:	b082      	sub	sp, #8
    8870:	af00      	add	r7, sp, #0
	uint16_t diagnostic;
	uint8_t type = 0;
    8872:	f04f 0300 	mov.w	r3, #0
    8876:	71fb      	strb	r3, [r7, #7]

	diagnostic = MDIO_read( PHYREG_DR );
    8878:	f04f 0012 	mov.w	r0, #18
    887c:	f7ff fea0 	bl	85c0 <MDIO_read>
    8880:	4603      	mov	r3, r0
    8882:	80bb      	strh	r3, [r7, #4]

    if( (diagnostic & DR_DPLX) != 0 ) {
    8884:	88bb      	ldrh	r3, [r7, #4]
    8886:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    888a:	2b00      	cmp	r3, #0
    888c:	d002      	beq.n	8894 <PHY_link_type+0x28>
    	type = MSS_MAC_LINK_STATUS_FDX;
    888e:	f04f 0304 	mov.w	r3, #4
    8892:	71fb      	strb	r3, [r7, #7]
    }

    if( (diagnostic & DR_DATA_RATE) != 0 ) {
    8894:	88bb      	ldrh	r3, [r7, #4]
    8896:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    889a:	2b00      	cmp	r3, #0
    889c:	d003      	beq.n	88a6 <PHY_link_type+0x3a>
    	type |= MSS_MAC_LINK_STATUS_100MB;
    889e:	79fb      	ldrb	r3, [r7, #7]
    88a0:	f043 0302 	orr.w	r3, r3, #2
    88a4:	71fb      	strb	r3, [r7, #7]
    }

    return type;
    88a6:	79fb      	ldrb	r3, [r7, #7]
}
    88a8:	4618      	mov	r0, r3
    88aa:	f107 0708 	add.w	r7, r7, #8
    88ae:	46bd      	mov	sp, r7
    88b0:	bd80      	pop	{r7, pc}
    88b2:	bf00      	nop

000088b4 <PHY_set_link_type>:
void
PHY_set_link_type
(
    uint8_t type
)
{
    88b4:	b580      	push	{r7, lr}
    88b6:	b084      	sub	sp, #16
    88b8:	af00      	add	r7, sp, #0
    88ba:	4603      	mov	r3, r0
    88bc:	71fb      	strb	r3, [r7, #7]
	uint16_t reg;

	reg = MDIO_read( PHYREG_ANAR );
    88be:	f04f 0004 	mov.w	r0, #4
    88c2:	f7ff fe7d 	bl	85c0 <MDIO_read>
    88c6:	4603      	mov	r3, r0
    88c8:	81fb      	strh	r3, [r7, #14]
	reg |= ANAR_100FD | ANAR_100HD | ANAR_10FD | ANAR_10HD;
    88ca:	89fb      	ldrh	r3, [r7, #14]
    88cc:	f443 73f0 	orr.w	r3, r3, #480	; 0x1e0
    88d0:	81fb      	strh	r3, [r7, #14]

	if( (type & MSS_MAC_LINK_STATUS_100MB) == 0 ) {
    88d2:	79fb      	ldrb	r3, [r7, #7]
    88d4:	f003 0302 	and.w	r3, r3, #2
    88d8:	2b00      	cmp	r3, #0
    88da:	d103      	bne.n	88e4 <PHY_set_link_type+0x30>
		reg &= ~(ANAR_100FD | ANAR_100HD);
    88dc:	89fb      	ldrh	r3, [r7, #14]
    88de:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
    88e2:	81fb      	strh	r3, [r7, #14]
	}

	if( (type & MSS_MAC_LINK_STATUS_FDX) == 0 ) {
    88e4:	79fb      	ldrb	r3, [r7, #7]
    88e6:	f003 0304 	and.w	r3, r3, #4
    88ea:	2b00      	cmp	r3, #0
    88ec:	d103      	bne.n	88f6 <PHY_set_link_type+0x42>
		reg &= ~(ANAR_100FD | ANAR_10FD);
    88ee:	89fb      	ldrh	r3, [r7, #14]
    88f0:	f423 73a0 	bic.w	r3, r3, #320	; 0x140
    88f4:	81fb      	strh	r3, [r7, #14]
	}

	MDIO_write( PHYREG_ANAR, reg );
    88f6:	89fb      	ldrh	r3, [r7, #14]
    88f8:	f04f 0004 	mov.w	r0, #4
    88fc:	4619      	mov	r1, r3
    88fe:	f7ff fe97 	bl	8630 <MDIO_write>
}
    8902:	f107 0710 	add.w	r7, r7, #16
    8906:	46bd      	mov	sp, r7
    8908:	bd80      	pop	{r7, pc}
    890a:	bf00      	nop

0000890c <SystemInit>:

/***************************************************************************//**
 * See system_a2fxxxm3f.h for details.
 */
void SystemInit(void)
{
    890c:	b480      	push	{r7}
    890e:	af00      	add	r7, sp, #0
    /*
     * Do not make use of global variables or make any asumptions regarding
     * memory content if modifying this function. The memory content has not been
     * initialised by the time this function is called by the start-up code.
     */
}
    8910:	46bd      	mov	sp, r7
    8912:	bc80      	pop	{r7}
    8914:	4770      	bx	lr
    8916:	bf00      	nop

00008918 <SystemCoreClockUpdate>:

/***************************************************************************//**
 *
 */
void SystemCoreClockUpdate (void)
{
    8918:	b580      	push	{r7, lr}
    891a:	b08a      	sub	sp, #40	; 0x28
    891c:	af00      	add	r7, sp, #0
    uint32_t PclkDiv0;
    uint32_t PclkDiv1;
    uint32_t AceDiv;
    uint32_t FabDiv;

    const uint32_t pclk_div_lut[4] = { 1uL, 2uL, 4uL, 1uL };
    891e:	f648 730c 	movw	r3, #36620	; 0x8f0c
    8922:	f2c0 0300 	movt	r3, #0
    8926:	46bc      	mov	ip, r7
    8928:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
    892a:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    /* Read PCLK dividers from system registers. Multiply the value read from
     * system register by two to get actual divider value. */
    PclkDiv0 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK0_DIV_SHIFT) & PCLK_DIV_MASK)];
    892e:	f242 0300 	movw	r3, #8192	; 0x2000
    8932:	f2ce 0304 	movt	r3, #57348	; 0xe004
    8936:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    8938:	ea4f 0393 	mov.w	r3, r3, lsr #2
    893c:	f003 0303 	and.w	r3, r3, #3
    8940:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8944:	f107 0228 	add.w	r2, r7, #40	; 0x28
    8948:	4413      	add	r3, r2
    894a:	f853 3c28 	ldr.w	r3, [r3, #-40]
    894e:	613b      	str	r3, [r7, #16]
    PclkDiv1 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK1_DIV_SHIFT) & PCLK_DIV_MASK)];
    8950:	f242 0300 	movw	r3, #8192	; 0x2000
    8954:	f2ce 0304 	movt	r3, #57348	; 0xe004
    8958:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    895a:	ea4f 1313 	mov.w	r3, r3, lsr #4
    895e:	f003 0303 	and.w	r3, r3, #3
    8962:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8966:	f107 0228 	add.w	r2, r7, #40	; 0x28
    896a:	4413      	add	r3, r2
    896c:	f853 3c28 	ldr.w	r3, [r3, #-40]
    8970:	617b      	str	r3, [r7, #20]
    AceDiv = pclk_div_lut[((SYSREG->MSS_CLK_CR >> ACE_DIV_SHIFT) & PCLK_DIV_MASK)];
    8972:	f242 0300 	movw	r3, #8192	; 0x2000
    8976:	f2ce 0304 	movt	r3, #57348	; 0xe004
    897a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    897c:	ea4f 1393 	mov.w	r3, r3, lsr #6
    8980:	f003 0303 	and.w	r3, r3, #3
    8984:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8988:	f107 0228 	add.w	r2, r7, #40	; 0x28
    898c:	4413      	add	r3, r2
    898e:	f853 3c28 	ldr.w	r3, [r3, #-40]
    8992:	61bb      	str	r3, [r7, #24]
    {
        /* Compute the FPGA fabric frequency divider. */
        uint32_t obdiv;
        uint32_t obdivhalf;
        
        obdiv = (SYSREG->MSS_CCC_DIV_CR >> OBDIV_SHIFT) & OBDIV_MASK;
    8994:	f242 0300 	movw	r3, #8192	; 0x2000
    8998:	f2ce 0304 	movt	r3, #57348	; 0xe004
    899c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    899e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    89a2:	f003 031f 	and.w	r3, r3, #31
    89a6:	623b      	str	r3, [r7, #32]
        obdivhalf = (SYSREG->MSS_CCC_DIV_CR >> OBDIVHALF_SHIFT) & OBDIVHALF_MASK;
    89a8:	f242 0300 	movw	r3, #8192	; 0x2000
    89ac:	f2ce 0304 	movt	r3, #57348	; 0xe004
    89b0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    89b2:	ea4f 3353 	mov.w	r3, r3, lsr #13
    89b6:	f003 0301 	and.w	r3, r3, #1
    89ba:	627b      	str	r3, [r7, #36]	; 0x24
        FabDiv = obdiv + 1uL;
    89bc:	6a3b      	ldr	r3, [r7, #32]
    89be:	f103 0301 	add.w	r3, r3, #1
    89c2:	61fb      	str	r3, [r7, #28]
        if ( obdivhalf != 0uL )
    89c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    89c6:	2b00      	cmp	r3, #0
    89c8:	d003      	beq.n	89d2 <SystemCoreClockUpdate+0xba>
        {
            FabDiv = FabDiv * 2uL;
    89ca:	69fb      	ldr	r3, [r7, #28]
    89cc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    89d0:	61fb      	str	r3, [r7, #28]
    }
    
    /* Retrieve FCLK from eNVM spare pages if Actel system boot programmed as part of the system. */
    
    /* Read system clock from eNVM spare pages. */
    SystemCoreClock = GetSystemClock();
    89d2:	f000 f849 	bl	8a68 <GetSystemClock>
    89d6:	4602      	mov	r2, r0
    89d8:	f240 030c 	movw	r3, #12
    89dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89e0:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = SystemCoreClock / PclkDiv0;
    89e2:	f240 030c 	movw	r3, #12
    89e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89ea:	681a      	ldr	r2, [r3, #0]
    89ec:	693b      	ldr	r3, [r7, #16]
    89ee:	fbb2 f2f3 	udiv	r2, r2, r3
    89f2:	f240 0310 	movw	r3, #16
    89f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89fa:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = SystemCoreClock / PclkDiv1;
    89fc:	f240 030c 	movw	r3, #12
    8a00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a04:	681a      	ldr	r2, [r3, #0]
    8a06:	697b      	ldr	r3, [r7, #20]
    8a08:	fbb2 f2f3 	udiv	r2, r2, r3
    8a0c:	f240 0314 	movw	r3, #20
    8a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a14:	601a      	str	r2, [r3, #0]
    g_FrequencyACE = SystemCoreClock / AceDiv;
    8a16:	f240 030c 	movw	r3, #12
    8a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a1e:	681a      	ldr	r2, [r3, #0]
    8a20:	69bb      	ldr	r3, [r7, #24]
    8a22:	fbb2 f2f3 	udiv	r2, r2, r3
    8a26:	f240 0318 	movw	r3, #24
    8a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a2e:	601a      	str	r2, [r3, #0]
    g_FrequencyFPGA = SystemCoreClock / FabDiv;
    8a30:	f240 030c 	movw	r3, #12
    8a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a38:	681a      	ldr	r2, [r3, #0]
    8a3a:	69fb      	ldr	r3, [r7, #28]
    8a3c:	fbb2 f2f3 	udiv	r2, r2, r3
    8a40:	f240 031c 	movw	r3, #28
    8a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a48:	601a      	str	r2, [r3, #0]
    
    /* Keep SystemFrequency as well as SystemCoreClock for legacy reasons. */
    SystemFrequency = SystemCoreClock;
    8a4a:	f240 030c 	movw	r3, #12
    8a4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a52:	681a      	ldr	r2, [r3, #0]
    8a54:	f240 0308 	movw	r3, #8
    8a58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a5c:	601a      	str	r2, [r3, #0]
}
    8a5e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    8a62:	46bd      	mov	sp, r7
    8a64:	bd80      	pop	{r7, pc}
    8a66:	bf00      	nop

00008a68 <GetSystemClock>:
 * retrieved from eNVM spare pages.
 * The FCLK frequency value selected in the MSS Configurator software tool is
 * stored in eNVM spare pages as part of the Actel system boot configuration data.
 */
uint32_t GetSystemClock( void )
{
    8a68:	b480      	push	{r7}
    8a6a:	b08b      	sub	sp, #44	; 0x2c
    8a6c:	af00      	add	r7, sp, #0
    uint32_t fclk = 0uL;
    8a6e:	f04f 0300 	mov.w	r3, #0
    8a72:	607b      	str	r3, [r7, #4]
    
    uint32_t * p_sysboot_key = SYSBOOT_KEY_ADDR;
    8a74:	f640 031c 	movw	r3, #2076	; 0x81c
    8a78:	f2c6 0308 	movt	r3, #24584	; 0x6008
    8a7c:	60bb      	str	r3, [r7, #8]
    uint32_t * p_idcode = IDCODE_LOCATION;
    8a7e:	f240 2330 	movw	r3, #560	; 0x230
    8a82:	f2c6 0308 	movt	r3, #24584	; 0x6008
    8a86:	60fb      	str	r3, [r7, #12]
    uint32_t idcode;
	
    idcode = *p_idcode & ~IDCODE_DEV_REV_MASK;
    8a88:	68fb      	ldr	r3, [r7, #12]
    8a8a:	681b      	ldr	r3, [r3, #0]
    8a8c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    8a90:	613b      	str	r3, [r7, #16]
	
    if ( A2F060IFX_ID == idcode )
    8a92:	693a      	ldr	r2, [r7, #16]
    8a94:	f241 13cf 	movw	r3, #4559	; 0x11cf
    8a98:	f2c0 53a1 	movt	r3, #1441	; 0x5a1
    8a9c:	429a      	cmp	r2, r3
    8a9e:	d108      	bne.n	8ab2 <GetSystemClock+0x4a>
    {
        uint32_t *p_fclk = SYSBOOT_A2F060_FCLK_ADDR;
    8aa0:	f64e 732c 	movw	r3, #61228	; 0xef2c
    8aa4:	f2c6 0301 	movt	r3, #24577	; 0x6001
    8aa8:	617b      	str	r3, [r7, #20]
        fclk = *p_fclk;
    8aaa:	697b      	ldr	r3, [r7, #20]
    8aac:	681b      	ldr	r3, [r3, #0]
    8aae:	607b      	str	r3, [r7, #4]
    8ab0:	e03d      	b.n	8b2e <GetSystemClock+0xc6>
    }
    else if ( SYSBOOT_KEY_VALUE == *p_sysboot_key )
    8ab2:	68bb      	ldr	r3, [r7, #8]
    8ab4:	681a      	ldr	r2, [r3, #0]
    8ab6:	f244 3341 	movw	r3, #17217	; 0x4341
    8aba:	f6c4 4354 	movt	r3, #19540	; 0x4c54
    8abe:	429a      	cmp	r2, r3
    8ac0:	d135      	bne.n	8b2e <GetSystemClock+0xc6>
    {
        /* Actel system boot programmed, check if it has the FCLK value stored. */
        uint32_t *p_sysboot_version = SYSBOOT_VERSION_ADDR;
    8ac2:	f640 0340 	movw	r3, #2112	; 0x840
    8ac6:	f2c6 0308 	movt	r3, #24584	; 0x6008
    8aca:	61bb      	str	r3, [r7, #24]
        uint32_t sysboot_version = *p_sysboot_version;
    8acc:	69bb      	ldr	r3, [r7, #24]
    8ace:	681b      	ldr	r3, [r3, #0]
    8ad0:	61fb      	str	r3, [r7, #28]
        
        sysboot_version &= SYSBOOT_VERSION_MASK;
    8ad2:	69fb      	ldr	r3, [r7, #28]
    8ad4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8ad8:	61fb      	str	r3, [r7, #28]
        
        if ( sysboot_version >= MIN_SYSBOOT_VERSION )
    8ada:	69fa      	ldr	r2, [r7, #28]
    8adc:	f240 3300 	movw	r3, #768	; 0x300
    8ae0:	f2c0 0301 	movt	r3, #1
    8ae4:	429a      	cmp	r2, r3
    8ae6:	d922      	bls.n	8b2e <GetSystemClock+0xc6>
        {
            /* Handle change of eNVM location of FCLK between 1.3.x and 2.x.x versions of the system boot. */
            if ( sysboot_version < SYSBOOT_VERSION_2_X )
    8ae8:	69fa      	ldr	r2, [r7, #28]
    8aea:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8aee:	f2c0 0301 	movt	r3, #1
    8af2:	429a      	cmp	r2, r3
    8af4:	d808      	bhi.n	8b08 <GetSystemClock+0xa0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 1.3.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_1_3_FCLK_ADDR;
    8af6:	f241 632c 	movw	r3, #5676	; 0x162c
    8afa:	f2c6 0308 	movt	r3, #24584	; 0x6008
    8afe:	623b      	str	r3, [r7, #32]
                fclk = *p_fclk;
    8b00:	6a3b      	ldr	r3, [r7, #32]
    8b02:	681b      	ldr	r3, [r3, #0]
    8b04:	607b      	str	r3, [r7, #4]
    8b06:	e012      	b.n	8b2e <GetSystemClock+0xc6>
            }
            else if ( sysboot_version < MAX_SYSBOOT_VERSION )
    8b08:	69fa      	ldr	r2, [r7, #28]
    8b0a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8b0e:	f2c0 0302 	movt	r3, #2
    8b12:	429a      	cmp	r2, r3
    8b14:	d808      	bhi.n	8b28 <GetSystemClock+0xc0>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 2.x.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_2_x_FCLK_ADDR;
    8b16:	f641 63ac 	movw	r3, #7852	; 0x1eac
    8b1a:	f2c6 0308 	movt	r3, #24584	; 0x6008
    8b1e:	627b      	str	r3, [r7, #36]	; 0x24
                fclk = *p_fclk;
    8b20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8b22:	681b      	ldr	r3, [r3, #0]
    8b24:	607b      	str	r3, [r7, #4]
    8b26:	e002      	b.n	8b2e <GetSystemClock+0xc6>
            }
            else
            {
                fclk = 0uL;
    8b28:	f04f 0300 	mov.w	r3, #0
    8b2c:	607b      	str	r3, [r7, #4]
            }
        }
    }
    
    if ( 0uL == fclk )
    8b2e:	687b      	ldr	r3, [r7, #4]
    8b30:	2b00      	cmp	r3, #0
    8b32:	d105      	bne.n	8b40 <GetSystemClock+0xd8>
        /* 
         * Could not retrieve FCLK from system boot configuration data. Fall back
         * to using SMARTFUSION_FCLK_FREQ which must then be defined as part of
         * project settings.
         */
        ASSERT( SMARTFUSION_FCLK_FREQ_DEFINED );
    8b34:	be00      	bkpt	0x0000
        fclk = SMARTFUSION_FCLK_FREQ;
    8b36:	f647 0340 	movw	r3, #30784	; 0x7840
    8b3a:	f2c0 137d 	movt	r3, #381	; 0x17d
    8b3e:	607b      	str	r3, [r7, #4]
    }
    
    return fclk;
    8b40:	687b      	ldr	r3, [r7, #4]
}
    8b42:	4618      	mov	r0, r3
    8b44:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    8b48:	46bd      	mov	sp, r7
    8b4a:	bc80      	pop	{r7}
    8b4c:	4770      	bx	lr
    8b4e:	bf00      	nop

00008b50 <mss_mac_crc32>:
(
    uint32_t value,
    const uint8_t *data,
    uint32_t data_length
)
{
    8b50:	b480      	push	{r7}
    8b52:	b087      	sub	sp, #28
    8b54:	af00      	add	r7, sp, #0
    8b56:	60f8      	str	r0, [r7, #12]
    8b58:	60b9      	str	r1, [r7, #8]
    8b5a:	607a      	str	r2, [r7, #4]
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    8b5c:	f04f 0300 	mov.w	r3, #0
    8b60:	617b      	str	r3, [r7, #20]
    8b62:	e019      	b.n	8b98 <mss_mac_crc32+0x48>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
    8b64:	68ba      	ldr	r2, [r7, #8]
    8b66:	697b      	ldr	r3, [r7, #20]
    8b68:	4413      	add	r3, r2
    8b6a:	781b      	ldrb	r3, [r3, #0]
    8b6c:	461a      	mov	r2, r3
    8b6e:	68fb      	ldr	r3, [r7, #12]
    8b70:	ea82 0303 	eor.w	r3, r2, r3
    8b74:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    8b78:	f648 731c 	movw	r3, #36636	; 0x8f1c
    8b7c:	f2c0 0300 	movt	r3, #0
    8b80:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    8b84:	68fb      	ldr	r3, [r7, #12]
    8b86:	ea4f 2313 	mov.w	r3, r3, lsr #8
    8b8a:	ea82 0303 	eor.w	r3, r2, r3
    8b8e:	60fb      	str	r3, [r7, #12]
    uint32_t data_length
)
{
  uint32_t a;
  
  for(a=0; a<data_length; a++) {
    8b90:	697b      	ldr	r3, [r7, #20]
    8b92:	f103 0301 	add.w	r3, r3, #1
    8b96:	617b      	str	r3, [r7, #20]
    8b98:	697a      	ldr	r2, [r7, #20]
    8b9a:	687b      	ldr	r3, [r7, #4]
    8b9c:	429a      	cmp	r2, r3
    8b9e:	d3e1      	bcc.n	8b64 <mss_mac_crc32+0x14>
	value = crc32_table[(value ^ data[a]) & 0xff] ^ (value >> 8);
  }
  
  return value;
    8ba0:	68fb      	ldr	r3, [r7, #12]
}
    8ba2:	4618      	mov	r0, r3
    8ba4:	f107 071c 	add.w	r7, r7, #28
    8ba8:	46bd      	mov	sp, r7
    8baa:	bc80      	pop	{r7}
    8bac:	4770      	bx	lr
    8bae:	bf00      	nop

00008bb0 <mss_ethernet_crc>:
mss_ethernet_crc
(
    const uint8_t *data,
    uint32_t data_length
)
{
    8bb0:	b580      	push	{r7, lr}
    8bb2:	b082      	sub	sp, #8
    8bb4:	af00      	add	r7, sp, #0
    8bb6:	6078      	str	r0, [r7, #4]
    8bb8:	6039      	str	r1, [r7, #0]
	return mss_mac_crc32( 0xffffffffUL, data, data_length );
    8bba:	f04f 30ff 	mov.w	r0, #4294967295
    8bbe:	6879      	ldr	r1, [r7, #4]
    8bc0:	683a      	ldr	r2, [r7, #0]
    8bc2:	f7ff ffc5 	bl	8b50 <mss_mac_crc32>
    8bc6:	4603      	mov	r3, r0
}
    8bc8:	4618      	mov	r0, r3
    8bca:	f107 0708 	add.w	r7, r7, #8
    8bce:	46bd      	mov	sp, r7
    8bd0:	bd80      	pop	{r7, pc}
    8bd2:	bf00      	nop

00008bd4 <__libc_init_array>:
    8bd4:	b570      	push	{r4, r5, r6, lr}
    8bd6:	f249 3634 	movw	r6, #37684	; 0x9334
    8bda:	f249 3534 	movw	r5, #37684	; 0x9334
    8bde:	f2c0 0600 	movt	r6, #0
    8be2:	f2c0 0500 	movt	r5, #0
    8be6:	1b76      	subs	r6, r6, r5
    8be8:	10b6      	asrs	r6, r6, #2
    8bea:	d006      	beq.n	8bfa <__libc_init_array+0x26>
    8bec:	2400      	movs	r4, #0
    8bee:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    8bf2:	3401      	adds	r4, #1
    8bf4:	4798      	blx	r3
    8bf6:	42a6      	cmp	r6, r4
    8bf8:	d8f9      	bhi.n	8bee <__libc_init_array+0x1a>
    8bfa:	f249 3534 	movw	r5, #37684	; 0x9334
    8bfe:	f249 3638 	movw	r6, #37688	; 0x9338
    8c02:	f2c0 0500 	movt	r5, #0
    8c06:	f2c0 0600 	movt	r6, #0
    8c0a:	1b76      	subs	r6, r6, r5
    8c0c:	f000 fb86 	bl	931c <_init>
    8c10:	10b6      	asrs	r6, r6, #2
    8c12:	d006      	beq.n	8c22 <__libc_init_array+0x4e>
    8c14:	2400      	movs	r4, #0
    8c16:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    8c1a:	3401      	adds	r4, #1
    8c1c:	4798      	blx	r3
    8c1e:	42a6      	cmp	r6, r4
    8c20:	d8f9      	bhi.n	8c16 <__libc_init_array+0x42>
    8c22:	bd70      	pop	{r4, r5, r6, pc}

00008c24 <memcpy>:
    8c24:	2a03      	cmp	r2, #3
    8c26:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
    8c2a:	d80b      	bhi.n	8c44 <memcpy+0x20>
    8c2c:	b13a      	cbz	r2, 8c3e <memcpy+0x1a>
    8c2e:	2300      	movs	r3, #0
    8c30:	f811 c003 	ldrb.w	ip, [r1, r3]
    8c34:	f800 c003 	strb.w	ip, [r0, r3]
    8c38:	3301      	adds	r3, #1
    8c3a:	4293      	cmp	r3, r2
    8c3c:	d1f8      	bne.n	8c30 <memcpy+0xc>
    8c3e:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
    8c42:	4770      	bx	lr
    8c44:	1882      	adds	r2, r0, r2
    8c46:	460c      	mov	r4, r1
    8c48:	4603      	mov	r3, r0
    8c4a:	e003      	b.n	8c54 <memcpy+0x30>
    8c4c:	f814 1c01 	ldrb.w	r1, [r4, #-1]
    8c50:	f803 1c01 	strb.w	r1, [r3, #-1]
    8c54:	f003 0603 	and.w	r6, r3, #3
    8c58:	4619      	mov	r1, r3
    8c5a:	46a4      	mov	ip, r4
    8c5c:	3301      	adds	r3, #1
    8c5e:	3401      	adds	r4, #1
    8c60:	2e00      	cmp	r6, #0
    8c62:	d1f3      	bne.n	8c4c <memcpy+0x28>
    8c64:	f01c 0403 	ands.w	r4, ip, #3
    8c68:	4663      	mov	r3, ip
    8c6a:	bf08      	it	eq
    8c6c:	ebc1 0c02 	rsbeq	ip, r1, r2
    8c70:	d068      	beq.n	8d44 <memcpy+0x120>
    8c72:	4265      	negs	r5, r4
    8c74:	f1c4 0a04 	rsb	sl, r4, #4
    8c78:	eb0c 0705 	add.w	r7, ip, r5
    8c7c:	4633      	mov	r3, r6
    8c7e:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    8c82:	f85c 6005 	ldr.w	r6, [ip, r5]
    8c86:	ea4f 08c4 	mov.w	r8, r4, lsl #3
    8c8a:	1a55      	subs	r5, r2, r1
    8c8c:	e008      	b.n	8ca0 <memcpy+0x7c>
    8c8e:	f857 4f04 	ldr.w	r4, [r7, #4]!
    8c92:	4626      	mov	r6, r4
    8c94:	fa04 f40a 	lsl.w	r4, r4, sl
    8c98:	ea49 0404 	orr.w	r4, r9, r4
    8c9c:	50cc      	str	r4, [r1, r3]
    8c9e:	3304      	adds	r3, #4
    8ca0:	185c      	adds	r4, r3, r1
    8ca2:	2d03      	cmp	r5, #3
    8ca4:	fa26 f908 	lsr.w	r9, r6, r8
    8ca8:	f1a5 0504 	sub.w	r5, r5, #4
    8cac:	eb0c 0603 	add.w	r6, ip, r3
    8cb0:	dced      	bgt.n	8c8e <memcpy+0x6a>
    8cb2:	2300      	movs	r3, #0
    8cb4:	e002      	b.n	8cbc <memcpy+0x98>
    8cb6:	5cf1      	ldrb	r1, [r6, r3]
    8cb8:	54e1      	strb	r1, [r4, r3]
    8cba:	3301      	adds	r3, #1
    8cbc:	1919      	adds	r1, r3, r4
    8cbe:	4291      	cmp	r1, r2
    8cc0:	d3f9      	bcc.n	8cb6 <memcpy+0x92>
    8cc2:	e7bc      	b.n	8c3e <memcpy+0x1a>
    8cc4:	f853 4c40 	ldr.w	r4, [r3, #-64]
    8cc8:	f841 4c40 	str.w	r4, [r1, #-64]
    8ccc:	f853 4c3c 	ldr.w	r4, [r3, #-60]
    8cd0:	f841 4c3c 	str.w	r4, [r1, #-60]
    8cd4:	f853 4c38 	ldr.w	r4, [r3, #-56]
    8cd8:	f841 4c38 	str.w	r4, [r1, #-56]
    8cdc:	f853 4c34 	ldr.w	r4, [r3, #-52]
    8ce0:	f841 4c34 	str.w	r4, [r1, #-52]
    8ce4:	f853 4c30 	ldr.w	r4, [r3, #-48]
    8ce8:	f841 4c30 	str.w	r4, [r1, #-48]
    8cec:	f853 4c2c 	ldr.w	r4, [r3, #-44]
    8cf0:	f841 4c2c 	str.w	r4, [r1, #-44]
    8cf4:	f853 4c28 	ldr.w	r4, [r3, #-40]
    8cf8:	f841 4c28 	str.w	r4, [r1, #-40]
    8cfc:	f853 4c24 	ldr.w	r4, [r3, #-36]
    8d00:	f841 4c24 	str.w	r4, [r1, #-36]
    8d04:	f853 4c20 	ldr.w	r4, [r3, #-32]
    8d08:	f841 4c20 	str.w	r4, [r1, #-32]
    8d0c:	f853 4c1c 	ldr.w	r4, [r3, #-28]
    8d10:	f841 4c1c 	str.w	r4, [r1, #-28]
    8d14:	f853 4c18 	ldr.w	r4, [r3, #-24]
    8d18:	f841 4c18 	str.w	r4, [r1, #-24]
    8d1c:	f853 4c14 	ldr.w	r4, [r3, #-20]
    8d20:	f841 4c14 	str.w	r4, [r1, #-20]
    8d24:	f853 4c10 	ldr.w	r4, [r3, #-16]
    8d28:	f841 4c10 	str.w	r4, [r1, #-16]
    8d2c:	f853 4c0c 	ldr.w	r4, [r3, #-12]
    8d30:	f841 4c0c 	str.w	r4, [r1, #-12]
    8d34:	f853 4c08 	ldr.w	r4, [r3, #-8]
    8d38:	f841 4c08 	str.w	r4, [r1, #-8]
    8d3c:	f853 4c04 	ldr.w	r4, [r3, #-4]
    8d40:	f841 4c04 	str.w	r4, [r1, #-4]
    8d44:	461c      	mov	r4, r3
    8d46:	460d      	mov	r5, r1
    8d48:	3340      	adds	r3, #64	; 0x40
    8d4a:	3140      	adds	r1, #64	; 0x40
    8d4c:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
    8d50:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
    8d54:	dcb6      	bgt.n	8cc4 <memcpy+0xa0>
    8d56:	4621      	mov	r1, r4
    8d58:	462b      	mov	r3, r5
    8d5a:	1b54      	subs	r4, r2, r5
    8d5c:	e00f      	b.n	8d7e <memcpy+0x15a>
    8d5e:	f851 5c10 	ldr.w	r5, [r1, #-16]
    8d62:	f843 5c10 	str.w	r5, [r3, #-16]
    8d66:	f851 5c0c 	ldr.w	r5, [r1, #-12]
    8d6a:	f843 5c0c 	str.w	r5, [r3, #-12]
    8d6e:	f851 5c08 	ldr.w	r5, [r1, #-8]
    8d72:	f843 5c08 	str.w	r5, [r3, #-8]
    8d76:	f851 5c04 	ldr.w	r5, [r1, #-4]
    8d7a:	f843 5c04 	str.w	r5, [r3, #-4]
    8d7e:	2c0f      	cmp	r4, #15
    8d80:	460d      	mov	r5, r1
    8d82:	469c      	mov	ip, r3
    8d84:	f101 0110 	add.w	r1, r1, #16
    8d88:	f103 0310 	add.w	r3, r3, #16
    8d8c:	f1a4 0410 	sub.w	r4, r4, #16
    8d90:	dce5      	bgt.n	8d5e <memcpy+0x13a>
    8d92:	ebcc 0102 	rsb	r1, ip, r2
    8d96:	2300      	movs	r3, #0
    8d98:	e003      	b.n	8da2 <memcpy+0x17e>
    8d9a:	58ec      	ldr	r4, [r5, r3]
    8d9c:	f84c 4003 	str.w	r4, [ip, r3]
    8da0:	3304      	adds	r3, #4
    8da2:	195e      	adds	r6, r3, r5
    8da4:	2903      	cmp	r1, #3
    8da6:	eb03 040c 	add.w	r4, r3, ip
    8daa:	f1a1 0104 	sub.w	r1, r1, #4
    8dae:	dcf4      	bgt.n	8d9a <memcpy+0x176>
    8db0:	e77f      	b.n	8cb2 <memcpy+0x8e>
    8db2:	bf00      	nop

00008db4 <memset>:
    8db4:	2a03      	cmp	r2, #3
    8db6:	b2c9      	uxtb	r1, r1
    8db8:	b430      	push	{r4, r5}
    8dba:	d807      	bhi.n	8dcc <memset+0x18>
    8dbc:	b122      	cbz	r2, 8dc8 <memset+0x14>
    8dbe:	2300      	movs	r3, #0
    8dc0:	54c1      	strb	r1, [r0, r3]
    8dc2:	3301      	adds	r3, #1
    8dc4:	4293      	cmp	r3, r2
    8dc6:	d1fb      	bne.n	8dc0 <memset+0xc>
    8dc8:	bc30      	pop	{r4, r5}
    8dca:	4770      	bx	lr
    8dcc:	eb00 0c02 	add.w	ip, r0, r2
    8dd0:	4603      	mov	r3, r0
    8dd2:	e001      	b.n	8dd8 <memset+0x24>
    8dd4:	f803 1c01 	strb.w	r1, [r3, #-1]
    8dd8:	f003 0403 	and.w	r4, r3, #3
    8ddc:	461a      	mov	r2, r3
    8dde:	3301      	adds	r3, #1
    8de0:	2c00      	cmp	r4, #0
    8de2:	d1f7      	bne.n	8dd4 <memset+0x20>
    8de4:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
    8de8:	ebc2 040c 	rsb	r4, r2, ip
    8dec:	fb03 f301 	mul.w	r3, r3, r1
    8df0:	e01f      	b.n	8e32 <memset+0x7e>
    8df2:	f842 3c40 	str.w	r3, [r2, #-64]
    8df6:	f842 3c3c 	str.w	r3, [r2, #-60]
    8dfa:	f842 3c38 	str.w	r3, [r2, #-56]
    8dfe:	f842 3c34 	str.w	r3, [r2, #-52]
    8e02:	f842 3c30 	str.w	r3, [r2, #-48]
    8e06:	f842 3c2c 	str.w	r3, [r2, #-44]
    8e0a:	f842 3c28 	str.w	r3, [r2, #-40]
    8e0e:	f842 3c24 	str.w	r3, [r2, #-36]
    8e12:	f842 3c20 	str.w	r3, [r2, #-32]
    8e16:	f842 3c1c 	str.w	r3, [r2, #-28]
    8e1a:	f842 3c18 	str.w	r3, [r2, #-24]
    8e1e:	f842 3c14 	str.w	r3, [r2, #-20]
    8e22:	f842 3c10 	str.w	r3, [r2, #-16]
    8e26:	f842 3c0c 	str.w	r3, [r2, #-12]
    8e2a:	f842 3c08 	str.w	r3, [r2, #-8]
    8e2e:	f842 3c04 	str.w	r3, [r2, #-4]
    8e32:	4615      	mov	r5, r2
    8e34:	3240      	adds	r2, #64	; 0x40
    8e36:	2c3f      	cmp	r4, #63	; 0x3f
    8e38:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
    8e3c:	dcd9      	bgt.n	8df2 <memset+0x3e>
    8e3e:	462a      	mov	r2, r5
    8e40:	ebc5 040c 	rsb	r4, r5, ip
    8e44:	e007      	b.n	8e56 <memset+0xa2>
    8e46:	f842 3c10 	str.w	r3, [r2, #-16]
    8e4a:	f842 3c0c 	str.w	r3, [r2, #-12]
    8e4e:	f842 3c08 	str.w	r3, [r2, #-8]
    8e52:	f842 3c04 	str.w	r3, [r2, #-4]
    8e56:	4615      	mov	r5, r2
    8e58:	3210      	adds	r2, #16
    8e5a:	2c0f      	cmp	r4, #15
    8e5c:	f1a4 0410 	sub.w	r4, r4, #16
    8e60:	dcf1      	bgt.n	8e46 <memset+0x92>
    8e62:	462a      	mov	r2, r5
    8e64:	ebc5 050c 	rsb	r5, r5, ip
    8e68:	e001      	b.n	8e6e <memset+0xba>
    8e6a:	f842 3c04 	str.w	r3, [r2, #-4]
    8e6e:	4614      	mov	r4, r2
    8e70:	3204      	adds	r2, #4
    8e72:	2d03      	cmp	r5, #3
    8e74:	f1a5 0504 	sub.w	r5, r5, #4
    8e78:	dcf7      	bgt.n	8e6a <memset+0xb6>
    8e7a:	e001      	b.n	8e80 <memset+0xcc>
    8e7c:	f804 1b01 	strb.w	r1, [r4], #1
    8e80:	4564      	cmp	r4, ip
    8e82:	d3fb      	bcc.n	8e7c <memset+0xc8>
    8e84:	e7a0      	b.n	8dc8 <memset+0x14>
    8e86:	bf00      	nop

00008e88 <ethbroadcast>:
    8e88:	ffff ffff ffff 0000                         ........

00008e90 <ethzero>:
	...

00008e98 <memp_sizes>:
    8e98:	001c 0020 0020 0018 0010 0010 0260 0000     .. . .......`...

00008ea8 <memp_num>:
    8ea8:	0004 0004 0005 000f 0003 0010 0010 0000     ................

00008eb8 <ip_addr_any>:
    8eb8:	0000 0000                                   ....

00008ebc <src_dest_to_ctrl_reg_lut>:
    8ebc:	0001 0000 0003 0080 0001 0100 0003 0180     ................
    8ecc:	0001 0200 0003 0280 0001 0300 0003 0380     ................
    8edc:	0001 0400 0003 0400 0001 0480 0003 0480     ................
    8eec:	0003 0500 0001 0580                         ........

00008ef4 <g_pdma_status_mask>:
    8ef4:	0003 000c 0030 00c0 0300 0c00 3000 c000     ....0........0..

00008f04 <C.18.2827>:
    8f04:	b1c0 883c 8888 0000                         ..<.....

00008f0c <C.18.2576>:
    8f0c:	0001 0000 0002 0000 0004 0000 0001 0000     ................

00008f1c <crc32_table>:
    8f1c:	0000 0000 3096 7707 612c ee0e 51ba 9909     .....0.w,a...Q..
    8f2c:	c419 076d f48f 706a a535 e963 95a3 9e64     ..m...jp5.c...d.
    8f3c:	8832 0edb b8a4 79dc e91e e0d5 d988 97d2     2......y........
    8f4c:	4c2b 09b6 7cbd 7eb1 2d07 e7b8 1d91 90bf     +L...|.~.-......
    8f5c:	1064 1db7 20f2 6ab0 7148 f3b9 41de 84be     d.... .jHq...A..
    8f6c:	d47d 1ada e4eb 6ddd b551 f4d4 85c7 83d3     }......mQ.......
    8f7c:	9856 136c a8c0 646b f97a fd62 c9ec 8a65     V.l...kdz.b...e.
    8f8c:	5c4f 1401 6cd9 6306 3d63 fa0f 0df5 8d08     O\...l.cc=......
    8f9c:	20c8 3b6e 105e 4c69 41e4 d560 7172 a267     . n;^.iL.A`.rqg.
    8fac:	e4d1 3c03 d447 4b04 85fd d20d b56b a50a     ...<G..K....k...
    8fbc:	a8fa 35b5 986c 42b2 c9d6 dbbb f940 acbc     ...5l..B....@...
    8fcc:	6ce3 32d8 5c75 45df 0dcf dcd6 3d59 abd1     .l.2u\.E....Y=..
    8fdc:	30ac 26d9 003a 51de 5180 c8d7 6116 bfd0     .0.&:..Q.Q...a..
    8fec:	f4b5 21b4 c423 56b3 9599 cfba a50f b8bd     ...!#..V........
    8ffc:	b89e 2802 8808 5f05 d9b2 c60c e924 b10b     ...(..._....$...
    900c:	7c87 2f6f 4c11 5868 1dab c161 2d3d b666     .|o/.LhX..a.=-f.
    901c:	4190 76dc 7106 01db 20bc 98d2 102a efd5     .A.v.q... ..*...
    902c:	8589 71b1 b51f 06b6 e4a5 9fbf d433 e8b8     ...q........3...
    903c:	c9a2 7807 f934 0f00 a88e 9609 9818 e10e     ...x4...........
    904c:	0dbb 7f6a 3d2d 086d 6c97 9164 5c01 e663     ..j.-=m..ld..\c.
    905c:	51f4 6b6b 6162 1c6c 30d8 8565 004e f262     .Qkkbal..0e.N.b.
    906c:	95ed 6c06 a57b 1b01 f4c1 8208 c457 f50f     ...l{.......W...
    907c:	d9c6 65b0 e950 12b7 b8ea 8bbe 887c fcb9     ...eP.......|...
    908c:	1ddf 62dd 2d49 15da 7cf3 8cd3 4c65 fbd4     ...bI-...|..eL..
    909c:	6158 4db2 51ce 3ab5 0074 a3bc 30e2 d4bb     Xa.M.Q.:t....0..
    90ac:	a541 4adf 95d7 3dd8 c46d a4d1 f4fb d3d6     A..J...=m.......
    90bc:	e96a 4369 d9fc 346e 8846 ad67 b8d0 da60     j.iC..n4F.g...`.
    90cc:	2d73 4404 1de5 3303 4c5f aa0a 7cc9 dd0d     s-.D...3_L...|..
    90dc:	713c 5005 41aa 2702 1010 be0b 2086 c90c     <q.P.A.'..... ..
    90ec:	b525 5768 85b3 206f d409 b966 e49f ce61     %.hW..o ..f...a.
    90fc:	f90e 5ede c998 29d9 9822 b0d0 a8b4 c7d7     ...^...)".......
    910c:	3d17 59b3 0d81 2eb4 5c3b b7bd 6cad c0ba     .=.Y....;\...l..
    911c:	8320 edb8 b3b6 9abf e20c 03b6 d29a 74b1      ..............t
    912c:	4739 ead5 77af 9dd2 2615 04db 1683 73dc     9G...w...&.....s
    913c:	0b12 e363 3b84 9464 6a3e 0d6d 5aa8 7a6a     ..c..;d.>jm..Zjz
    914c:	cf0b e40e ff9d 9309 ae27 0a00 9eb1 7d07     ........'......}
    915c:	9344 f00f a3d2 8708 f268 1e01 c2fe 6906     D.......h......i
    916c:	575d f762 67cb 8065 3671 196c 06e7 6e6b     ]Wb..ge.q6l...kn
    917c:	1b76 fed4 2be0 89d3 7a5a 10da 4acc 67dd     v....+..Zz...J.g
    918c:	df6f f9b9 eff9 8ebe be43 17b7 8ed5 60b0     o.......C......`
    919c:	a3e8 d6d6 937e a1d1 c2c4 38d8 f252 4fdf     ....~......8R..O
    91ac:	67f1 d1bb 5767 a6bc 06dd 3fb5 364b 48b2     .g..gW.....?K6.H
    91bc:	2bda d80d 1b4c af0a 4af6 3603 7a60 4104     .+..L....J.6`z.A
    91cc:	efc3 df60 df55 a867 8eef 316e be79 4669     ..`.U.g...n1y.iF
    91dc:	b38c cb61 831a bc66 d2a0 256f e236 5268     ..a...f...o%6.hR
    91ec:	7795 cc0c 4703 bb0b 16b9 2202 262f 5505     .w...G....."/&.U
    91fc:	3bbe c5ba 0b28 b2bd 5a92 2bb4 6a04 5cb3     .;..(....Z.+.j.\
    920c:	ffa7 c2d7 cf31 b5d0 9e8b 2cd9 ae1d 5bde     ....1......,...[
    921c:	c2b0 9b64 f226 ec63 a39c 756a 930a 026d     ..d.&.c...ju..m.
    922c:	06a9 9c09 363f eb0e 6785 7207 5713 0500     ....?6...g.r.W..
    923c:	4a82 95bf 7a14 e2b8 2bae 7bb1 1b38 0cb6     .J...z...+.{8...
    924c:	8e9b 92d2 be0d e5d5 efb7 7cdc df21 0bdb     ...........|!...
    925c:	d2d4 86d3 e242 f1d4 b3f8 68dd 836e 1fda     ....B......hn...
    926c:	16cd 81be 265b f6b9 77e1 6fb0 4777 18b7     ....[&...w.owG..
    927c:	5ae6 8808 6a70 ff0f 3bca 6606 0b5c 1101     .Z..pj...;.f\...
    928c:	9eff 8f65 ae69 f862 ffd3 616b cf45 166c     ..e.i.b...kaE.l.
    929c:	e278 a00a d2ee d70d 8354 4e04 b3c2 3903     x.......T..N...9
    92ac:	2661 a767 16f7 d060 474d 4969 77db 3e6e     a&g...`.MGiI.wn>
    92bc:	6a4a aed1 5adc d9d6 0b66 40df 3bf0 37d8     Jj...Z..f..@.;.7
    92cc:	ae53 a9bc 9ec5 debb cf7f 47b2 ffe9 30b5     S..........G...0
    92dc:	f21c bdbd c28a caba 9330 53b3 a3a6 24b4     ........0..S...$
    92ec:	3605 bad0 0693 cdd7 5729 54de 67bf 23d9     .6......)W.T.g.#
    92fc:	7a2e b366 4ab8 c461 1b02 5d68 2b94 2a6f     .zf..Ja...h].+o*
    930c:	be37 b40b 8ea1 c30c df1b 5a05 ef8d 2d02     7..........Z...-

0000931c <_init>:
    931c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    931e:	bf00      	nop
    9320:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9322:	bc08      	pop	{r3}
    9324:	469e      	mov	lr, r3
    9326:	4770      	bx	lr

00009328 <_fini>:
    9328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    932a:	bf00      	nop
    932c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    932e:	bc08      	pop	{r3}
    9330:	469e      	mov	lr, r3
    9332:	4770      	bx	lr

00009334 <__frame_dummy_init_array_entry>:
    9334:	0485 0000                                   ....

00009338 <__do_global_dtors_aux_fini_array_entry>:
    9338:	0471 0000                                   q...
